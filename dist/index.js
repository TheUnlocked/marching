(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen } = require( './var.js' )

const ops = { 
  Onion: {
    func( sdf,thickness ) { return `vec2( opOnion( ${sdf}.x, ${thickness} ), ${sdf}.y )` },
    variables:[['thickness', 'float', .03]]
  },
  Halve: {
    func( sdf, direction ) { return `vec2( opHalve( ${sdf}.x, p, ${direction} ), ${sdf}.y )` },
    variables:[['direction','int',0]]
  },
  Round: {
    func( sdf, amount ) { return `vec2( ${sdf}.x - ${amount}, ${sdf}.y )` },
    variables:[['amount','float',.1]]
  }
}


const Alterations= {}

for( let name in ops ) {

  // get codegen function
  let op = ops[ name ]

  // create constructor
  Alterations[ name ] = function( sdf, ...args ) {
    const __op = Object.create( Alterations[ name ].prototype )
    __op.sdf = sdf
    __op.variables = []
    __op.__desc = { parameters:[] }

    for( let i = 0; i < op.variables.length; i++ ) {
      const propArray = op.variables[ i ]
      const propName = propArray[ 0 ]
      const propType = propArray[ 1 ]
      const propValue = args[ i ] === undefined ? propArray[ 2 ] : args[ i ]

      __op.__desc.parameters.push({ name:propName, value:propValue })
      let param

      switch( propType ) {
        case 'int':
          param = int_var_gen( propValue )()
          break;
        default:
          param = float_var_gen( propValue )()
          break;
      }
      
      Object.defineProperty( __op, propName, {
        get() { return param },
        set(v) { param.set( v ) }
      })

      __op.variables.push( param )
    }
      
    __op.matId = MaterialID.alloc()

    return __op
  } 

  Alterations[ name ].prototype = SceneNode()

  Alterations[ name ].prototype.emit = function ( __name ) {
    const emitterA = this.sdf.emit( __name )
    //const emitterB = this.b.emit()

    const output = {
      out: op.func( emitterA.out, ...this.variables.map( v => v.emit() ) ), 
      preface: (emitterA.preface || '') 
    }

    return output
  }

  Alterations[name].prototype.emit_decl = function () {
    let str =  this.sdf.emit_decl() 
    for( let v of this.variables ) {
      str += v.emit_decl()
    }

    return str
  };

  Alterations[name].prototype.update_location = function(gl, program) {
    this.sdf.update_location( gl, program )
    for( let v of this.variables ) v.update_location( gl, program )
  }

  Alterations[name].prototype.upload_data = function(gl) {
    this.sdf.upload_data( gl )
    for( let v of this.variables ) v.upload_data( gl )
    
  }
}

Alterations.Halve.UP = 0
Alterations.Halve.DOWN = 1
Alterations.Halve.LEFT = 3
Alterations.Halve.RIGHT = 2

module.exports = Alterations

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28}],2:[function(require,module,exports){
const Audio = {
  __hasInput: false,
  ctx: null,

  start() {
    if( Audio.__hasInput === false ) {
      Audio.ctx = new AudioContext()
      Audio.createInput().then( input => {
        Audio.createFFT()
        input.connect( Audio.FFT )

        Audio.interval = setInterval( Audio.fftCallback, 1000/60 )
        //window.FFT = Audio.FFT
      })
    }
    Audio.__hasInput = true
  },

  createInput() {
    console.log( 'connecting audio input...' )
    
    const p = new Promise( resolve => {
      console.log( 'start?' )
      navigator.mediaDevices.getUserMedia({ audio:true, video:false })
        .then( stream => {
          console.log( 'audio input connected' )
          Audio.input = Audio.ctx.createMediaStreamSource( stream )
          //Audio.mediaStreamSource.connect( Gibberish.node )
          Audio.__hasInput = true
          resolve( Audio.input )
        })
        .catch( err => { 
          console.log( 'error opening audio input:', err )
        })
    })
    return p
  },

  createFFT() {
    Audio.FFT = Audio.ctx.createAnalyser()

    let __windowSize = 512
    Object.defineProperty( Audio, 'windowSize', {
      get() { return __windowSize },
      set(v){
        __windowSize = v
        Audio.FFT.fftSize = v 
        Audio.FFT.values = new Uint8Array( Audio.FFT.frequencyBinCount )
      }
    })

    Audio.windowSize = 512
  },

  fftCallback() {
    Audio.FFT.getByteFrequencyData( Audio.FFT.values )
    
    let lowSum, midSum, highSum, lowCount, midCount, highCount
    lowSum = midSum = highSum = lowCount = midCount = highCount = 0

    let frequencyCounter = 0

    // does this start at 0Hz? ack... can't remember... does it include DC offset?
    const hzPerBin = (Audio.ctx.sampleRate / 2) / Audio.FFT.frequencyBinCount
    const lowRange = 150, midRange = 1400, highRange = Audio.ctx.sampleRate / 2

    for( let i = 1; i < Audio.FFT.frequencyBinCount; i++ ) {
      if( frequencyCounter < lowRange ) {
        lowSum += Audio.FFT.values[ i ]
        lowCount++
      }else if( frequencyCounter < midRange ) {
        midSum += Audio.FFT.values[ i ]
        midCount++
      }else{
        highSum += Audio.FFT.values[ i ]
        highCount++
      }

      frequencyCounter += hzPerBin
    }

    Audio.low = (lowSum / lowCount) / 255
    Audio.mid = (midSum / midCount) / 255 || 0
    Audio.high = (highSum / highCount) / 255
  }
}

module.exports = Audio

},{}],3:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' )

const BG = function( Scene, SDF ) {

  const Background = function( color ) {
    if( SDF.memo.background === undefined ) {
      const bg = Object.create( Background.prototype )

      const __color = param_wrap( color, vec3_var_gen( 0,0,0, 'bg' ), 'bg' )  
      
      Object.defineProperty( bg, 'color', {
        get() { return __color },
        set( v ) {
          __color.var.set( v )
        }
      })
      
      // this refers to the current scene via implicit binding in scene.js
      this.postprocessing.push( bg )

      SDF.memo.background = true
    }
    return this
  }

  Background.prototype = SceneNode()
 
  Object.assign( Background.prototype, {
    emit() {
      return ''//this.color.emit()
    },
   
    emit_decl() {
      let str = this.color.emit_decl()
      SDF.memo.background = true

      return str
    },

    update_location( gl, program ) {
      this.color.update_location( gl, program )
    },

    upload_data( gl ) {
      this.color.upload_data( gl )
    }
  })

  return Background
}

module.exports = BG 

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28}],4:[function(require,module,exports){
const vec3 = require('gl-vec3')
const mat4 = require('gl-mat4')

// camera adapted from https://github.com/shama/first-person-camera
function FirstPersonCamera(opts) {
  if (!(this instanceof FirstPersonCamera)) return new FirstPersonCamera(opts)
  opts = opts || {}
  this.position = opts.position || vec3.create()
  this.rotation = opts.rotation || vec3.create()
  this.positionSpeed = opts.positionSpeed || -.5
  this.rotationSpeed = opts.rotationSpeed || .01
}
module.exports = FirstPersonCamera

FirstPersonCamera.prototype.view = function(out) {
  if (!out) out = mat4.create()
  // altered x/y ordering from original
  mat4.rotateY(out, out, this.rotation[1])
  mat4.rotateX(out, out, this.rotation[0])
  mat4.rotateZ(out, out, this.rotation[2] - Math.PI)
  mat4.translate(out, out, [-this.position[0], -this.position[1], -this.position[2]])

  return out
}

FirstPersonCamera.prototype.control = function(dt, move, mouse, prevMouse) {
  var speed = (this.positionSpeed / 1000) * dt
  var dir = [0,0,0]
  if (move[0]) dir[2] -= speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[1]) dir[2] += speed * (Marching.keys.Alt ? 4 : 1 )
  if (move[2]) dir[0] += speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[3]) dir[0] -= speed * (Marching.keys.Alt ? 4 : 1 )
  if (move[4]) dir[1] -= speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[5]) dir[1] += speed * (Marching.keys.Alt ? 4 : 1 )
  this.move(dir)
  // just use arrow keys instead of mouse
  // this.pointer(mouse, prevMouse)
}

FirstPersonCamera.prototype.move = function(dir) {
  if (dir[0] !== 0 || dir[1] !== 0 || dir[2] !== 0) {
    var cam = mat4.create()
    mat4.rotateY(cam, cam, this.rotation[1])
    mat4.rotateX(cam, cam, this.rotation[0])
    vec3.transformMat4(dir, dir, cam)
    vec3.add(this.position, this.position, dir)
  }
}

//FirstPersonCamera.prototype.pointer = function(da, db) {
//  var dt = [da[0] - db[0], da[1]- db[1]]
//  var rot = this.rotation
//  rot[1] -= dt[0] * this.rotationSpeed
//  if (rot[1] < 0) rot[1] += Math.PI * 2
//  if (rot[1] >= Math.PI * 2) rot[1] -= Math.PI * 2
//  rot[0] -= dt[1] * this.rotationSpeed
//  if (rot[0] < -Math.PI * .5) rot[0] = -Math.PI*0.5
//  if (rot[0] > Math.PI * .5) rot[0] = Math.PI*0.5
//}

const Camera = {
  init( gl, program, handler ) {
    const camera = FirstPersonCamera({
      fov: 190,
      near:.01,
      far:10,
      direction:[0,0,1],
      viewport:[1,1,1,-1]
    })
    camera.rotation = [0,Math.PI,Math.PI] 
    Camera.__camera = camera

    const camera_pos    = gl.getUniformLocation( program, 'camera_pos' )
    const camera_normal = gl.getUniformLocation( program, 'camera_normal' )
    const camera_rot    = gl.getUniformLocation( program, 'camera_rot' )
    const ucamera       = gl.getUniformLocation( program, 'camera' )

    this.pos = { dirty:false }
    this.dir = { dirty:true }
    this.__rot = { dirty:true, value:0 }

    Object.defineProperty( this, 'rotation', {
      configurable:true,
      get() { return this.__rot.value },
      set(v) { 
        this.__rot.value = v 
        this.__rot.dirty = true
      }
    })

    let px = 0, py =0, pz = 5, nx = 0, ny = 0, nz = 0
    Object.defineProperties( this.pos, {
      x: {
        get()  { return px },
        set(v) { px = camera.position[0] = v;this.dirty = true; }
      },

      y: {
        get()  { return py },
        set(v) { py = camera.position[1] = v; this.dirty = true; }
      },

      z: {
        get()  { return pz },
        set(v) { pz = camera.position[2] = v; this.dirty = true; }
      },
    })

    Object.defineProperties( this.dir, {
      x: {
        get()  { return nx },
        set(v) { nx = camera.rotation[0] = v; this.dirty = true; }
      },

      y: {
        get()  { return ny },
        set(v) { ny = camera.rotation[1] = v; this.dirty = true; }
      },

      z: {
        get()  { return nz },
        set(v) { nz = camera.rotation[2] = v; this.dirty = true; }
      },
    })

    let init = false
    gl.uniform3f( camera_normal, this.dir.x, this.dir.y, this.dir.z )
    camera.position = [this.pos.x, this.pos.y, this.pos.z ] 
    //camera.update()
    gl.uniform3f( camera_pos, this.pos.x, this.pos.y, this.pos.z )
    gl.uniformMatrix4fv( ucamera, false, camera.view() )
    gl.uniform1f( camera_rot, this.rot ) 

    Camera.move = (x,y,z) => {
      // XXX does this need to update property values?
      camera.move([x,y,z])
      Camera.update()
    }
    Camera.moveTo = (x,y,z) => {
      Camera.pos.x = x
      Camera.pos.y = y
      Camera.pos.z = z
    }
    Camera.update = ()=> {
      const pos = camera.position
      gl.uniform3f( camera_pos, pos[0], pos[1], pos[2]  )
      gl.uniformMatrix4fv( ucamera, false, camera.view() )
    }

    let prvx = 0, prvy = 0, x = 0, y = 0
    Camera.__mousemovefnc = e => {
      prvx = x
      prvy = y
      x = e.pageX
      y = e.pageY
    }

    let prevTime = 0
    let k  = Marching.keys
    Camera.__framefnc = t => {
      if( k.ArrowLeft ) camera.rotation[1] += camera.rotationSpeed
      if( k.ArrowRight ) camera.rotation[1] -= camera.rotationSpeed
      if( k.ArrowUp && !k.Shift ) camera.rotation[0] -= camera.rotationSpeed
      if( k.ArrowDown && !k.Shift) camera.rotation[0] += camera.rotationSpeed
      
      if( Marching.cameraEnabled ) { 
        camera.control( 
          t*1000 - prevTime,
          [k.w,k.s,k.d,k.a,k.ArrowUp && k.Shift, k.ArrowDown && k.Shift], 
          [x,y], [prvx,prvy] 
        )
        Camera.update()
        prvx = x
        prvy = y
        prevTime = t*1000
      }
    }

    Camera.__mousemove = null
    Camera.on = ()=> {
      if( Camera.__mousemove === null ) {
        window.addEventListener( 'mousemove', Camera.__mousemovefnc )
        Camera.__mousemove = true
      }
      if( Marching.callbacks.indexOf( Camera.__framefnc ) === -1 ) {
        Marching.callbacks.push( Camera.__framefnc )
      }
    }

    handler( ()=> {
      if( this.pos.dirty === true ) {
        //camera.position = [this.pos.x, this.pos.y, this.pos.z ]
 
        //camera.position = [this.pos.x, this.pos.y, this.pos.z ]
        //camera.update()
        const pos = camera.position
        gl.uniform3f( camera_pos, pos[0], pos[1], pos[2] )
        gl.uniformMatrix4fv( ucamera, false, camera.view() )
        this.pos.dirty = false
      }

      // XXX this is broken and needs to be fixed
      if( this.dir.dirty === true ) {
        gl.uniform3f( camera_normal, this.dir.x, this.dir.y, this.dir.z )
        gl.uniformMatrix4fv( ucamera, false, camera.view() )
        this.dir.dirty = false
      }
      if( this.__rot.dirty === true ) {
        gl.uniform1f( camera_rot, this.__rot.value )
        this.__rot.dirty = false
      }
    })

  }
}

module.exports = Camera

},{"gl-mat4":58,"gl-vec3":92}],5:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const Transform = require( './transform.js' )

const ops = { 
  // this needs to create an opOut, not return a vec2
  Displace( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( name );

    const sdfStr = `float d1${this.id} = ${sdf.out}.x;\n`

    let displaceString = `float d2${this.id} = sin( ${this.amount.emit()}.x * ${name}.x ) * `  
    displaceString += `sin( ${this.amount.emit()}.y * ${name}.y ) * `
    displaceString += `sin( ${this.amount.emit()}.z * ${name}.z );\n`
    displaceString += `${sdf.out}.x = (d1${this.id} + d2${this.id}*${this.size.emit()})*.5;\n`

    const output = {
      out: `${sdf.out}`, 
      preface: sdf.preface + sdfStr + displaceString 
    }

    return output
  },

  Bend( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( 'q'+this.id );

    let preface=`        float c${this.id} = cos( ${this.amount.emit()}.x * ${name}.x );
        float s${this.id} = sin( ${this.amount.emit()}.x * ${name}.x );
        mat2  m${this.id} = mat2( c${this.id},-s${this.id},s${this.id},c${this.id} );
        vec4  q${this.id} = vec4( m${this.id} * ${name}.xy, ${name}.z, 1. );\n`

    if( typeof sdf.preface === 'string' ) {
      preface += sdf.preface
    }

    return { preface, out:sdf.out }
  },

  Twist( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( 'q'+this.id );

    let preface=`        float c${this.id} = cos( ${this.amount.emit()}.x * ${name}.y );
        float s${this.id} = sin( ${this.amount.emit()}.x * ${name}.y );
        mat2  m${this.id} = mat2( c${this.id},-s${this.id},s${this.id},c${this.id} );
        vec4  q${this.id} = vec4( m${this.id} * ${name}.xz, ${name}.y, 1. );\n`

    if( typeof sdf.preface === 'string' ) {
      preface += sdf.preface
    }

    return { preface, out:sdf.out }
  },
  __Bump( __name ) {
    let name = __name === undefined ? 'p' : __name

    const bumpString =  `        vec4 transformBump${this.id} = ${name} * ${this.transform.emit()};\n`
    const tex = this.amount.emit( name )

    const pointString = `(transformBump${this.id} * ${this.sdf.transform.emit()})`

    const sdf = this.sdf.emit( pointString, this.transform, `tex${this.id}` ) 

    Marching.textures.addTexture( this.amount.value )

    let preface=`  vec3 tex${this.id} = getTexture( ${this.amount.value.id}, ${pointString}.xyz ) * ${this.size.emit()};\n
        //vec4 displaceBump${this.id} = vec4((${pointString} - tex${this.id}), 1.);
    `
        //${sdf.out}.x = (tex${this.id}.x + tex${this.id}.y + tex${this.id}.z ) / 3. * .5 + ${sdf.out}.x;\n`
        //vec4 ${'p'+this.id} = vec4(${pointString} + tex${this.id}, 1.);\n`

    //sdf.preface += `\n        
    //    ${sdf.out}.x -= min(tex${this.id}.x, min(tex${this.id}.y, tex${this.id}.z));\n` 

    if( typeof sdf.preface === 'string' ) {
      preface = preface + sdf.preface
    }

    preface =  bumpString + preface

    return { preface, out:sdf.out }
  },
  // XXX todo: something like https://www.shadertoy.com/view/ldSGzR
  // https://www.dropbox.com/s/l1yl164jb3rhomq/mm_sfgrad_bump.pdf?dl=0
  Bump( __name ) {
    let name = __name === undefined ? 'p' : __name

    const bumpString =  `        vec4 transformBump${this.id} = ${name} * ${this.transform.emit()};\n`
    const tex = this.amount.emit( name )

    const pointString = `(transformBump${this.id} * ${this.sdf.transform.emit()}).xyz`

    const sdf = this.sdf.emit( `transformBump${this.id}`, this.transform ) 

    Marching.textures.addTexture( this.amount.value )

    let preface=`  vec3 tex${this.id} = getTexture( ${this.amount.value.id}, ${pointString}) * ${this.size.emit()};
        ${sdf.out}.x = (tex${this.id}.x + tex${this.id}.y + tex${this.id}.z)/3. + ${sdf.out}.x;\n`

    if( typeof sdf.preface === 'string' ) {
      preface = sdf.preface + preface
    }

    preface = bumpString + preface

    return { preface, out:sdf.out }
  },
}

const DistanceOps = {}

for( let name in ops ) {

  // get codegen function
  let __op = ops[ name ]

  // create constructor
  DistanceOps[ name ] = function( a,b,c ) {
    const op = Object.create( DistanceOps[ name ].prototype )
    op.sdf = a
    op.amount = b
    op.emit = __op
    op.name = name
    op.transform = Transform()

    const defaultValues = [.5,.5,.5]

    op.id = VarAlloc.alloc()
    const isArray = true 
    
    if( typeof b === 'number' ) {
      b = [b,b,b]
      b.type = 'vec3'
    }
    
    if( name !== 'Bumpz' ) {
      let __var =  param_wrap( 
        b, 
        vec3_var_gen( ...defaultValues ) 
      )

      // for assigning entire new vectors to property
      Object.defineProperty( op, 'amount', {
        get() { return __var },
        set(v) {
          if( typeof v === 'object' ) {
            __var.set( v )
          }else{
            __var.value.x = v
            __var.value.y = v
            __var.value.z = v
            __var.value.w = v
            __var.dirty = true
          }
        }
      })

      op.params = [{ name:'amount' }]
    }else{
      op.params = []
      op.emit_decl = function() {}
      op.emit = function() {}
      op.update_data= function() {}
      op.upload_location = function() {}
    }
    op.__setMaterial = function(mat) {
      if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
      this.__material = this.mat = Marching.materials.addMaterial( mat )
      op.sdf.material( this.__material )
    }
    if( name === 'Displace' || name === 'Bump' ) {
      let __var2 =  param_wrap( 
        c, 
        float_var_gen( .03 ) 
      )
      Object.defineProperty( op, 'size', {
        get() { return __var2 },
        set(v) {
          __var2.set( v )
          __var2.dirty = true
        }
      })

      op.params.push({ name:'size' })
    }
    op.__desc = { parameters:op.params }
    return op
  } 

  DistanceOps[ name ].prototype = SceneNode()

  DistanceOps[name].prototype.emit_decl = function () {
    let str =  this.sdf.emit_decl() + (this.name !== 'Bump' ? this.amount.emit_decl() : '')
    str += this.transform.emit_decl()
    if( this.name === 'Displace' || this.name === 'Bump' ) str += this.size.emit_decl()  

    return str
  };

  DistanceOps[name].prototype.update_location = function(gl, program) {
    this.sdf.update_location( gl, program )
    if( this.name !== 'Bump' ) this.amount.update_location( gl, program )
    if( this.name === 'Displace' || this.name === 'Bump') this.size.update_location( gl, program ) 
    this.transform.update_location( gl, program )
  }

  DistanceOps[name].prototype.upload_data = function(gl) {
    this.sdf.upload_data( gl )
    if( this.name !== 'Bump' ) this.amount.upload_data( gl )
    if( this.name === 'Displace' || this.name === 'Bump') this.size.upload_data( gl )
    this.transform.upload_data( gl )
  }
}

module.exports = DistanceOps


},{"./sceneNode.js":22,"./transform.js":26,"./utils.js":27,"./var.js":28}],6:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const Transform = require( './transform.js' )
const glslops = require( './distanceOperationsGLSL.js' )

const opslen = { 
  Union:2,
  Intersection:2,
  Difference:2,
  StairsUnion:4,
  StairsIntersection:4,
  StairsDifference:4,
  RoundUnion:3,
  RoundDifference:3,
  RoundIntersection:3,
  ChamferUnion:3,
  ChamferDifference:3,
  ChamferIntersection:3,
  Pipe:3,
  Engrave:3,
  Groove:4,
  Tongue:4,
  
  // these two do not currently have support for transforms or repeats...
  Onion:2,
  Switch:2
}

const ops = { 
  Union( ...args ) { return `opU( ${args.join(',')} )` },
  SmoothUnion( ...args  ) { return `opSmoothUnion( ${args.join(',')} )` },
  Intersection( ...args ) { return `opI( ${args.join(',')} )` },
  SmoothIntersection( ...args ) { return `opSmoothIntersection( ${args.join(',')} )` },  
  Difference( ...args ) { return `opS( ${args.join(',')} )` },  
  SmoothDifference( ...args ) { return `opSmoothSubtraction( ${args.join(',')} )` },  
  StairsUnion(  ...args ) { return `fOpUnionStairs( ${args.join(',')} )`  },
  StairsIntersection( ...args ) { return `fOpIntersectionStairs( ${args.join(',')} )` },
  StairsDifference( ...args ) { return `fOpSubstractionStairs( ${args.join(',')} )` },
  RoundUnion( ...args ) { return `fOpUnionRound( ${args.join(',')} )` },
  RoundDifference( ...args ) { return `fOpDifferenceRound( ${args.join(',')} )` },
  RoundIntersection( ...args ) { return `fOpIntersectionRound( ${args.join(',')} )` },
  ChamferUnion( ...args ) { return `fOpUnionChamfer( ${args.join(',')} )` },
  ChamferDifference( ...args ) { return `fOpDifferenceChamfer( ${args.join(',')} )` },
  ChamferIntersection( ...args ) { return `fOpIntersectionChamfer( ${args.join(',')} )` },
  Pipe( ...args ) { return `fOpPipe( ${args.join(',')} )` },
  Engrave( ...args ) { return `fOpEngrave( ${args.join(',')} )` },
  Groove( ...args ) { return `fOpGroove( ${args.join(',')} )` },
  Tongue( ...args ) { return `fOpTongue( ${args.join(',')} )` },
  
  // these two do not currently have support for transforms or repeats...
  Onion( a,b ) { return `opOnion( ${a}, ${b} )` },
  Switch( a,b,c,d,e,f ) { return `opSwitch( ${a}, ${b}, ${c} )` }
}

const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

const DistanceOps = {
  __glsl:[],
  __getGLSL() {
    return this.__glsl.join('\n')
  },
  __clear() { this.__glsl.length = 0 }
}


for( let name in ops ) {

  // get codegen function
  let op = ops[ name ]
  const name2 = name + '2'

  // create constructor
  DistanceOps[ name ] = function( a,b,c,d ) {
    const op = Object.create( DistanceOps[ name ].prototype )
    op.a = a
    op.b = b
    op.transform = Transform( false )
    op.id = VarAlloc.alloc()
    op.type = 'domain_op'

    let __c = param_wrap( c, float_var_gen(.3) )

    op.__len = opslen[ name ]
    if( op.__len > 2 ) {
      Object.defineProperty( op, 'c', {
        get() { return __c },
        set(v) {
          __c.set( v )
        }
      })
      
      if( op.__len > 3 ) {
        let __d = param_wrap( d, float_var_gen(4) )

        Object.defineProperty( op, 'd', {
          get() { return __d },
          set(v) {
            __d.set( v )
          }
        })
      }
    }

    op.__setTexture = function(tex,props) {
      if( typeof tex === 'string' ) {
        this.texture = op.texture.bind( this )
        this.__textureObj = this.tex = Marching.Texture( tex,props,this.texture )
        this.__textureID = this.__textureObj.id
      }else{
        this.__textureObj = this.tex = Object.assign( tex, props )
        this.__textureID = this.__textureObj.id
      }
    }
    op.__setMaterial = function(mat) {
      if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
      this.__material = this.mat = Marching.materials.addMaterial( mat )
    }
    op.__setBump = function(tex,props) {
      //this.bump = p.bump.bind( this )
      const b = this.bump = this.__bumpObj = Marching.Bump( this, tex, props )
      this.bump.texture = this.bump.amount.value
      this.__bumpID = this.__bumpObj.id
      this.rotate = this.bump.rotate
      this.translate = this.bump.translate
      this.scale = this.bump.scale
      Object.defineProperty( this.bump, 'strength', {
        get() { return b.size },
        set(v){ b.size = v }
      })
    }
    Object.assign( op, {
      renderingBump : false,
      emittingDecl  : false,
      uploading     : false,
      updating      : false
    })

    let repeat = null
    Object.defineProperty( op, 'repeat', {
      get() { return repeat },
      set(v){ 
        repeat = v
        this.a.repeat = v
        this.b.repeat = v
      }
    })

    op.matId = MaterialID.alloc()

    op.params = [{name:'c'},{ name:'d'}]
    op.__desc = { parameters: op.params }

    return op
  } 
  
  DistanceOps[ name2 ] = function( ...args ) {
    // accepts unlimited arguments, but the last one could be a blending coefficient
    let blend = .25, coeff=4, u

    if( typeof args[ args.length - 1 ] === 'number' ) {
      blend = args.pop()

      // if there are two non-sdf arguments to the function...
      if( typeof args[ args.length - 1 ] === 'number' ) {
        coeff = blend
        blend = args.pop()
      }

      u = args.reduce( (state,next) => DistanceOps[ name ]( state, next, blend, coeff ) )
    }else{
      u = args.reduce( (state,next) => DistanceOps[ name ]( state, next ) )
    }

    return u
  }

  DistanceOps[ name ].prototype = SceneNode()

  DistanceOps[ name ].prototype.texture = function( ...args ) {
    this.__setTexture( ...args )
    this.a.texture( this.__textureObj )
    this.b.texture( this.__textureObj )

    return this
  }
  DistanceOps[ name ].prototype.material = function( ...args ) {
    this.__setMaterial( ...args )
    this.a.material( this.__material )
    this.b.material( this.__material )

    return this
  }

  const pushString = function( name ) {
    const glslobj = glslops[ name ]
    
    // some definitions are a single string, and not split into
    // separate float and opOut functions
    if( typeof glslobj === 'string' ) {
      if( DistanceOps.__glsl.indexOf( glslobj ) === -1 ) {
        DistanceOps.__glsl.push( glslobj )
      }
    }else{
      // some distance operations are dependent on other ones...
      // if this one has dependencies add them.
      // dependencies must be added before adding other functions
      // so that they're above them in the final GLSL code.
      if( glslobj.dependencies !== undefined ) {
        for( let dname of glslobj.dependencies ) {
          const d = glslops[ dname ]
          if( DistanceOps.__glsl.indexOf( d.float ) === -1 ) {
            DistanceOps.__glsl.push( d.float )
          }
        }
      }  
      if( DistanceOps.__glsl.indexOf( glslobj.float ) === -1 ) {
        DistanceOps.__glsl.push( glslobj.float )
      }
      if( DistanceOps.__glsl.indexOf( glslobj.vec2) === -1 ) {
        DistanceOps.__glsl.push( glslobj.vec2 )
      }
    }
  }

  DistanceOps[ name ].prototype.emit = function ( pname='p', transform = null ){
    if( this.__bumpObj !== undefined && this.renderingBump === false) {
      this.renderingBump = true
      return this.__bumpObj.emit( pname, transform )
    }
    pushString( name )

    if( transform !== null ) this.transform.apply( transform, false )
    //this.transform.internal()

    // first two args are fixed, rest are variable
    let emitters = []
    const a = this.a.emit( pname, this.transform ), 
          b = this.b.emit( pname, this.transform ) 

    emitters[0] = a.out
    emitters[1] = b.out
    if( this.__len > 2 ) emitters.push( this.c.emit() )
    if( this.__len > 3 ) emitters.push( this.d.emit() )
    
    const body = `
        vec2 do${this.id} = ${op( ...emitters )};
        do${this.id}.x *= ${this.transform.emit()}_scale;
    `

    const output = {
      out: 'do'+this.id,
      preface: (a.preface || '') + (b.preface || '') + body
    }

    this.renderingBump = false
    return output
  }

  DistanceOps[name].prototype.emit_decl = function () {
    if( this.__bumpObj !== undefined && this.emittingDecl === false) {
      this.emittingDecl = true
      return this.__bumpObj.emit_decl() 
    }
    let str =  this.transform.emit_decl() + this.a.emit_decl() + this.b.emit_decl()
    if( this.c !== undefined ) str += this.c.emit_decl()
    if( this.d !== undefined ) str += this.d.emit_decl()

    if( ops[ name ].code !== undefined ) {
      //str += ops[ name ].code
      if( Marching.requiredOps.indexOf( ops[ name ].code ) === - 1 ) {
        Marching.requiredOps.push( ops[ name ].code )
      }
    }

    this.emittingDecl = false
    return str
  };

  DistanceOps[name].prototype.update_location = function(gl, program) {
    if( this.__bumpObj !== undefined && this.updating === false) {
      this.updating = true
      return this.__bumpObj.update_location( gl, program )
    }
    this.a.update_location( gl, program )
    this.transform.update_location( gl, program )
    this.b.update_location( gl, program )
    if( this.c !== undefined ) this.c.update_location( gl, program )
    if( this.d !== undefined ) this.d.update_location( gl, program )

    this.updating = false
  }

  DistanceOps[name].prototype.upload_data = function(gl) {
    if( this.__bumpObj !== undefined && this.uploading  === false ) {
      this.uploading = true
      return this.__bumpObj.upload_data( gl )
    }
    this.transform.internal()
    this.transform.upload_data( gl )
    this.a.transform.apply( this.transform )
    this.b.transform.apply( this.transform )
    this.a.upload_data( gl )
    this.b.upload_data( gl )
    if( this.c !== undefined ) this.c.upload_data( gl )
    if( this.d !== undefined ) this.d.upload_data( gl )
    this.uploading = false
    
  }
}

module.exports = DistanceOps

},{"./distanceOperationsGLSL.js":7,"./sceneNode.js":22,"./transform.js":26,"./utils.js":27,"./var.js":28}],7:[function(require,module,exports){
module.exports = {
  Union:{
    float:`
      float opU( float d1, float d2 ) {
        return min(d1,d2);
      }
      `,
    vec2:`
      vec2 opU( vec2 d1, vec2 d2 ) {
        vec2 o;

        if( d1.x < d2.x ) {
          o = d1;
        }else{
          o = d2; 
        }

        return o;
      }
      `
  },
  Intersection:{
    float:`
      float opI( float d1, float d2 ) {
        return max(d1,d2);
      }
      `,
    vec2:`
      vec2 opI( vec2 d1, vec2 d2  ) {
        vec2 o;

        if( d1.x > d2.x ) {
          o = d1; 
        }else{
          o = d2; 
        }

        return o;
      }
      `
  },

  Difference:{
    float:`
      float opS( float d1, float d2 ) { return max(d1,-d2); }
      `,
    vec2:`
      vec2 opS( vec2 d1, vec2 d2  ) {
        vec2 o;

        if( d1.x >= -d2.x ) {
          o = d1; 
        }else{
          d2.x *= -1.;
          o = d2;
        }

        return o;
      }
      `
  },

  StairsUnion:{
    float:`
      float fOpUnionStairs(float a, float b, float r, float n) {
        float s = r/n;
        float u = b-r;
        return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));
      }`,
    vec2:`
      vec2 fOpUnionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 

        if( d1.x <= d2.x ) {
          o.y = d1.y; 
        }else{
          o.y = d2.y; 
        }

        o.x = fOpUnionStairs( d1.x, d2.x, r, n );

        return o;
      }
      `
  },
  StairsIntersection:{
    dependencies: ['StairsUnion'],
    float:`
      // We can just call Union since stairs are symmetric.
      float fOpIntersectionStairs(float a, float b, float r, float n) {
        return -fOpUnionStairs(-a, -b, r, n);
      }
      `,
    vec2:`
      vec2 fOpIntersectionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = -fOpUnionStairs( -d1.x, -d2.x, r, n );

        if( -d1.x <= -d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  StairsDifference:{
    dependencies: ['StairsUnion'],
    float:`
      float fOpSubstractionStairs(float a, float b, float r, float n) {
        return -fOpUnionStairs(-a, b, r, n);
      }`,
    vec2:`
      vec2 fOpSubstractionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = -fOpUnionStairs( -d1.x, d2.x, r, n );

        if( -d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  RoundUnion:{
    float:`
      float fOpUnionRound(float a, float b, float r) {
        vec2 u = max(vec2(r - a,r - b), vec2(0));
        return max(r, min (a, b)) - length(u);
      }`,

    vec2:`
      vec2 fOpUnionRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpUnionRound( d1.x, d2.x, r );

        if( d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  RoundIntersection:{
    float:`
      float fOpIntersectionRound(float a, float b, float r) {
        vec2 u = max(vec2(r + a,r + b), vec2(0));
        return min(-r, max (a, b)) + length(u);
      }`,
    vec2:`
      vec2 fOpIntersectionRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpIntersectionRound( d1.x, d2.x, r );

        if( d1.x >= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  RoundDifference:{
    dependencies: ['RoundIntersection'],
    float:`
      float fOpDifferenceRound (float a, float b, float r) {
        return fOpIntersectionRound(a, -b, r);
      }`,
    vec2:`
      vec2 fOpDifferenceRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpDifferenceRound( d1.x, d2.x, r );

        if( d1.x >= -d2.x ) {
          o.y = d1.y; 
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  ChamferUnion:{
    float:`
      float fOpUnionChamfer(float a, float b, float r) {
        return min(min(a, b), (a - r + b)*sqrt(0.5));
      }`,
    vec2:`
      vec2 fOpUnionChamfer( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpUnionChamfer( d1.x, d2.x, r );

        if( d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  ChamferIntersection:{
    float:`
      float fOpIntersectionChamfer(float a, float b, float r) {
        return max(max(a, b), (a + r + b)*sqrt(0.5));
      }`,
    vec2:`
      vec2 fOpIntersectionChamfer( vec2 d1, vec2 d2, float r   ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpIntersectionChamfer( d1.x, d2.x, r );

        if( d1.x >= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  ChamferDifference:{
    dependencies:['ChamferIntersection'],
    float:`
      float fOpDifferenceChamfer (float a, float b, float r) {
        return fOpIntersectionChamfer(a, -b, r);
      }`,
    vec2:`
      vec2 fOpDifferenceChamfer( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpDifferenceChamfer( d1.x, d2.x, r );

        if( d1.x >= -d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  Pipe:`
      float fOpPipe(float a, float b, float r) {
        return length(vec2(a, b)) - r;
      }
      vec2 fOpPipe( vec2 d1, vec2 d2, float r   ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpPipe( d1.x, d2.x, r );

        return o;
      }
      `,

  Engrave:`
      float fOpEngrave(float a, float b, float r) {
        return max(a, (a + r - abs(b))*sqrt(0.5));
      }
      vec2 fOpEngrave( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpEngrave( d1.x, d2.x, r );

        return o;
      }
      `,
  Groove:`
      float fOpGroove(float a, float b, float ra, float rb) {
        return max(a, min(a + ra, rb - abs(b)));
      }
      vec2 fOpGroove( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpGroove( d1.x, d2.x, r, n );

        return o;
      }
      `,

  Tongue:`
      float fOpTongue(float a, float b, float ra, float rb) {
        return min(a, max(a - ra, abs(b) - rb));
      }
      vec2 fOpTongue( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpTongue( d1.x, d2.x, r, n );

        return o;
      }
      `,
  Onion:`
      float opOnion( in float sdf, in float thickness ){
        return abs(sdf)-thickness;
      }

      float opHalve( in float sdf, vec3 p, in int dir ){
        float _out = 0.;
        switch( dir ) {
          case 0:  
            _out = max( sdf, p.y );
            break;
          case 1:
            _out = max( sdf, -p.y );
            break;
          case 2:
            _out = max( sdf, p.x );
            break;
          case 3:
            _out = max( sdf, -p.x );
            break;
        }

        return _out;
      }
      `,

  Switch:`
      vec2 opSwitch( vec2 a, vec2 b, float c ) {
        if( c < .5 ) {
          return a;
        }else{
          return b;
        } 
      }
      `
}

},{}],8:[function(require,module,exports){
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const Transform = require( './transform.js' )

const descriptions = {
  Elongation: {
    parameters:[ { name:'distance', type:'vec3', default:Vec3(0) } ],
    func:`
      vec4 opElongate( in vec3 p, in vec3 h ) {
        //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box
        
        vec3 q = abs(p)-h;
        return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );
      }`,
    emit( name='p' ) {
      const pId = this.getID()
      const pName = 'p' + pId

      let preface =
        `        vec4 ${pName}_xyzw = opElongate( ${name}, ${this.distance.emit()} );\n
        vec3 ${pName} = ${pName}_xyzw.xyz;\n`


      const sdf = this.sdf.emit( pName )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:`vec2(${pName}_xyzw.w + ${sdf.out}.x, ${sdf.out}.y)`, preface }
    }
  },
  PolarRepetition: {
    parameters:[ 
      { name:'count', type:'float', default:5 },
      { name:'distance', type:'vec3', default:Vec3(.25) },

    ],
    emit( name='p', transform=null) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`

      if( transform !== null ) this.transform.apply( transform, false )
      this.transform.invert()

      let preface =`
          vec4 ${pName} = vec4( polarRepeat( ${pointString}, ${this.__target.count.emit() } ), 1. ); 
          ${pName} -= vec4(${this.__target.distance.emit()}.x,0.,0.,0.);\n`

      const sdf = this.sdf.emit( pName )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface

      return { out:sdf.out, preface }
    }
  },
  Mirror: {
    parameters: [ { name:'distance', type:'vec3', default:Vec3(0) } ],
    extra:[{ name:'dims', type:'local', default:'xyz' }],

    emit( name='p', transform=null, notused=null, scale=null ) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId

      if( transform !== null ) {
        this.transform.apply( transform, false )
      }
      this.transform.invert()
     
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`,
            s = scale === null ? this.transform.emit_scale() : `${this.transform.emit_scale()} * ${scale}`
 
      let preface =`
        vec4 ${pName} = vec4( ( ${pointString} ) , 1.);\n
        ${pName}.${this.dims} = abs( ${pName}.${this.dims} );\n`

      const sdf = this.sdf.emit( pName, null, null, s )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:sdf.out, preface }
    }
  },
  //let preface = `         vec3 ${pName} = ${name} / ${this.amount.emit()};\n`

  //let sdf = this.sdf.emit( pName )
  //let out = sdf.out 

  //sdf.preface += `      ${out}.x = ${out}.x * ${this.amount.emit()};\n`

  //if( typeof sdf.preface === 'string' ) preface += sdf.preface
  Repetition: {
    parameters: [ { name:'distance', type:'vec3', default:Vec3(0) } ],
    emit( name='p', transform=null ) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId

      if( transform !== null ) this.transform.apply( transform, false )
      
      this.transform.invert()
     
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`;

      let preface =`
        vec4 ${pName} = vec4( (mod( ${pointString}, ${this.__target.distance.emit()} ) - .5 * ${this.__target.distance.emit()}) * ${this.transform.emit_scale()}, 1.);\n`

      const sdf = this.sdf.emit( pName )//, this.transform )//, 1, this.__target.distance )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:sdf.out, preface }
    }
  },
}
  
const getDomainOps = function( SDF ) {
  const ops = {}

  for( let key in descriptions ) {
    const opDesc = descriptions[ key ]
    
    ops[ key ] = function( sdf, ...args ) {
      const op = Object.create( ops[ key ].prototype )
      op.sdf = sdf
      op.parameters = []
      op.transform = Transform()
      const target = op.__target = op // sdf.__target !== undefined ? sdf.__target : op

      let count = 0
      for( let prop of opDesc.parameters ) {
        op.parameters.push({ name:prop.name })

        let arg = args[ count ]
        let __var

        switch( prop.type ) {
          case 'vec2':
            if( typeof arg === 'number' ) arg = Vec2( arg )
            if( arg === undefined ) arg = prop.default.copy()

            __var = param_wrap( 
              arg, 
              vec2_var_gen( prop.default )    
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.dirty = true
                }
              }
            })  

            break;
          case 'vec3':
            if( typeof arg === 'number' ) arg = Vec3( arg )
            if( arg === undefined ) arg = prop.default.copy()

            __var = param_wrap( 
              arg, 
              vec3_var_gen( prop.default )
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.value.z = v
                  __var.dirty = true
                }
              }
            })  

            break;
          case 'vec4':
            if( typeof arg === 'number' ) arg = Vec4( arg )
              __var = param_wrap( 
              arg, 
              vec4_var_gen( prop.default )  
            )

            if( arg === undefined ) arg = prop.default.copy()

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.value.z = v
                  __var.value.w = v
                  __var.dirty = true
                }
              }
            })  

            break;
          default: // float
            __var =  param_wrap( 
              arg, 
              float_var_gen( prop.default )
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                __var.set( v ) 
              }
            })
            break;
          }
        count++
      }
      
      if( opDesc.extra !== undefined ) {
        for( let extra of opDesc.extra ) {
          op[ extra.name ] = args[ count - 1 ] || extra.default
        }
      }

      op.__setTexture = function(tex,props) {
        if( typeof tex === 'string' ) {
          this.texture = op.texture.bind( this )
          this.__textureObj = this.tex = Marching.Texture( tex,props,this.texture )
          this.__textureID = this.__textureObj.id
        }else{
          this.__textureObj = this.tex = Object.assign( tex, props )
          this.__textureID = this.__textureObj.id
        }
      }
      op.__setMaterial = function(mat) {
        if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
        this.__material = this.mat = Marching.materials.addMaterial( mat )
      }
      op.__desc = opDesc

      if( key !== 'Mirror' ) op.sdf.repeat = op
      return op
    }

    ops[ key ].prototype = SceneNode()
    ops[ key ].prototype.emit = opDesc.emit
    
    ops[ key ].prototype.texture = function( ...args ) {
      this.__setTexture( ...args )
      this.sdf.texture( this.__textureObj )

      return this
    }
    ops[ key ].prototype.material = function( ...args ) {
      this.__setMaterial( ...args )
      this.sdf.material( this.__material )

      return this
    }

    ops[ key ].prototype.emit_decl = function( shouldEmitSDF=true ) {
      let decl = ''
      decl += this.transform.emit_decl()
      for( let param of this.parameters ) {
        decl += this.__target[ param.name ].emit_decl() 
      }
      if( shouldEmitSDF ) decl += this.sdf.emit_decl()
      
      // for rotation etc... any extra glsl function that needs to
      // be added to the shader
      if( opDesc.glsl !== undefined && SDF.memo[ key ] === undefined ) {
        decl += opDesc.glsl
        SDF.memo[ key ] = true
      }

      return decl
    }
    ops[ key ].prototype.update_location = function( gl, program, shouldUpdateSDF=true ) {
      for( let param of this.parameters ) this.__target[ param.name ].update_location( gl, program)
      if( shouldUpdateSDF ) this.sdf.update_location( gl, program )
      this.transform.update_location( gl, program )
    }
    ops[ key ].prototype.upload_data = function( gl, shouldUploadSDF=true ) {
      for( let param of this.parameters ) this.__target[ param.name ].upload_data( gl )
      this.transform.upload_data( gl )
      if( shouldUploadSDF ) this.sdf.upload_data( gl )
    }
  }
  
  ops.Repeat = ops.Repetition
  ops.RepeatScale = ops.RepetitionShrink
  ops.PolarRepeat = ops.PolarRepetition

  return ops
}

module.exports = getDomainOps

},{"./sceneNode.js":22,"./transform.js":26,"./utils.js":27,"./var.js":28,"./vec.js":29}],9:[function(require,module,exports){
// matrix.js - taken from https://github.com/evanw/lightgl.js/

// Represents a 4x4 matrix stored in row-major order that uses Float32Arrays
// when available. Matrix operations can either be done using convenient
// methods that return a new matrix for the result or optimized methods
// that store the result in an existing matrix to avoid generating garbage.

var hasFloat32Array = (typeof Float32Array != 'undefined');

// ### new GL.Matrix([elements])
//
// This constructor takes 16 arguments in row-major order, which can be passed
// individually, as a list, or even as four lists, one for each row. If the
// arguments are omitted then the identity matrix is constructed instead.
function Matrix() {
  var m = Array.prototype.concat.apply([], arguments);
  if (!m.length) {
    m = [
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ];
  }
  this.m = hasFloat32Array ? new Float32Array(m) : m;
}

Matrix.prototype = {
  // ### .inverse()
  //
  // Returns the matrix that when multiplied with this matrix results in the
  // identity matrix.
  inverse: function() {
    return Matrix.inverse(this, new Matrix());
  },

  // ### .transpose()
  //
  // Returns this matrix, exchanging columns for rows.
  transpose: function() {
    return Matrix.transpose(this, new Matrix());
  },

  // ### .multiply(matrix)
  //
  // Returns the concatenation of the transforms for this matrix and `matrix`.
  // This emulates the OpenGL function `glMultMatrix()`.
  multiply: function(matrix) {
    return Matrix.multiply(this, matrix, new Matrix());
  },

  // ### .transformPoint(point)
  //
  // Transforms the vector as a point with a w coordinate of 1. This
  // means translations will have an effect, for example.
  transformPoint: function(v) {
    var m = this.m;
    return new Vector(
      m[0] * v.x + m[1] * v.y + m[2] * v.z + m[3],
      m[4] * v.x + m[5] * v.y + m[6] * v.z + m[7],
      m[8] * v.x + m[9] * v.y + m[10] * v.z + m[11]
    ).divide(m[12] * v.x + m[13] * v.y + m[14] * v.z + m[15]);
  },

  // ### .transformPoint(vector)
  //
  // Transforms the vector as a vector with a w coordinate of 0. This
  // means translations will have no effect, for example.
  transformVector: function(v) {
    var m = this.m;
    return new Vector(
      m[0] * v.x + m[1] * v.y + m[2] * v.z,
      m[4] * v.x + m[5] * v.y + m[6] * v.z,
      m[8] * v.x + m[9] * v.y + m[10] * v.z
    );
  }
};

// ### GL.Matrix.inverse(matrix[, result])
//
// Returns the matrix that when multiplied with `matrix` results in the
// identity matrix. You can optionally pass an existing matrix in `result`
// to avoid allocating a new matrix. This implementation is from the Mesa
// OpenGL function `__gluInvertMatrixd()` found in `project.c`.
Matrix.inverse = function(matrix, result) {
  result = result || new Matrix();
  var m = matrix.m, r = result.m;

  r[0] = m[5]*m[10]*m[15] - m[5]*m[14]*m[11] - m[6]*m[9]*m[15] + m[6]*m[13]*m[11] + m[7]*m[9]*m[14] - m[7]*m[13]*m[10];
  r[1] = -m[1]*m[10]*m[15] + m[1]*m[14]*m[11] + m[2]*m[9]*m[15] - m[2]*m[13]*m[11] - m[3]*m[9]*m[14] + m[3]*m[13]*m[10];
  r[2] = m[1]*m[6]*m[15] - m[1]*m[14]*m[7] - m[2]*m[5]*m[15] + m[2]*m[13]*m[7] + m[3]*m[5]*m[14] - m[3]*m[13]*m[6];
  r[3] = -m[1]*m[6]*m[11] + m[1]*m[10]*m[7] + m[2]*m[5]*m[11] - m[2]*m[9]*m[7] - m[3]*m[5]*m[10] + m[3]*m[9]*m[6];

  r[4] = -m[4]*m[10]*m[15] + m[4]*m[14]*m[11] + m[6]*m[8]*m[15] - m[6]*m[12]*m[11] - m[7]*m[8]*m[14] + m[7]*m[12]*m[10];
  r[5] = m[0]*m[10]*m[15] - m[0]*m[14]*m[11] - m[2]*m[8]*m[15] + m[2]*m[12]*m[11] + m[3]*m[8]*m[14] - m[3]*m[12]*m[10];
  r[6] = -m[0]*m[6]*m[15] + m[0]*m[14]*m[7] + m[2]*m[4]*m[15] - m[2]*m[12]*m[7] - m[3]*m[4]*m[14] + m[3]*m[12]*m[6];
  r[7] = m[0]*m[6]*m[11] - m[0]*m[10]*m[7] - m[2]*m[4]*m[11] + m[2]*m[8]*m[7] + m[3]*m[4]*m[10] - m[3]*m[8]*m[6];

  r[8] = m[4]*m[9]*m[15] - m[4]*m[13]*m[11] - m[5]*m[8]*m[15] + m[5]*m[12]*m[11] + m[7]*m[8]*m[13] - m[7]*m[12]*m[9];
  r[9] = -m[0]*m[9]*m[15] + m[0]*m[13]*m[11] + m[1]*m[8]*m[15] - m[1]*m[12]*m[11] - m[3]*m[8]*m[13] + m[3]*m[12]*m[9];
  r[10] = m[0]*m[5]*m[15] - m[0]*m[13]*m[7] - m[1]*m[4]*m[15] + m[1]*m[12]*m[7] + m[3]*m[4]*m[13] - m[3]*m[12]*m[5];
  r[11] = -m[0]*m[5]*m[11] + m[0]*m[9]*m[7] + m[1]*m[4]*m[11] - m[1]*m[8]*m[7] - m[3]*m[4]*m[9] + m[3]*m[8]*m[5];

  r[12] = -m[4]*m[9]*m[14] + m[4]*m[13]*m[10] + m[5]*m[8]*m[14] - m[5]*m[12]*m[10] - m[6]*m[8]*m[13] + m[6]*m[12]*m[9];
  r[13] = m[0]*m[9]*m[14] - m[0]*m[13]*m[10] - m[1]*m[8]*m[14] + m[1]*m[12]*m[10] + m[2]*m[8]*m[13] - m[2]*m[12]*m[9];
  r[14] = -m[0]*m[5]*m[14] + m[0]*m[13]*m[6] + m[1]*m[4]*m[14] - m[1]*m[12]*m[6] - m[2]*m[4]*m[13] + m[2]*m[12]*m[5];
  r[15] = m[0]*m[5]*m[10] - m[0]*m[9]*m[6] - m[1]*m[4]*m[10] + m[1]*m[8]*m[6] + m[2]*m[4]*m[9] - m[2]*m[8]*m[5];

  var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
  for (var i = 0; i < 16; i++) r[i] /= det;
  return result;
};

// ### GL.Matrix.transpose(matrix[, result])
//
// Returns `matrix`, exchanging columns for rows. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix.
Matrix.transpose = function(matrix, result) {
  result = result || new Matrix();
  var m = matrix.m, r = result.m;
  r[0] = m[0]; r[1] = m[4]; r[2] = m[8]; r[3] = m[12];
  r[4] = m[1]; r[5] = m[5]; r[6] = m[9]; r[7] = m[13];
  r[8] = m[2]; r[9] = m[6]; r[10] = m[10]; r[11] = m[14];
  r[12] = m[3]; r[13] = m[7]; r[14] = m[11]; r[15] = m[15];
  return result;
};

// ### GL.Matrix.multiply(left, right[, result])
//
// Returns the concatenation of the transforms for `left` and `right`. You can
// optionally pass an existing matrix in `result` to avoid allocating a new
// matrix. This emulates the OpenGL function `glMultMatrix()`.
Matrix.multiply = function(left, right, result) {
  result = result || new Matrix();
  var a = left.m, b = right.m, r = result.m;

  r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
  r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
  r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
  r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

  r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
  r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
  r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
  r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

  r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
  r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
  r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
  r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

  r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
  r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
  r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
  r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];

  return result;
};

// ### GL.Matrix.identity([result])
//
// Returns an identity matrix. You can optionally pass an existing matrix in
// `result` to avoid allocating a new matrix. This emulates the OpenGL function
// `glLoadIdentity()`.
Matrix.identity = function(result) {
  result = result || new Matrix();
  var m = result.m;
  m[0] = m[5] = m[10] = m[15] = 1;
  m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
  return result;
};

// ### GL.Matrix.perspective(fov, aspect, near, far[, result])
//
// Returns a perspective transform matrix, which makes far away objects appear
// smaller than nearby objects. The `aspect` argument should be the width
// divided by the height of your viewport and `fov` is the top-to-bottom angle
// of the field of view in degrees. You can optionally pass an existing matrix
// in `result` to avoid allocating a new matrix. This emulates the OpenGL
// function `gluPerspective()`.
Matrix.perspective = function(fov, aspect, near, far, result) {
  var y = Math.tan(fov * Math.PI / 360) * near;
  var x = y * aspect;
  return Matrix.frustum(-x, x, -y, y, near, far, result);
};

// ### GL.Matrix.frustum(left, right, bottom, top, near, far[, result])
//
// Sets up a viewing frustum, which is shaped like a truncated pyramid with the
// camera where the point of the pyramid would be. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix. This emulates
// the OpenGL function `glFrustum()`.
Matrix.frustum = function(l, r, b, t, n, f, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 2 * n / (r - l);
  m[1] = 0;
  m[2] = (r + l) / (r - l);
  m[3] = 0;

  m[4] = 0;
  m[5] = 2 * n / (t - b);
  m[6] = (t + b) / (t - b);
  m[7] = 0;

  m[8] = 0;
  m[9] = 0;
  m[10] = -(f + n) / (f - n);
  m[11] = -2 * f * n / (f - n);

  m[12] = 0;
  m[13] = 0;
  m[14] = -1;
  m[15] = 0;

  return result;
};

// ### GL.Matrix.ortho(left, right, bottom, top, near, far[, result])
//
// Returns an orthographic projection, in which objects are the same size no
// matter how far away or nearby they are. You can optionally pass an existing
// matrix in `result` to avoid allocating a new matrix. This emulates the OpenGL
// function `glOrtho()`.
Matrix.ortho = function(l, r, b, t, n, f, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 2 / (r - l);
  m[1] = 0;
  m[2] = 0;
  m[3] = -(r + l) / (r - l);

  m[4] = 0;
  m[5] = 2 / (t - b);
  m[6] = 0;
  m[7] = -(t + b) / (t - b);

  m[8] = 0;
  m[9] = 0;
  m[10] = -2 / (f - n);
  m[11] = -(f + n) / (f - n);

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.scale(x, y, z[, result])
//
// This emulates the OpenGL function `glScale()`. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix.
Matrix.scale = function(x, y, z, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = x;
  m[1] = 0;
  m[2] = 0;
  m[3] = 0;

  m[4] = 0;
  m[5] = y;
  m[6] = 0;
  m[7] = 0;

  m[8] = 0;
  m[9] = 0;
  m[10] = z;
  m[11] = 0;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.translate(x, y, z[, result])
//
// This emulates the OpenGL function `glTranslate()`. You can optionally pass
// an existing matrix in `result` to avoid allocating a new matrix.
Matrix.translate = function(x, y, z, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 1;
  m[1] = 0;
  m[2] = 0;
  m[3] = x;

  m[4] = 0;
  m[5] = 1;
  m[6] = 0;
  m[7] = y;

  m[8] = 0;
  m[9] = 0;
  m[10] = 1;
  m[11] = z;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.rotate(a, x, y, z[, result])
//
// Returns a matrix that rotates by `a` degrees around the vector `x, y, z`.
// You can optionally pass an existing matrix in `result` to avoid allocating
// a new matrix. This emulates the OpenGL function `glRotate()`.
Matrix.rotate = function(a, x, y, z, result) {
  if (!a || (!x && !y && !z)) {
    return Matrix.identity(result);
  }

  result = result || new Matrix();
  var m = result.m;

  var d = Math.sqrt(x*x + y*y + z*z);
  a *= Math.PI / 180; x /= d; y /= d; z /= d;
  var c = Math.cos(a), s = Math.sin(a), t = 1 - c;

  m[0] = x * x * t + c;
  m[1] = x * y * t - z * s;
  m[2] = x * z * t + y * s;
  m[3] = 0;

  m[4] = y * x * t + z * s;
  m[5] = y * y * t + c;
  m[6] = y * z * t - x * s;
  m[7] = 0;

  m[8] = z * x * t - y * s;
  m[9] = z * y * t + x * s;
  m[10] = z * z * t + c;
  m[11] = 0;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz[, result])
//
// Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking
// toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.
// You can optionally pass an existing matrix in `result` to avoid allocating
// a new matrix. This emulates the OpenGL function `gluLookAt()`.
Matrix.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz, result) {
  result = result || new Matrix();
  var m = result.m;

  var e = new Vector(ex, ey, ez);
  var c = new Vector(cx, cy, cz);
  var u = new Vector(ux, uy, uz);
  var f = e.subtract(c).unit();
  var s = u.cross(f).unit();
  var t = f.cross(s).unit();

  m[0] = s.x;
  m[1] = s.y;
  m[2] = s.z;
  m[3] = -s.dot(e);

  m[4] = t.x;
  m[5] = t.y;
  m[6] = t.z;
  m[7] = -t.dot(e);

  m[8] = f.x;
  m[9] = f.y;
  m[10] = f.z;
  m[11] = -f.dot(e);

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

module.exports = Matrix

},{}],10:[function(require,module,exports){
const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

const FloatPrototype = {
  type: 'float',
	emit() { return emit_float( this.x ) },
	emit_decl() { return "" }
}


const Float = function( x=0 ) {
  const f = Object.create( FloatPrototype )
  f.x = x
  return f
}

module.exports = Float

},{}],11:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )

const Fogger = function( Scene, SDF ) {

  const Fog = function( amount=0.055, color ) {
    const fog = Object.create( Fog.prototype )
    const __amount = param_wrap( amount, float_var_gen( amount ) )  
    
    Object.defineProperty( fog, 'amount', {
      get() { return __amount },
      set( v ) {
        __amount.set( v )
      }
    })

    const __color = param_wrap( color, vec3_var_gen( .5,.6,.7 ) )  
    
    Object.defineProperty( fog, 'color', {
      get() { return __color },
      set( v ) {
        __color.var.set( v )
      }
    })
    
    // this refers to the current scene via implicit binding in scene.js
    this.postprocessing.push( fog )

    return this
  }

  Fog.prototype = SceneNode()
 
  Object.assign( Fog.prototype, {
    emit() {
      return `  color = applyFog( color, t.x, ${this.amount.emit()} );`
    },
   
    emit_decl() {
      let str = this.amount.emit_decl() + this.color.emit_decl()
      const preface = `  vec3 applyFog( in vec3 rgb, in float distance, in float amount ) {
    float fogAmount = 1. - exp( -distance * amount );
    vec3  fogColor  = ${this.color.emit()};
    return mix( rgb, fogColor, fogAmount );
  }
  `
      if( SDF.memo.fog === undefined ) {
        str = str + preface
        SDF.memo.fog = true
      }else{
        str = ''
      }

      return str
    },

    update_location( gl, program ) {
      this.amount.update_location( gl, program )
      this.color.update_location( gl, program )
    },

    upload_data( gl ) {
      this.amount.upload_data( gl )
      this.color.upload_data( gl )
    }
  })

  return Fog
}

module.exports = Fogger

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28}],12:[function(require,module,exports){
'use strict'

const Marching = require( './main.js' )

Marching.__export = Marching.export
Marching.export = obj => {
  obj.march = Marching.createScene.bind( Marching )
  Marching.__export( obj )
}

window.Marching = Marching

module.exports = Marching

},{"./main.js":15}],13:[function(require,module,exports){
const emit_int = function( a ) {
	if( a % 1 !== 0 )
		return Math.round( a )
	else
		return a
}

const IntPrototype = {
  type: 'int',
	emit() { return emit_int( this.x ) },
	emit_decl() { return "" }
}


const Int = function( x=0 ) {
  const f = Object.create( IntPrototype )
  f.x = x
  return f
}

module.exports = Int

},{}],14:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' ),
      { Vec2, Vec3, Vec4 } = require( './vec.js' )

const glsl = require( 'glslify' )

const Lights = function( SDF ) {

  const Light = {
    lights:[],
    materials:[],

    defaultLights:`
      Light lights[2] = Light[2](
        Light( vec3( 2.,2.,3. ),  vec3(0.25,0.25,.25), 1. ),
        Light( vec3( -2.,2.,3. ), vec3(.25,0.25,0.25), 1. )
      );
    `,

    defaultMaterials:`
      Material materials[2] = Material[2](
        Material( 0, vec3( 1. ), vec3(0.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.), 0 ),
        Material( 0, vec3( 1. ), vec3(1.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.), 0 )
      );
    `,

    light( __pos=Vec3(2,2,3), __color=Vec3(0,0,1), attenuation=1 ) {
      const light = { 
        __attenuation: param_wrap( attenuation, float_var_gen( 1 ) ),
      }

      pos = typeof __pos === 'number' ? Vec3( __pos ) : __pos

      const __varpos = param_wrap( 
        pos, 
        vec3_var_gen( [2,2,3] )
      )

      Object.defineProperty( light, 'pos', {
        get() { return __varpos },
        set(v) {
          if( typeof v === 'object' ) {
            __varpos.set( v )
          }else{
            __varpos.value.x = v
            __varpos.value.y = v
            __varpos.value.z = v
            __varpos.dirty = true
          }
        }
      })  

      color = typeof __color === 'number' ? Vec3( __color ) : __color

      const __varcol = param_wrap( 
        color, 
        vec3_var_gen( [0,0,1] )
      )

      Object.defineProperty( light, 'color', {
        get() { return __varcol },
        set(v) {
          if( typeof v === 'object' ) {
            __varcol.set( v )
          }else{
            __varcol.value.x = v
            __varcol.value.y = v
            __varcol.value.z = v
            __varcol.dirty = true
          }
        }
      })  

      Object.defineProperty( light, 'attenuation', {
        get() { return light.__attenuation.value },
        set(v){
          light.__attenuation.value = v
          light.__attenuation.dirty = true
        }
      })

      return light
    },

    emit_lights() {
      if( this.lights.length === 0 ) return this.defaultLights

      let str = `Light lights[${this.lights.length}] = Light[${this.lights.length}](`

      for( let light of this.lights ) {
        str += `\n        Light( ${light.pos.emit()}, ${light.color.emit()}, ${light.__attenuation.emit()}),` 
      }
      
      str = str.slice(0,-1) // remove trailing comma

      str += '\n      );'

      return str
    },

    mode:'global',

    gen( shadows=8, geometries ) {
      //const str = this.modes[ this.mode ]( this.lights.length || 2, this.emit_lights(), SDF.materials.emit_materials(), shadows )
   
      const modeConstants = SDF.materials.modeConstants
      this.modesEmployed.length = 0

      let lightingFunctions = []

      // loop through all materials used and add corresponding lighting functions as needed
      for( let mat of SDF.materials.materials ) {
        if( this.modesEmployed.indexOf( mat.mode ) === -1 ) {
          lightingFunctions.push( this.modes[ mat.mode ]() )  

          this.modesEmployed.push( mat.mode )
        }
      }

      // check all modes to see if they're lighting function has been added to the shader,
      // if not, add their function stub
      for( let mode of modeConstants ) {
        // key is iterated as string, must use parseInt
        if( this.modesEmployed.indexOf( mode ) === -1 ) {
          lightingFunctions.push( this.defaultFunctionDeclarations[ modeConstants.indexOf( mode ) ] )
        }
      }

      const textures = Marching.textures.__emitFunction()
      const lighting = this.shell( 
        this.lights.length || 2, 
        this.emit_lights(), 
        SDF.materials.emit_materials(), 
        shadows,
        geometries, 
        textures.glsldefs,
        textures.mainfunc
      )

      let lightingFuncStr = lightingFunctions.join('\n')
      lightingFuncStr = lightingFuncStr.replace( /(MAX\_LIGHTS)/g, this.lights.length || 2 )
      return lighting[0] + lightingFuncStr + lighting[1]
    },

    emit_decl() {
      let str = ''
      for( let light of this.lights ) {
        str += light.pos.emit_decl()
        str += light.color.emit_decl()
        str += light.__attenuation.emit_decl()
      }

      return str
    },

    update_location( gl, program ) {
      for( let light of this.lights ) {
        if( light.pos.dirty === true )  light.pos.update_location( gl, program )
        if( light.color.dirty === true )  light.color.update_location( gl, program )
        if( light.__attenuation.dirty === true ) light.__attenuation.update_location( gl, program )
      }

    },

    upload_data( gl, program='' ) {
      for( let light of this.lights ) {
        if( light.pos.dirty === true )   light.pos.upload_data( gl, program )
        if( light.color.dirty === true )  light.color.upload_data( gl, program )
        if( light.__attenuation.dirty === true )  light.__attenuation.upload_data( gl, program )
      }
    },

    modesEmployed:[],

    // these stubs are placed in the shader by default as placeholders so that they can be referenced in 
    // a switch statement selecting lighting. They are overridden by actual lighting functions if any
    // material in the scene uses a corresponding function.
    defaultFunctionDeclarations: [
      '    vec3 global( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) { return vec3(0.); }',
      '    vec3 normal( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) { return vec3(0.); }',
      '    vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) { return vec3(0.); }',
      '    vec3 orenn( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) { return vec3(0.); }',
    ],

    shell( numlights, lights, materials, shadow=0, sdfs, texturePreface, textureBody ) {
      const __shadow = shadow > 0
        ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
        : ''


      let preface = glsl(["#define GLSLIFY 1\n  int MAX_LIGHTS = ",";\n    float ao( in vec3 pos, in vec3 nor ){\n      float occ = 0.0;\n      float sca = 1.0;\n      for( int i=0; i<5; i++ )\n      {\n          float hr = 0.01 + 0.12 * float( i ) / 4.0;\n          vec3 aopos =  nor * hr + pos;\n          float dd = scene ( aopos ).x;\n          occ += -(dd-hr)*sca;\n          sca *= 0.95;\n      }\n      return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n    }\n\n    \n    ","\n    ","\n    ",""],numlights,texturePreface,textureBody)
      let func = `

    vec3 lighting( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, float sdfID, bool useTextureTransform ) {
      ${sdfs}
      SDF sdf = sdfs[ int( sdfID ) ];

      ${materials}
      Material mat = materials[ sdf.materialID ];

      int MAX_LIGHTS = ${numlights};     

      ${lights}
 
      vec3 tex = getTexture( int(sdf.textureID), surfacePosition, normal, sdf, useTextureTransform );

      vec3 clr;
      switch( mat.mode ) {
        case 0: clr = global( surfacePosition, normal, rayOrigin, rayDirection, mat, lights, tex ); break;
        case 1: clr = normal; break;
        case 2: clr = directional( surfacePosition, normal, rayOrigin, rayDirection, mat, lights, tex ); break;
        case 3: clr = orenn( surfacePosition, normal, rayOrigin, rayDirection, mat, lights ); break;
        default:
          clr = normal;
      }

      return clr; 
    }
`
      return [ preface, func ]
    }, 

    modes:{
      global() {
        const shadow = SDF.__scene.__shadow

        const str = glsl(["#define GLSLIFY 1\n\n\n        vec3 global( vec3 pos, vec3 nor, vec3 ro, vec3 rd, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) {\n          Light light = lights[ 0 ];\n          vec3  ref = reflect( rd, nor ); // reflection angle\n          float occ = ao( pos, nor );\n          vec3  lig = normalize( light.position ); // light position\n          float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n          float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n          // simulated backlight\n          float bac = clamp( dot( nor, normalize( vec3( -lig.x, 0.0 , -lig.z ))), 0.0, 1.0 ) * clamp( 1.0-pos.y, 0.0 ,1.0 );\n\n          // simulated skydome light\n          float dom = smoothstep( -0.1, 0.1, ref.y );\n          float fre = pow( clamp( 1.0 + dot( nor,rd ),0.0,1.0 ), 3.0);\n          float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 8.0 );\n\n          dif *= softshadow( pos, lig, 0.02, 2.5, "," );\n          dom *= softshadow( pos, ref, 0.02, 2.5, "," );\n\n          vec3 brdf = textureColor;//vec3( 0.0 );\n          brdf += 1.20 * dif * vec3( 1.00,0.90,0.60 ) * mat.diffuse * light.color;\n          brdf += 2.20 * spe * vec3( 1.00,0.90,0.60 ) * dif * mat.specular * light.color;\n          brdf += 0.30 * amb * vec3( 0.50,0.70,1.00 ) * occ * mat.ambient * light.color;\n          brdf += 0.40 * dom * vec3( 0.50,0.70,1.00 );\n          brdf += 0.70 * bac * vec3( 0.25 );\n          brdf += 0.40 * (fre * light.color);\n\n          return brdf;\n        }\n        ",""],shadow.toFixed(1),shadow.toFixed(1))

        return str
      },

      phong( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow

        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n        \n        vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) {\n          vec3  outputColor   = textureColor;//vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = dot( normal, surfaceToLightDirection ); \n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = pow( specularAngle, mat.shininess );\n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            // bias, scale, power\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * mat.diffuse * light.color;\n            color += 2.2 * specularCoefficient * mat.specular * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // texture\n            //color *= textureColor.xyz;\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }\n        ",""],__shadow)

        return str
      }, 
      phongT( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow

        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n\n        vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) {\n          vec3  outputColor   = vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          vec4 textureColor;\n          if( mat.textureID > -1 ) {\n            //textureColor = texcube( textures[ mat.textureID ], surfacePosition, normal, 1. );//texture( textures[ mat.textureID ], surfacePosition.xy - normal.xy ); \n            vec2 uv = getUVCubic( surfacePosition, vec3(0.) );//surfacePosition.xz*vec2(0.03,0.07);\n            textureColor = texture( textures[ mat.textureID ], uv );\n          }else{\n            textureColor = vec4(0.);\n          }\n\n          outputColor = 0;//textureColor.xyz;\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = dot( normal, surfaceToLightDirection ); \n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = pow( specularAngle, mat.shininess );\n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            // bias, scale, power\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * textureColor.xyz * light.color;\n            color += 2.2 * specularCoefficient * textureColor.xyz * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // texture\n            //color *= textureColor.xyz;\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }\n        ",""],__shadow)

        return str
      }, 


      orenn( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow
        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n        float orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;\n}\n\n        float gaussianSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\n        vec3 orenn( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) {\n          vec3  outputColor   = vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = orenNayarDiffuse( surfaceToLightDirection, -rayDirection, normal, 0.15, 4.0);\n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = gaussianSpecular( surfaceToLightDirection, -rayDirection, normal, .5 ); \n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * mat.diffuse * light.color;\n            color += 2.2 * specularCoefficient * mat.specular * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }",""],__shadow)

        return str
      }, 


      global_save( numlights, lights, materials, shadow='' ) {
        const str = glsl(["#define GLSLIFY 1\n\n        float ao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float( i ) / 4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene ( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n        ","\n\n        ","\n\n        vec3 lighting( vec3 pos, vec3 nor, vec3 ro, vec3 rd, float materialID ) {\n          Light light = lights[ 0 ];\n          vec3  ref = reflect( rd, nor ); // reflection angle\n          float occ = ao( pos, nor );\n          vec3  lig = normalize( light.position ); // light position\n          float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n          float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n          // simulated backlight\n          float bac = clamp( dot( nor, normalize( vec3( -lig.x, 0.0 , -lig.z ))), 0.0, 1.0 ) * clamp( 1.0-pos.y, 0.0 ,1.0 );\n\n          // simulated skydome light\n          float dom = smoothstep( -0.1, 0.1, ref.y );\n          float fre = pow( clamp( 1.0 + dot( nor,rd ),0.0,1.0 ), 2.0 );\n          float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 8.0 );\n\n          dif *= softshadow( pos, lig, 0.02, 2.5, 8. );\n          dom *= softshadow( pos, ref, 0.02, 2.5, 8. );\n\n          Material mat = materials[ int(materialID) ];\n\n          vec3 brdf = vec3( 0.0 );\n          brdf += 1.20 * dif * vec3( 1.00,0.90,0.60 ) * mat.diffuse * light.color;\n          brdf += 2.20 * spe * vec3( 1.00,0.90,0.60 ) * dif * mat.specular * light.color;\n          brdf += 0.30 * amb * vec3( 0.50,0.70,1.00 ) * occ * mat.ambient * light.color;\n          brdf += 0.40 * dom * vec3( 0.50,0.70,1.00 ) * occ;\n          brdf += 0.70 * bac * vec3( 0.25 ) * occ;\n          brdf += 0.40 * (fre * light.color) * occ;\n\n          return brdf;\n        }",""],materials,lights)

        return str

      },

      normal() { return '' },
      noise() { return '' }
    },
  }

  return Light
}

module.exports = Lights

// old lighting
/*
*/

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28,"./vec.js":29,"glslify":120}],15:[function(require,module,exports){
const SDF = {
  camera:           require( './camera.js' ),
  __primitives:     require( './primitives.js' ),
  vectors:          require( './vec.js' ),
  distanceOps:      require( './distanceOperations.js' ),
  alterations:      require( './alterations.js' ),
  distanceDeforms:  require( './distanceDeformations.js' ),
  __domainOps:      require( './domainOperations.js' ),
  __noise:          require( './noise.js' ),
  __scene:          require( './scene.js' ),
  __lighting:       require( './lighting.js' ),
  __materials:      require( './material.js' ),
  __textures:       require( './texture.js' ),
  Var:              require( './var.js' ).Var,
  //Color:            require( './color.js' ),
  FFT:              require( './audio.js' ),

  // a function that generates the fragment shader
  renderFragmentShader: require( './renderFragmentShader.js' ),

  // additional callbacks that are run once per frame
  callbacks: [],
  geometries: [],

  // the main drawing callback
  render: null,

  // the scene is a chain of Unions combining all elements together
  scene:  null,

  // a speed of 1 corresponds to 60 fps.
  delay: 0,
  __isPaused:false,

  defaultVertexSource:`    #version 300 es
    in vec3 a_pos;
		in vec2 a_uv;
		out vec2 v_uv;

		void main() {
			v_uv = a_uv;
			gl_Position = vec4(a_pos, 1.0);
    }`
  ,

  export( obj ) {
    Object.assign( 
      obj, 
      this.primitives,
      this.vectors,
      this.distanceOps,
      this.domainOps,
      this.distanceDeforms,
      this.alterations
    )

    obj.Light = this.Light
    obj.Material = this.Material
    obj.Texture  = this.Texture
    obj.camera = this.camera
    obj.callbacks = this.callbacks // XXX remove once API stops using callbacks
    obj.FFT = this.FFT
  },

  init( canvas, shouldInit = false ) {
    this.primitives = this.__primitives( this )
    this.Scene      = this.__scene( this )
    this.domainOps  = this.__domainOps( this )
    this.noise     = this.__noise( this )
    this.export( this )
    this.canvas = canvas 

    this.lighting   = this.__lighting( this )
    this.Light = this.lighting.light
    this.materials  = this.__materials( this )
    this.Material = this.materials.material
    this.textures = this.__textures( this )
    this.Texture = this.textures.texture

    this.canvas.width = window.innerWidth 
    this.canvas.height = window.innerHeight
    this.gl = this.canvas.getContext( 'webgl2', { antialias:true, alpha:true })

  },

  initBuffers() {
    const gl = this.gl
    gl.clearColor( 0.0, 0.0, 0.0, 0.0 )
    gl.clear(gl.COLOR_BUFFER_BIT)

    const vbo = gl.createBuffer()

    const vertices = new Float32Array([
      -1.0, -1.0, 0.0, 0.0, 0.0,
      1.0, -1.0, 0.0, 1.0, 0.0,
      -1.0, 1.0, 0.0, 0.0, 1.0,
      1.0, 1.0, 0.0, 1.0, 1.0
    ])

    gl.bindBuffer (gl.ARRAY_BUFFER, vbo )
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )

    const ibo = gl.createBuffer()

    const indices = new Uint16Array( [0, 1, 2, 2, 1, 3] )

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, ibo )
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW )
  },

  // generate shaders, initialize camera, start rendering loop 
  createScene( ...args ) {
    const scene = this.Scene( args, this.canvas )

    this.requiredGeometries = []
    this.requiredOps = []
    this.memo = {}

    return scene
  },

  start( fs, width, height, shouldAnimate ) {
    if( this.render !== null ) this.render.running = false

    this.fs = fs
    this.callbacks.length = 0

    this.render = this.initWebGL( this.defaultVertexSource, fs, width, height, shouldAnimate )
    this.render.running = true

    this.camera.init( this.gl, this.program, cb => { 
      this.callbacks.push( cb )
    })

    setTimeout( ()=> this.render( 0.0 ), 0 )
  },

  generateSDF( __scene ) {
    let scene = { preface:'' }

    /* if there is more than one object in our scene, chain pairs of objects
       in Unions. So, given objects a,b,c, and d create:

       Union( a, Union( b, Union( c,d ) ) )

       ... or something like that. If there is only a single object,
       use that object as the entire scene.
     */

    let objs = __scene.objs
    if( objs.length > 1 ) {
      // reduce objects to nested Unions
      scene.output = objs.reduce( ( current, next ) => this.Union( current, next ) )
    }else{
      scene.output = objs[0]
    }

    // create an fancy emit() function that wraps the scene
    // with an id #.

    scene.output.__emit = scene.output.emit.bind( scene.output )
    scene.output.emit = function( ...args ) {
      const emitted = scene.output.__emit(...args)
      const output = {
        out:     emitted.out,
        preface: emitted.preface || '' 
      }

      return output 
    }

    this.scene = scene.output

    let variablesDeclaration = scene.output.emit_decl()
    const sceneRendering = scene.output.emit()

    // fog etc. maybe msaa?
    let pp = ''
    for( let processor of __scene.postprocessing ) {
      pp += processor.emit()
      variablesDeclaration += processor.emit_decl()
    }
    
    this.postprocessing = __scene.postprocessing

    return [ variablesDeclaration, sceneRendering, pp ]
  },

	compile( type, source ) {
    const gl = this.gl

		const shader = this.shader = gl.createShader( type );
		gl.shaderSource( shader, source )
		gl.compileShader( shader )

		if( gl.getShaderParameter( shader, gl.COMPILE_STATUS) !== true ) {
			let log = gl.getShaderInfoLog( shader )
			gl.deleteShader( shader )

			console.log( source )
			console.log( log )

			return null
		}

		return shader
	},

  createProgram( vs_source, fs_source ) {
    const gl = this.gl
		const vs = this.compile( gl.VERTEX_SHADER, vs_source )
		const fs = this.compile( gl.FRAGMENT_SHADER, fs_source )

		if( null === vs || null === fs ) return null

		const program = gl.createProgram()
		gl.attachShader( program, vs )
		gl.attachShader( program, fs )
		gl.linkProgram( program )

		if( gl.getProgramParameter( program, gl.LINK_STATUS ) !== true ){
			const log = gl.getProgramInfoLog( program )
			gl.deleteShader(vs)
			gl.deleteShader(fs)
			gl.deleteProgram(program)

			console.error( log )
			return null
		}

		return program
  },

  clear() {
    if( this.callbacks !== undefined ) this.callbacks.length = 0
    if( this.render !== null ) this.render.running = false
    this.geometries.length = 0

    const gl = this.gl
    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT )
  },

  pause() {
    this.__isPaused = !this.__isPaused
  },

  initWebGL( vs_source, fs_source, width, height,shouldAnimate=false ) {
    const gl = this.gl
    //if( shouldInit === true ) this.initBuffers()
    this.initBuffers()


    const program = this.program = this.createProgram( vs_source, fs_source )
    gl.useProgram(program);

    const loc_a_pos = gl.getAttribLocation(program, "a_pos");
    const loc_a_uv = gl.getAttribLocation(program, "a_uv");

    const loc_u_time = gl.getUniformLocation(program, "time");
    const loc_u_resolution = gl.getUniformLocation(program, "resolution" )

    this.postprocessing.forEach( pp => pp.update_location( gl, program ) )

    this.scene.update_location( gl, program )
    this.textures.update_location( gl, program )
    this.materials.update_location( gl, program )
    this.lighting.update_location( gl, program )

    gl.enableVertexAttribArray(loc_a_pos)
    gl.enableVertexAttribArray(loc_a_uv)

    gl.vertexAttribPointer(loc_a_pos, 3, gl.FLOAT, false, 20, 0)
    gl.vertexAttribPointer(loc_a_uv, 2, gl.FLOAT, false, 20, 12)

    gl.viewport( 0,0,width,height )
    gl.uniform2f( loc_u_resolution, width, height )

    let total_time = 0.0;

    function clamp255(v) {
      return Math.min( Math.max( 0, v * 255 ), 255 )
    }

    let frameCount = 0
    const render = function( timestamp ){
      if( render.running === true && shouldAnimate === true ) {
        window.requestAnimationFrame( render )
      }else if( render.running === false ) {
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT )
        return
      }
      if( this.__isPaused === false ) {
        this.currentTime = timestamp

        if( this.delay !== 0 && this.delay >= frameCount ) {
          frameCount++
          return
        }else if( this.delay !== 0 ) {
          frameCount = 0
        }

        total_time = timestamp / 1000.0
        gl.uniform1f( loc_u_time, total_time )

        this.callbacks.forEach( cb => cb( total_time, this.currentTime ) )

        if( typeof window.onframe === 'function' ) {
          window.onframe( total_time )
        }
      }

      this.materials.upload_data( gl )
      this.textures.upload_data( gl )
      this.scene.upload_data( gl )
      this.lighting.upload_data( gl )
      this.postprocessing.forEach( pp => pp.upload_data( gl ) )

      gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 )

    }.bind( SDF )

    render.running = true

    return render    
  }
}

module.exports = SDF

},{"./alterations.js":1,"./audio.js":2,"./camera.js":4,"./distanceDeformations.js":5,"./distanceOperations.js":6,"./domainOperations.js":8,"./lighting.js":14,"./material.js":16,"./noise.js":17,"./primitives.js":19,"./renderFragmentShader.js":20,"./scene.js":21,"./texture.js":23,"./var.js":28,"./vec.js":29}],16:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' ),
      { Vec2, Vec3, Vec4 } = require( './vec.js' )


const glsl = require( 'glslify' )

const __Materials = function( SDF ) {

  const Materials = {
    materials:[],
    __materials:[],
    modeConstants : [
      'global',
      'normal',
      'phong',
      'orenn',
      'noise'
    ],

    default: 'global',

    //defaultMaterials:`
    //  Material materials[2] = Material[2](
    //    Material( 0, vec3( 1. ), vec3(0.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.) ),
    //    Material( 0, vec3( 1. ), vec3(1.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.) )
    //  );
    //`,

    addMaterial( mat ) {
      if( mat === undefined ) mat = Materials.material.default

      if( Materials.materials.indexOf( mat ) === -1 ) {
        mat.id = MaterialID.alloc()

        // we have to dirty the material so that its data
        // will be uploaded to new shaders, otherwise the
        // material will only work the first time it's used, when
        // it's dirty on initialization.
        Materials.dirty( mat )

        Materials.materials.push( mat )
      } 

      return mat
    },

    material( mode='global', __ambient, __diffuse, __specular, __shininess, __fresnel, __texture=null ){
      let modeIdx = Materials.modeConstants.indexOf( mode )
      if( modeIdx === -1 ) {
        console.warn( `There is no material type named ${mode}. Using the default material, ${Materials.default}, instead.` )
        mode = Materials.default
        modeIdx = Materials.modeConstants.indexOf( mode )
      }

      if( typeof __ambient === 'number' ) __ambient = Vec3( __ambient )
      const ambient = param_wrap( __ambient, vec3_var_gen(.1,.1,.1) )
      if( typeof __diffuse=== 'number' ) __diffuse= Vec3( __diffuse )
      const diffuse = param_wrap( __diffuse, vec3_var_gen(0,0,1) )
      if( typeof __specular === 'number' ) __specular = Vec3( __specular )
      const specular = param_wrap( __specular, vec3_var_gen(1,1,1) )
      const shininess = param_wrap( __shininess, float_var_gen(8) )
      if( typeof __fresnel === 'number' ) __fresnel = Vec3( __fresnel )
      const fresnel = param_wrap( __fresnel, vec3_var_gen(0,1,2) )

      const mat = { shininess, mode, texture:__texture, type:'material' }

      Object.defineProperty( mat, 'ambient', {
        get() { return ambient },
        set(v) {
          if( typeof v === 'object' ) {
            ambient.set( v )
          }else{
            ambient.value.x = v
            ambient.value.y = v
            ambient.value.z = v
            ambient.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'diffuse', {
        get() { return diffuse },
        set(v) {
          if( typeof v === 'object' ) {
            diffuse.set( v )
          }else{
            diffuse.value.x = v
            diffuse.value.y = v
            diffuse.value.z = v
            diffuse.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'specular', {
        get() { return specular },
        set(v) {
          if( typeof v === 'object' ) {
            specular.set( v )
          }else{
            specular.value.x = v
            specular.value.y = v
            specular.value.z = v
            specular.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'fresnel', {
        get() { return fresnel },
        set(v) {
          if( typeof v === 'object' ) {
            fresnel.set( v )
          }else{
            fresnel.value.x = v
            fresnel.value.y = v
            fresnel.value.z = v
            fresnel.dirty = true
          }
        }
      })  
      //Object.defineProperty( mat, 'shininess', {
      //  get() { return mat.shininess.value },
      //  set(v){
      //    mat.shininess.value = v
      //    mat.shininess.dirty = true
      //  }
      //})     //
      
      return mat 
    },

    dirty( mat ) {
      mat.ambient.dirty = true
      mat.diffuse.dirty = true
      mat.specular.dirty = true
      mat.shininess.dirty = true
      mat.fresnel.dirty = true
      if( mat.texture !== null ) mat.texture.dirty = true
    },
   
    emit_materials() {
      if( this.materials.length === 0 ) {
        console.log( 'returning undefined?', this.defaultMaterials )
        return this.defaultMaterials//this.addMaterial() 
      }

      let str = `Material materials[${this.materials.length}] = Material[${this.materials.length}](`

      this.materials.sort( (a,b) => a.id > b.id ? 1 : -1 ) 

      for( let mat of this.materials ) {
        const fresnel = `Fresnel( ${f(mat.fresnel.x)}, ${f(mat.fresnel.y)}, ${f(mat.fresnel.z)} )`

        const texid = 0//SDF.textures.textures.indexOf( mat.texture )
        str += mat.texture === null 
          ? `\n        Material( ${this.modeConstants.indexOf( mat.mode )}, ${mat.ambient.emit()}, ${mat.diffuse.emit()}, ${mat.specular.emit()}, ${mat.shininess.emit()}, ${mat.fresnel.emit()}, ${ texid } ),` 
          : `\n        Material( ${this.modeConstants.indexOf( mat.mode )}, ${mat.ambient.emit()}, ${mat.diffuse.emit()}, ${mat.specular.emit()}, ${mat.shininess.emit()}, ${mat.fresnel.emit()}, ${ texid } ),` 
      }
      
      str = str.slice(0,-1) // remove trailing comma

      str += '\n      );'

      this.__materials = this.materials.slice( 0 )
      this.materials.length = 0

      return str
    },

    emit_decl() {
      let str = ''
      for( let mat of this.__materials ) {
        str += mat.ambient.emit_decl()
        str += mat.diffuse.emit_decl()
        str += mat.specular.emit_decl()
        str += mat.shininess.emit_decl()
        str += mat.fresnel.emit_decl()
      }

      return str
    },

    update_location( gl, program ) {
      for( let mat of this.__materials ) {
        if( mat.ambient.dirty === true )   mat.ambient.update_location( gl, program )
        if( mat.diffuse.dirty === true )   mat.diffuse.update_location( gl, program )
        if( mat.specular.dirty === true )  mat.specular.update_location( gl, program )
        if( mat.shininess.dirty === true ) mat.shininess.update_location( gl, program )
        if( mat.fresnel.dirty === true )   mat.fresnel.update_location( gl, program )
      }
    },

    upload_data( gl, program='' ) {
      for( let mat of this.__materials ) {
        if( mat.ambient.dirty === true )   mat.ambient.upload_data( gl, program )
        if( mat.diffuse.dirty === true )   mat.diffuse.upload_data( gl, program )
        if( mat.specular.dirty === true )  mat.specular.upload_data( gl, program )
        if( mat.shininess.dirty === true ) mat.shininess.upload_data( gl, program )
        if( mat.fresnel.dirty === true )   mat.fresnel.upload_data( gl, program )
      }
    }

  }

  const f = value => value % 1 === 0 ? value.toFixed(1) : value 

  Object.assign( Materials.material, {
    default : Materials.material( 'global', Vec3( .15 ), Vec3(0), Vec3(1), 8, Vec3( 0, 1, .5 ) ),  
    red     : Materials.material( 'global', Vec3(.25,0,0), Vec3(1,0,0), Vec3(0), 2, Vec3(0) ),
    green   : Materials.material( 'global', Vec3(0,.25,0), Vec3(0,1,0), Vec3(0), 2, Vec3(0) ),
    blue    : Materials.material( 'global', Vec3(0,0,.25), Vec3(0,0,1), Vec3(0), 2, Vec3(0) ),
    cyan    : Materials.material( 'global', Vec3(0,.25,.25), Vec3(0,1,1), Vec3(0), 2, Vec3(0) ),
    magenta : Materials.material( 'global', Vec3(.25,0,.25), Vec3(1,0,1), Vec3(0), 2, Vec3(0) ),
    yellow  : Materials.material( 'global', Vec3(.25,.25,.0), Vec3(1,1,0), Vec3(0), 2, Vec3(0) ),
    black   : Materials.material( 'global', Vec3(0, 0, 0), Vec3(0,0,0), Vec3(0), 2, Vec3(0) ),
    white   : Materials.material( 'global', Vec3(.25), Vec3(1), Vec3(1), 2, Vec3(0) ),
    grey    : Materials.material( 'global', Vec3(.25), Vec3(.33), Vec3(1), 2, Vec3(0) ),

    'white glow' : Materials.material( 'phong',  Vec3(.015), Vec3(1), Vec3(1), 16, Vec3(0,200,5) ),
    glue    : Materials.material( 'phong',  Vec3(.015), Vec3(1), Vec3(1), 16, Vec3(0,15,-.1) ),
    inverse : Materials.material( 'phong', 1, .5, 1, 16, Vec3(1,.5,-2) ),

    normal  : Materials.material( 'normal' ),
    noise   : Materials.material( 'noise',  Vec3( .15 ), Vec3(1,0,0), Vec3(1), 8, Vec3( 0, 1, .5 ))
  })

  return Materials
}

module.exports = __Materials

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28,"./vec.js":29,"glslify":120}],17:[function(require,module,exports){
const glsl = require( 'glslify' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' )

const getNoise = function( SDF ) {
Noise = function( strength=.25, bias=1, timeMod=1 ) {
  const op = Object.create( Noise.prototype )
  op.type = 'string'
  op.isGen = true

  const defaultValues = [.5,.5,.5]

  op.matId = MaterialID.alloc()

  const __strength = param_wrap( strength, float_var_gen( strength ) )
  const __timeMod  = param_wrap( timeMod, float_var_gen( timeMod ) )

  Object.defineProperty( op, 'strength', {
    get() { return __strength },
    set(v) {
     __strength.var.set( v )
    }
  })
  Object.defineProperty( op, 'timeMod', {
    get() { return __timeMod },
    set(v) {
     __timeMod.var.set( v )
    }
  })
  const __bias  = param_wrap( bias, float_var_gen( bias ) )

  Object.defineProperty( op, 'bias', {
    get() { return __bias},
    set(v) {
     __bias.var.set( v )
    }
  })
  return op
} 

Noise.prototype = SceneNode()

Noise.prototype.emit = function ( __name ) {
  let name = __name === undefined ? 'p' : __name

  const out = `(${this.bias.emit()} + snoise( vec4( p.xyz, time * ${this.timeMod.emit()} )) * ${this.strength.emit()})`  

  const output = {
    out,
    preface:''
  }

  return output
}
Noise.prototype.glsl = glsl(["#define GLSLIFY 1\n    //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n"])

Noise.prototype.emit_decl = function () {
  let str = this.strength.emit_decl() + this.timeMod.emit_decl() + this.bias.emit_decl()

  if( SDF.memo.noise === undefined ) {
    str = Noise.prototype.glsl + str
    SDF.memo.noise = true
  }

  return str
};

Noise.prototype.update_location = function(gl, program) {
  this.strength.update_location( gl, program )
  this.timeMod.update_location( gl, program )
  this.bias.update_location( gl, program )
}

Noise.prototype.upload_data = function(gl) {
  this.strength.upload_data( gl )
  this.timeMod.upload_data( gl )
  this.bias.upload_data( gl )
}

return Noise

}

module.exports = getNoise 

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28,"glslify":120}],18:[function(require,module,exports){
const glsl = require( 'glslify' )

module.exports = {
  Box: {
    parameters:[
      { name:'size', type:'vec3', default:[1,1,1] },
    ],

    primitiveString( pName ) { 
	    return `sdBox( ${pName}, ${this.size.emit()} )`;
    },

    glslify:glsl(["#define GLSLIFY 1\n    float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n"])
  }, 

  // XXX we should normalize dimensions in the shader... 
  Cone: {
    parameters:[
      { name:'dimensions', type:'vec3', default:[.8,.6,.3] },
    ],

    primitiveString( pName ) { 
      return `sdCone( ${pName}, ${this.dimensions.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n"])
  }, 

	Cylinder: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.8,.6] },
    ],

    primitiveString( pName ) { 
      return `sdCappedCylinder( ${pName}, ${this.dimensions.emit()} )`
    },

    glslify:`    float sdCappedCylinder( vec3 p, vec2 h ) {
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
  }`
  }, 

  Capsule: {	
    parameters:[
      { name:'start', type:'vec3', default:[0,0,0] },
      { name:'end', type:'vec3', default:[.8,1,0] },
      { name:'radius', type:'float', default:.5 },
    ],

    primitiveString( pName ) { 
      return `sdCapsule( ${pName}, ${this.start.emit()}, ${this.end.emit()}, ${this.radius.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n"])

  },

  // XXX No cylinder description
  //` #pragma glslify: sdCylinder	= require('glsl-sdf-primitives/sdCylinder')`
 	HexPrism: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.8,.6] },
    ],

    primitiveString( pName ) { 
      return `sdHexPrism( ${pName}, ${this.dimensions.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n"])
  },

  Julia: {
    parameters:[
      { name:'fold', type:'float', default:0 },
    ],

    primitiveString( pName ) { 
      return `julia( ${pName}, ${this.fold.emit()} )`
    },

    // https://www.shadertoy.com/view/MsfGRr
    glslify:glsl(["#define GLSLIFY 1\n  vec4 qsqr( in vec4 a ) {\n    return vec4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n                 2.0*a.x*a.y,\n                 2.0*a.x*a.z,\n                 2.0*a.x*a.w );\n  }\n\n  float julia( in vec3 p, float atime ){\n    vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + atime * vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n    vec4 z = vec4(p,0.);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n    for( int i=0; i<11; i++ ){\n      md2 *= 4.0*mz2;   \n      // dz -> 2·z·dz, meaning |dz| -> 2·|z|·|dz| (can take the 4 out of the loop and do an exp2() afterwards)\n      z = qsqr(z) + c;  // z  -> z^2 + c\n\n      mz2 = dot(z,z);\n      if(mz2>4.0) break;\n    }\n    \n    return 0.25*sqrt(mz2/md2)*log(mz2);  // d = 0.5·|z|·log|z| / |dz|\n  }",""]),
  },
  KIFS: {
    parameters:[
      { name:'count', type:'float', default:8 },
      { name:'fold', type:'float', default:0 },
      { name:'radius', type:'float', default:.01 },
      { name:'threshold', type:'float', default:.004 },
      { name:'scale', type:'float', default:2 },
    ],

    primitiveString( pName ) { 
      return `kifs( ${pName}, ${this.count.emit()}, ${this.fold.emit()}, ${this.radius.emit()}, ${this.threshold.emit()}, ${this.scale.emit()} )`
    },

    // adapted from http://roy.red/folding-the-koch-snowflake-.html
    glslify:glsl(["#define GLSLIFY 1\n      float box( vec3 p, vec3 b ){\n      vec3 d = abs(p) - b;\n      return min(max(d.x,max(d.y,d.z)),0.0) +\n             length(max(d,0.0));\n    }\n    vec2 fold(vec2 p, float ang){    \n        vec2 n=vec2(cos(-ang),sin(-ang));\n        p-=2.*min(0.,dot(p,n))*n;\n        return p;\n    }\n    #define KPI 3.14159\n    vec3 tri_fold(vec3 pt, float foldamt) {\n        pt.xy = fold(pt.xy,KPI/3. + foldamt );\n        pt.xy = fold(pt.xy,-KPI/3. + foldamt );\n        pt.yz = fold(pt.yz,KPI/6.+.7 + foldamt );\n        pt.yz = fold(pt.yz,-KPI/6. + foldamt );\n        return pt;\n    }\n    vec3 tri_curve(vec3 pt, float iter, float fold, float scale ) {\n        int count = int(iter);\n        for(int i=0;i<count;i++){\n            pt*=scale;\n            pt.x-=2.6;\n            pt=tri_fold(pt,fold);\n        }\n        return pt;\n    }\n    float kifs(in vec3 p, float a, float fold, float radius, float thresh, float scale ){\n        p.x+=1.5;\n        p=tri_curve(p,a,fold,scale);\n        // uncomment below line to use spheres instead of boxes\n        return (length( p*thresh ) - radius );\n        //return box( p*thresh, vec3(radius) );\n    }\n",""]),
  },

  Mandelbulb: {
    parameters:[
      { name:'c0', type:'float', default:8 },
    ],

    primitiveString( pName ) { 
      return `mandelbulb( ${pName}, ${this.c0.emit()} )`
    },

    // adapted from: https://www.shadertoy.com/view/ltfSWn
    glslify:glsl(["#define GLSLIFY 1\n      float mandelbulb( in vec3 p, in float aa ){\n        vec3 w = p;\n        float m = dot(w,w);\n\n        vec4 trap = vec4(abs(w),m);\n        float dz = 1.0;\n                \n        for( int i=0; i<4; i++ ) {\n          dz = aa*pow(sqrt(m),aa - 1.)*dz + 1.0;\n\n          float r = length(w);\n          float b = aa*acos( w.y /r);\n          float a = aa*atan( w.x, w.z );\n          w = p + pow(r,aa) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n          trap = min( trap, vec4(abs(w),m) );\n\n          m = dot(w,w);\n          if( m > 256.0 ) {\n            break;\n          }\n        }\n\n        return 0.25*log(m)*sqrt(m)/dz;\n      }\n    ",""]),
  },

  // adapted from https://www.shadertoy.com/view/llGXDR
  Mandelbox: {
    parameters:[
      { name:'fold', type:'float', default:.1 },
      { name:'scale', type:'float', default:3.},
      { name:'iterations', type:'float', default:5 },
    ],

    glslify:`float mandelbox( float MR2, float SCALE, float ITER, vec3 position ){
      vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;
      float C1 = abs(SCALE-1.0), C2 = pow(abs(SCALE), 1.-ITER); // 10 is ITERS
      vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor
      for (int i=0; i<int(ITER); i++) {
        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3gg, mad3
        float r2 = dot(p.xyz, p.xyz);  // dp3
        p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4
        p.xyzw = p*scalevec + p0;  // mad4
      }
      return (length(p.xyz) - C1) / p.w - C2;
  }`,

    primitiveString( pName ) {
      return `mandelbox( ${this.fold.emit()}, ${this.scale.emit()}, ${this.iterations.emit()}, ${pName} )`
    }
  },

	Octahedron: {
    parameters:[
      { name:'radius', type:'float', default:1 },
    ],

    primitiveString( pName ) { 
      return `sdOctahedron( ${pName}, ${this.radius.emit()} )`
    },

    glslify:`    float sdOctahedron(vec3 p, float h) {
    p.y = p.y + h; // center vertically... is it centered on the z-axis?
    vec2 d = .5*(abs(p.xz)+p.y) - min(h,p.y);
    return length(max(d,0.)) + min(max(d.x,d.y), 0.);
  }`
  }, 

 	Plane: {
    parameters:[
      { name:'normal', type:'vec3', default:[0,1,0] },
      { name:'distance', type:'float', default:1 },
    ],

    primitiveString( pName ) { 
      return `sdPlane( ${pName}, vec4( ${this.normal.emit()}, ${this.distance.emit()} ))`
    },
    
    glslify:glsl(["#define GLSLIFY 1\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n"])
    
  },  
 	Quad: {
    parameters:[
      { name:'v1', type:'vec3', default:[-.5,-.5,0] },
      { name:'v2', type:'vec3', default:[.5,-.5,0] },
      { name:'v3', type:'vec3', default:[.5,.5,0] },
      { name:'v4', type:'vec3', default:[-.5,.5,0] },
    ],

    primitiveString( pName ) { 
      return `udQuad( ${pName}, ${this.v1.emit()}, ${this.v2.emit()}, ${this.v3.emit()}, ${this.v4.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n"])
  }, 

  RoundBox: {
    parameters:[
      { name:'size', type:'vec3', default:[1,1,1] },
      { name:'radius', type:'float', default:1 },
    ],

    primitiveString( pName ) { 
      return `udRoundBox( ${pName}, ${this.size.emit()},  ${this.radius.emit()} )`
    }, 
    glslify:glsl(["#define GLSLIFY 1\n    float udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n"])
  }, 
  Sphere:{
    parameters:[
      { name:'radius', type:'float', default:1 },
    ],

    primitiveString( pName ) { 
      return `(length(${pName}) - ${this.radius.emit()})`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\n"])
  },
  // phi, m, n1, n2, n3, a, b
  SuperFormula:{
    parameters:[
      { name:'m_1', type:'float', default:1 },
      { name:'n1_1', type:'float', default:1 },
      { name:'n2_1', type:'float', default:1 },
      { name:'n3_1', type:'float', default:1 },
      { name:'a_1', type:'float', default:1 },
      { name:'b_1', type:'float', default:1 },
      { name:'m_2', type:'float', default:1 },
      { name:'n1_2', type:'float', default:1 },
      { name:'n2_2', type:'float', default:1 },
      { name:'n3_2', type:'float', default:1 },
      { name:'a_2', type:'float', default:1 },
      { name:'b_2', type:'float', default:1 },
    ],

    primitiveString( pName ) { 
      return `superformula( ${pName}, ${this.m_1.emit()}, ${this.n1_1.emit()},${this.n2_1.emit()},${this.n3_1.emit()},${this.a_1.emit()},${this.b_1.emit()}, ${this.m_2.emit()}, ${this.n1_2.emit()},${this.n2_2.emit()},${this.n3_2.emit()},${this.a_2.emit()},${this.b_2.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float SuperFormula( float phi, float m, float n1, float n2, float n3, float a, float b ){\n\t\n\tfloat t1 = abs((1.0 / a) * cos(m * phi / 4.0));\n\tt1 = pow(t1, n2);\n\n\tfloat t2 = abs((a / b) * sin(m * phi / 4.0));\n\tt2 = pow(t2, n3);\n\n\tfloat t3 = t1 + t2;\n\n\tfloat r = pow(t3, -1.0 / n1);\n\n\treturn r;\n}\n\n float superformula( vec3 p, float m_1, float n1_1, float n2_1, float n3_1, float a_1, float b_1, float m_2, float n1_2, float n2_2, float n3_2, float a_2, float b_2 ) {\n    float d = length( p );\n    float theta = atan(p.y / p.x);\n    float phi = asin(p.z / d);\n    float r1 = SuperFormula( theta, m_1, n1_1, n2_1, n3_1, a_1, b_1 );\n    float r2 = SuperFormula( phi, m_2, n1_2, n2_2, n3_2, a_2, b_2 );\n    vec3 q = r2 * vec3(r1 * cos(theta) * cos(phi), r1 * sin(theta) * cos(phi), sin(phi));\n    d = d - length(q);\n\n    return d;\n  }    \n",""]) },

  Torus:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1] },
    ],

    primitiveString( pName ) { 
      return `sdTorus( ${pName}, ${this.radii.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n"])

  },  
  Torus88:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1] },
    ],

    primitiveString( pName ) { 
      return `sdTorus88( ${pName}, ${this.radii.emit()} )`
    },
    glslify:`float sdTorus88( vec3 p, vec2 t ) {
        vec2 q = vec2( length8( p.xz ) - t.x, p.y );
        return length8( q ) - t.y;
      }\n`,
  },
  Torus82:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1] },
    ],

    primitiveString( pName ) { 
      return `sdTorus82( ${pName}, ${this.radii.emit()} )`
    },
    glslify:`float sdTorus82( vec3 p, vec2 t ) {
        vec2 q = vec2( length( p.xz ) - t.x, p.y );
        return length8( q ) - t.y;
      }\n`
  },
 	Triangle: {
    parameters:[
      { name:'v1', type:'vec3', default:[0,-.5,0] },
      { name:'v2', type:'vec3', default:[-.5,.0,0] },
      { name:'v3', type:'vec3', default:[.5,.0,0] },
    ],

    primitiveString( pName ) { 
      return `udTriangle( ${pName}, ${this.v1.emit()}, ${this.v2.emit()}, ${this.v3.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n"])
  }, 

  TriPrism: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.5,.5] },
    ],

    primitiveString( pName ) { 
      return `sdTriPrism( ${pName}, ${this.dimensions.emit()})`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n"])

  }, 
  /*VoxelSphere:{
    parameters:[
      { name:'radius', type:'float', default:1 },
      { name:'resolution', type:'float', default:20 },
      { name:'center', type:'vec3', default:[0,0,0] },
      { name:'material', type:'mat', default:null }
    ],

    primitiveString( pName ) { 
      return `VoxelSphere( ${pName}, ${this.radius.emit()}, ${this.resolution.emit()} )`
    },
    glslify:glsl`float sdBox( vec3 p, vec3 b ){
        vec3 d = abs(p) - b;
        return min(max(d.x,max(d.y,d.z)),0.0) +
               length(max(d,0.0));
      }
      float VoxelSphere( vec3 p, float radius, float resolution ) {
        //vec3 ref = p * resolution;
        //ref = round( ref );
        //return ( length( ref ) - resolution * radius ) / resolution;

        float dist = round( length( p ) - radius * resolution) / resolution;
        //if( dist < resolution ) {
        //  dist = sdBox( vec3(0.), vec3(resolution) );
        //}

        return dist; 
    }`
  },*/

}

},{"glslify":120}],19:[function(require,module,exports){
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const Transform = require( './transform.js' )

const createPrimitives = function( SDF ) {

  const gens = { 
    int:   int_var_gen,
    float: float_var_gen,
    vec2: vec2_var_gen,
    vec3: vec3_var_gen,
    vec4: vec4_var_gen,
  }

  const vars = { 
    vec2: Vec2,
    vec3: Vec3,
    vec4: Vec4
  }

  // load descriptions of all primtives
  const descriptions = require( './primitiveDescriptions.js' )

  const Primitives = { 
    descriptions,

    textureMemo: [],

    emit_geometries() {
      const head = Array.isArray( SDF.__scene.__prerender ) ? SDF.__scene.__prerender[0] : SDF.__scene.__prerender
      const geos = Primitives.crawlNode( head, [] )

      geos.forEach( (geo,i) => {
        geo.__sdfID = i 
        if( geo.__textureObj !== undefined ) {
          SDF.textures.addTexture( geo.__textureObj )
        }
      })

      const length = geos.length
      const materials = SDF.materials.materials

      let decl = `SDF sdfs[${length}] = SDF[${length}](\n`
      geos.forEach( (geo, i) => {
        const textureID = geo.__textureObj === undefined ? 50000 : geo.__textureObj.id
        const hasRepeat = geo.repeat !== null && geo.repeat !== undefined
        decl += `        SDF( ${materials.indexOf( geo.__material )}, ${geo.transform.varName}, ${textureID}, ${hasRepeat ? geo.repeat.distance.emit() : 'vec3(0.)'}, ${hasRepeat ? geo.repeat.transform.emit() : `mat4(1.)`} )`
        if( i < geos.length - 1 ) decl += ','
        decl += '\n'
      })

      decl += `      );\n`

      this.geometries = geos

      return decl
    },

    crawlNode( node, arr ) {
      if( node.type === 'geometry' ) {
        arr.push( node )
      }else{
        if( node.a !== undefined ) Primitives.crawlNode( node.a, arr )
        if( node.b !== undefined ) Primitives.crawlNode( node.b, arr )
        if( node.sdf !== undefined ) Primitives.crawlNode( node.sdf, arr )
      }

      return arr
    }
  }

  const createPrimitive = function( name, desc ) {

    const params = desc.parameters
    // create constructor
    Primitives[ name ] = function( ...args ) {
      const p = Object.create( Primitives[ name ].prototype )
      p.params = params
      p.transform = Transform()
      p.transform.shouldInvert = true
      p.type = 'geometry'
      p.name = name
      p.repeat = null//Var( vars.vec3( 0 ), null, 'vec3' )

      p.__material = null
      p.__textureID  = 500000
      
      let count = 0

      // wrap each param in a Var object for codegen
      for( let param of params ) {
        if( param.name === 'color' ) {
          p.color = args[ count ] === undefined ? param.default : args[ count++ ]
          continue
        }
        if( param.type === 'obj' ) {
          let __value = args[ count++ ]
          p[ param.name ] = {
            get value() { return __value },
            set value(v){ __value = v },
            emit() {
              const output =  p[ param.name ].value.emit()
              return output
            },
            emit_decl() {
              return p[ param.name ].value.a.emit_decl() + p[param.name].value.b.emit_decl()
            }
          }
          continue
        }
        const defaultValues = param.default
        const isArray = Array.isArray( defaultValues )

        if( isArray ) {
          let val = args[ count++ ], __var

          if( typeof val === 'number' ) {
            __var = Var( vars[ param.type ]( val ), null, 'vec3' )
          }else{
            __var =  param_wrap(
              val,
              gens[ param.type ]( ...defaultValues ) 
            )
          }

          // for assigning entire new vectors to property
          Object.defineProperty( p, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              if( typeof v === 'object' ) {
                __var.set( v )
              }else{
                __var.value.x = v
                __var.value.y = v
                __var.value.z = v
                __var.value.w = v
                __var.dirty = true
              }
            }
          })

        }else{
          let __var  = param_wrap( 
            args[ count++ ], 
            gens[ param.type ]( defaultValues ) 
          )

          //__var.set( defaultValues )
          Object.defineProperty( p, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              __var.set( v )
            }
          })
        }
      }

      p.id = VarAlloc.alloc()

      p.__desc = desc
      p.__setMaterial = function(mat) {
        if( typeof mat === 'string' ) mat = SDF.Material[ mat ]
        this.__material = this.mat = SDF.materials.addMaterial( mat )
      }

      p.__setTexture = function(tex,props) {
        if( typeof tex === 'string' ) {
          this.texture = p.texture.bind( this )
          this.__textureObj = this.tex = SDF.Texture( tex,props,this.texture )
          this.__textureID = this.__textureObj.id
        }else{
          this.__textureObj = this.tex = Object.assign( tex, props )
          this.__textureID = this.__textureObj.id
        }
      }
      p.__setBump = function(tex,props) {
        //this.bump = p.bump.bind( this )
        const b = this.bump = this.__bumpObj = SDF.Bump( this, tex, props )
        this.bump.texture = this.bump.amount.value
        this.__bumpID = this.__bumpObj.id
        this.rotate = this.bump.rotate
        this.translate = this.bump.translate
        this.scale = this.bump.scale
        Object.defineProperty( this.bump, 'strength', {
          get() { return b.size },
          set(v){ b.size = v }
        })
      }

      Object.assign( p, {
        renderingBump : false,
        emittingDecl  : false,
        uploading     : false,
        updating      : false
      })

      if( p.__material === null ) p.__setMaterial()

      SDF.geometries.push( p )

      return p
    }

    // define prototype to use
    Primitives[ name ].prototype = SceneNode()
    Primitives[ name ].prototype.type = 'geometry'
    
    // create codegen string


    Primitives[ name ].prototype.emit = function ( __name, transform = null, bump=null, scale=null ) {
      if( SDF.memo[ this.id ] !== undefined ) return { preface:'', out:name+this.matId }
      if( this.__bumpObj !== undefined && this.renderingBump === false) {
        this.renderingBump = true
        return this.__bumpObj.emit( __name, transform )
      }
      
      const shaderCode = desc.glslify.indexOf('#') > -1 
        ? desc.glslify.slice(18) 
        : desc.glslify

      if( SDF.requiredGeometries.indexOf( shaderCode ) === - 1 ) {
        SDF.requiredGeometries.push( shaderCode )
      } 

      if( transform !== null ) this.transform.apply( transform, false )
      //this.transform.invert( true )
      this.transform.internal()

      const pname = typeof __name !== 'string' ? 'p' : __name,
            id = this.__sdfID,
            s = scale === null ? this.transform.emit_scale() : `${this.transform.emit_scale()} * ${scale}`,
            tstring = `( ${pname} * ${this.transform.emit()} ).xyz`
      
      const primitive = `
        vec2 ${name}${this.id} = vec2( ${desc.primitiveString.call( this, tstring, bump )} * ${s}, ${id}.);
      `
      SDF.memo[ this.id ] = name + this.id

      this.renderingBump = false
      return { preface:primitive, out:name+this.id  }
    }
    
    // declare any uniform variables
    Primitives[ name ].prototype.emit_decl = function() {
      if( this.__bumpObj !== undefined && this.emittingDecl === false) {
        this.emittingDecl = true
        return this.__bumpObj.emit_decl() 
      }
      let decl = ''
      decl += this.transform.emit_decl()

      //debugger
      if( this.__repeat !== undefined ) decl += this.__repeat.emit_decl( false )
      if( this.__polarRepeat !== undefined ) decl += this.__polarRepeat.emit_decl( false )

      for( let param of params ) {
        if( param.name !== 'material' )
          decl += this[ param.name ].emit_decl( )
      }

      this.emittingDecl = false
      return decl
    }

    Primitives[ name ].prototype.update_location = function( gl, program ) {
      if( this.__bumpObj !== undefined && this.updating === false) {
        this.updating = true
        return this.__bumpObj.update_location( gl, program )
      }

      for( let param of params ) {
        if( param.type !== 'obj' ) {
          if( param.name !== 'material' ) 
            this[ param.name ].update_location( gl,program )
        }
      }

      if( this.__repeat !== undefined ) this.__repeat.update_location( gl, program, false )
      if( this.__polarRepeat !== undefined ) this.__polarRepeat.update_location( gl, program, false )
      this.transform.update_location( gl, program )
      this.updating = false
    }

    Primitives[ name ].prototype.upload_data = function( gl ) {
      if( this.__bumpObj !== undefined && this.uploading  === false ) {
        this.uploading = true
        return this.__bumpObj.upload_data( gl )
      }
      for( let param of params ) {
        if( param.type !== 'obj' && param.name !== 'material' )
          this[ param.name ].upload_data( gl )
      }

      if( this.__polarRepeat !== undefined ) this.__polarRepeat.upload_data( gl, false )
      this.transform.upload_data( gl )
      this.uploading = false
    }
    
    return Primitives[ name ]
  }
  
  for( let name in descriptions ) {
    const desc = descriptions[ name ]
    createPrimitive( name, desc )
  }

  Primitives.create = createPrimitive

  return Primitives
}

module.exports = createPrimitives

},{"./primitiveDescriptions.js":18,"./sceneNode.js":22,"./transform.js":26,"./utils.js":27,"./var.js":28,"./vec.js":29}],20:[function(require,module,exports){
const glsl = require( 'glslify' )

const getMainContinuous = function( steps, minDistance, maxDistance, postprocessing ) {
  const out = `
  // adapted from https://www.shadertoy.com/view/ldfSWs
  vec3 calcNormal(vec3 pos, float eps) {
    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

    return normalize( v1 * scene ( pos + v1*eps ).x+
                      v2 * scene ( pos + v2*eps ).x+
                      v3 * scene ( pos + v3*eps ).x+
                      v4 * scene ( pos + v4*eps ).x);
  }

  vec3 calcNormal(vec3 pos) {
    return calcNormal(pos, 0.002);
  }

  // Adapted from from https://www.shadertoy.com/view/ldfSWs
  vec2 calcRayIntersection( vec3 rayOrigin, vec3 rayDir, float maxd, float precis ) {
    float latest = precis * 2.0;
    float dist   = +0.0;
    float type   = -1.0;
    vec2 result;
    vec2 res = vec2(-50000., -1.);;

    for (int i = 0; i < ${steps} ; i++) {
      if (latest < precis || dist > maxd) break;

      result = scene(rayOrigin + rayDir * dist);

      latest = result.x;
      dist  += latest;
    }

    if( dist < maxd ) {
      result.x = dist;
      res = result;
    }

    return res;
  }

  out vec4 col;
  void main() {
    vec2 pos = v_uv * 2.0 - 1.0;

    // not sure why I need the -y axis but without it
    // everything is flipped using perspective-camera
    pos.x *= ( resolution.x / -resolution.y );

    vec3 color = bg; 
    vec3 ro = camera_pos;
    vec3 rd = normalize( mat3(camera) * vec3( pos, 2. ) ); 
    
    vec2 t = calcRayIntersection( ro, rd, ${maxDistance}, ${minDistance} );

    if( t.x > -0.5 ) {
      vec3 pos = ro + rd * t.x;
      vec3 nor = calcNormal( pos );

      color = lighting( pos, nor, ro, rd, t.y, true ); 
    }

    ${postprocessing}
    
    col = clamp( vec4( color, 1.0 ), 0., 1. );
  }`

  return out
}

const getMainVoxels = function( steps, postprocessing, voxelSize = .1 ) {
  const out = `
  struct VoxelDistance {
    bvec3 mask;
    vec3  distance;
    float fogCoeff;
    int   id;
  };

  VoxelDistance calcRayIntersection( vec3 rayOrigin, vec3 rayDir ) {
    vec2 result;

    float m = ${voxelSize};
    rayOrigin *= 1./m;
    vec3 mapPos = vec3(floor(rayOrigin));
    vec3 diff = mapPos - rayOrigin;

    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
    vec3 rayStep = vec3(sign(rayDir));
    vec3 sideDist = (sign(rayDir) * diff + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 

    bvec3 mask;
    vec3 d = vec3(-100000.);
    float fogCoeff = 0.;

    for (int i = 0; i < ${Math.round(steps*1/voxelSize)} ; i++) {
      result = scene(mapPos*m);
      if( result.x <= 0. ) {
        d = mapPos*m+result.x;
        break;
      }

      mask = bvec3( lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy)) );
      sideDist += vec3( mask ) * deltaDist; 
      mapPos += vec3(mask) * rayStep;
      fogCoeff += result.x * m;
    }

    VoxelDistance vd = VoxelDistance( mask, d, fogCoeff, int(result.y) );
    return vd;
  }

  out vec4 col;
  void main() {
    vec2 pos = v_uv * 2.0 - 1.0;

    // not sure why I need the -y axis but without it
    // everything is flipped using perspective-camera
    pos.x *= ( resolution.x / -resolution.y );
    
    vec3 color = bg; 
    vec3 ro = camera_pos;
    vec3 rd = normalize( mat3(camera) * vec3( pos, 2. ) ); 
                 
    VoxelDistance vd = calcRayIntersection( ro, rd );
    bvec3 mask = vd.mask;
    
    vec3 nor;
    if (mask.x) {
      color = vec3(0.5);
      nor = vec3(1.,0.,0.);
    }
    if (mask.y) {
      color = vec3(1.0);
      nor = vec3(0.,1.,0.);
    }
    if (mask.z) {
      color = vec3(0.75);
      nor = vec3(0.,0.,1.);
    }
    if( vd.distance.x == -100000. ) {
      color = bg;
    }
    
    float modAmount = ${(1./voxelSize).toFixed(1)};
    if( color != bg ) {
      vec3 pos = vd.distance; 
      //vec3 pos = ro + rd * vd.fogCoeff;

      color *= lighting( pos * modAmount, nor, ro, rd, float(vd.id), false ); 
      //color *= lighting( pos, nor, ro, rd, float(vd.id), false ); 
      //color = min(color,1.);
      //color = getTexture( 0, pos );
      
    }
    
    vec2 t = vec2( vd.fogCoeff, vd.id );
  ${postprocessing}; 
    col = vec4( color, 1. ); 
  }`

  return out
}

module.exports = function( variables, scene, preface, geometries, lighting, postprocessing, steps=90, minDistance=.001, maxDistance=20, ops, voxelSize=0 ) {

  const main = voxelSize === 0
    ? getMainContinuous( steps, minDistance, maxDistance, postprocessing ) 
    : getMainVoxels( steps, postprocessing, voxelSize )

    const fs_source = glsl(["     #version 300 es\n      precision mediump float;\n#define GLSLIFY 1\n\n\n      float PI = 3.141592653589793;\n\n      in vec2 v_uv;\n\n      struct Light {\n        vec3 position;\n        vec3 color;\n        float attenuation;\n      };\n\n      int rotationCount = 1;\n\n      mat4 rotations[4] = mat4[4](\n        mat4(0.), mat4(0.), mat4(0.), mat4(0.)\n      );\n\n      struct Material {\n        int  mode;\n        vec3 ambient;\n        vec3 diffuse;\n        vec3 specular;\n        float shininess;\n        vec3 fresnel;\n        int textureID;\n      };     \n\n      struct SDF {\n        int materialID;\n        mat4 transform;\n        int textureID;\n        vec3 repeat;\n        mat4 repeatTransform;\n      };\n\n      uniform float time;\n      uniform vec2 resolution;\n      uniform vec3 camera_pos;\n      uniform vec3 camera_normal;\n      uniform float camera_rot;\n      uniform mat4 camera;\n\n      ","\n\n      // must be before geometries!\n      float length8( vec2 p ) { \n        return float( pow( pow(p.x,8.)+pow(p.y,8.), 1./8. ) ); \n      }\n\n      ","\n\n      /* GEOMETRIES */\n      ","\n\n      vec2 scene(vec3 p);\n\n      // XXX todo put this in domainOperations.js\n      vec3 polarRepeat(vec3 p, float repetitions) {\n        float angle = 2.*PI/repetitions;\n        float a = atan(p.z, p.x) + angle/2.;\n        float r = length(p.xz);\n        float c = floor(a/angle);\n        a = mod(a,angle) - angle/2.;\n        vec3 _p = vec3( cos(a) * r, p.y,  sin(a) * r );\n        // For an odd number of repetitions, fix cell index of the cell in -x direction\n        // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n        if (abs(c) >= (repetitions/2.)) c = abs(c);\n        return _p;\n      }\n\n      // added k value to glsl-sdf-ops/soft-shadow\n      float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k ){\n        float res = 1.0;\n        float t = mint;\n\n        for( int i = 0; i < 12; i++ ) {\n          float h = scene( ro + rd * t ).x;\n          res = min( res, k * h / t );\n          t += clamp( h, 0.02, 0.10 );\n          if( h<0.001 || t>tmax ) break;\n        }\n\n        return clamp( res, 0.0, 1.0 );\n      }\n\n","\n\n    vec2 scene(vec3 _p ) {\n      vec4 p = vec4( _p, 1. );\n","\n      return ",";\n    }\n \n","\n",""],variables,ops,geometries,lighting,preface,scene,main)

    return fs_source
  }

},{"glslify":120}],21:[function(require,module,exports){
const getFog = require( './fog.js' )
const vignette = require( './vignette.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const __lighting = require( './lighting.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require('./var.js')

const getScene = function( SDF ) {

  Scene = function( objs, canvas, steps=100, minDistance=.001, maxDistance=40, size=2, shouldAnimate=false ) {
    const scene  = Object.create( Scene.prototype )

    MaterialID.clear()

    SDF.lighting.lights = []

    scene.__prerender = objs
    if( objs.length > 1 ) {
      // reduce objects to nested Unions
      scene.__prerender = objs.reduce( ( current, next ) => SDF.Union( current, next ) )
    }

    Object.assign( scene, { 
      objs, 
      canvas,
      postprocessing:[],
      __shadow:8
    })

    scene.animate( shouldAnimate )
      .steps( steps )
      .threshold( minDistance )
      .farPlane( maxDistance )
      .resolution( 1 )

    scene.useQuality = true
    scene.useVoxels  = false

    SDF.__scene = scene

    return scene
  }

  Scene.prototype = {
    animate( v ) { this.__animate = v; return this },  
    resolution( v ) { 
      this.width = Math.floor( this.canvas.width = window.innerWidth * v )
      this.height = Math.floor( this.canvas.height = window.innerHeight * v )
      
      this.__resolution = v;
      this.useQuality = false
      return this 
    },  
    voxel( v = .1 ) { 
      this.useVoxels = true
      this.__voxelSize = v
      return this
    },
    threshold( v ) { this.__threshold = v; this.useQuality = false; return this },  
    steps( v ) { this.__steps = v; this.useQuality = false; return this },  
    farPlane( v ) { this.__farPlane = v; this.useQuality = false;  return this },  
    camera( x=0, y=0, z=5, speed=1 ) {
      SDF.camera.__camera.position[0] = x
      SDF.camera.__camera.position[1] = y
      SDF.camera.__camera.position[2] = z
      SDF.camera.__camera.rotationSpeed = speed * .01
      SDF.camera.__camera.positionSpeed = speed * -.25
      SDF.camera.update()
      return this
    },
    shadow( k=0 ) {
      this.__shadow = k;
      return this;
    },
    quality( quality=10 ) {
      this.threshold( .1 / (quality * quality * quality ) )
      this.steps( quality * 20 )
      this.farPlane( quality * 5 )
      this.resolution( Math.min( .2 * quality, 2 ) )

      return this
    },
    light( ...lights ) {
      SDF.lighting.lights = SDF.lighting.lights.concat( lights )
      return this
    },
    fog: getFog( Scene, SDF ),
    vignette: vignette( Scene, SDF ),
    background: require( './background.js' )( Scene, SDF ),
    presets: {
      'fractal.close': {
        farPlane:1,
        resolution:1,
        steps:150,
        animated:true,
        threshold:.000125
      },
      'fractal.kindaclose': {
        farPlane:2,
        resolution:1,
        steps:250,
        animated:true,
        threshold:.000125/2
      },
      'fractal.med': {
        farPlane:5,
        resolution:.75,
        steps:80,
        animated:true,
        threshold:.001,
      },
      'fractal.low': {
        farPlane:3.0,
        resolution:.5,
        animated:true,
        steps:50,
        threshold:.005,
      },
      'fractal.high': {
        farPlane:10,
        resolution:1,
        animated:true,
        steps:100,
        threshold:.001,
      },
      'repeat.low': {
        farPlane:25,
        resolution:.5,
        animated:true,
        steps:50
      },
      'repeat.med': {
        farPlane:35,
        resolution:1,
        animated:true,
        steps:75
      },
      'repeat.high': {
        farPlane:40,
        resolution:1,
        animated:true,
        steps:100
      },
      'voxel.high': {
        resolution:1,
        animated:true,
        steps:30
      },
      'voxel.med': {
        resolution:1,
        animated:true,
        steps:20
      },
      'voxel.low': {
        resolution:.5,
        animated:true,
        steps:10
      },
    },

    applyPreset( presetName ) {
      const preset = this.presets[ presetName ]
      if( preset.farPlane !== undefined ) this.farPlane( preset.farPlane )
      this.steps( preset.steps )
      this.resolution( preset.resolution )
      this.threshold( preset.threshold || .001 )

      return preset.animated
    },
    render( quality=10, animate=false, useQuality=true ) {
      this.background() // adds default if none has been specified
      if( typeof quality === 'string' ) {
        animate = this.applyPreset( quality )
      }else if( this.useQuality === true ) {
        this.quality( quality )
      }
      this.animate( animate )

      SDF.distanceOps.__clear()
      SDF.textures.clear()
      const geometries = SDF.primitives.emit_geometries()

      let [ variablesDeclaration, sceneRendering, postprocessing ] = SDF.generateSDF( this )

      const lighting = SDF.lighting.gen( this.__shadow, geometries )
      variablesDeclaration += SDF.materials.emit_decl() 
      variablesDeclaration += SDF.textures.emit_decl() 
      variablesDeclaration += SDF.lighting.emit_decl() 

      this.fs = SDF.renderFragmentShader( 
        variablesDeclaration, 
        sceneRendering.out, 
        sceneRendering.preface,
        SDF.requiredGeometries.join('\n') + SDF.requiredOps.join('\n'),
        lighting,
        postprocessing, 
        this.__steps, this.__threshold, this.__farPlane.toFixed(1),
        SDF.distanceOps.__getGLSL(),
        this.useVoxels ? this.__voxelSize : 0
      )

      SDF.start( this.fs, this.width, this.height, this.__animate )

      //SDF.materials.materials.length = 0

      this.useQuality = true

      return this
    },

  }

  return Scene

}

module.exports = getScene 

},{"./background.js":3,"./fog.js":11,"./lighting.js":14,"./utils.js":27,"./var.js":28,"./vignette.js":30}],22:[function(require,module,exports){
const SceneNode = ()=> Object.create( SceneNode.prototype )
const Matrix = require( './external/matrix.js' )

SceneNode.prototype = {
	emit() { return "#NotImplemented#"; },

	emit_decl() { return ""; },

	update_location(gl, program) {},

  upload_data(gl) {},

  getID() {
    let id = this.id

    if( id === undefined && this.sdf !== undefined ) {
      id = this.sdf.getID()
    }

    return id
  },

  getCenter() {
    let center = this.center

    if( center === undefined && this.sdf !== undefined ) {
      if( this.sdf.getCenter === undefined ) {
        center = this.sdf.__wrapped.getCenter()
      }else{
        center = this.sdf.getCenter()
      }
    }

    return center
  },

  move( ...args ) {
    return this.translate( ...args )
  },

  rotate( angle, x,y,z ) {
    this.transform.rotation.angle = angle
    if( x !== undefined ) this.transform.rotation.axis.x = x
    if( y !== undefined ) this.transform.rotation.axis.y = y
    if( z !== undefined ) this.transform.rotation.axis.z = z
  
    return this
  },

  rotateBy( angle,x,y,z ) {
    this.transform.__rotations.push( Matrix.rotate( angle,x,y,z ) )
    return this
  },

  translate( x,y,z ) {
    if( x !== undefined && x !== null ) this.transform.translation.x = x
    if( y !== undefined && y !== null ) this.transform.translation.y = y
    if( z !== undefined && z !== null ) this.transform.translation.z = z
  
    return this
  },

  scale( amount ) {
    if( amount !== undefined ) this.transform.scale = amount
    return this
  },

  material( mat ) {
    this.__setMaterial( mat )
    return this
  },

  texture( tex,props ) {
    this.__setTexture( tex,props )
    return this
  },

  bump( tex,strength ) {
    this.__setBump( tex,strength )
    return this
  }
}

const ops = [ 'repeat', 'polarRepeat', 'elongation' ]

ops.forEach( op => {
  const constructorName = op[0].toUpperCase() + op.slice(1)
  SceneNode.prototype[ op ] = function( ...args ) {
    this[ op ] = this[ op ].bind( this )
    Object.assign( this[ op ], SceneNode.prototype )
    this.__target = this[ op ]
    this[ '__'+op ] = Marching[ constructorName ]( this, ...args, this[ op ] )
    this[ op ].transform = this[ '__'+op ].transform
    return this
  }
})

module.exports = SceneNode

},{"./external/matrix.js":9}],23:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      getPixels = require( 'get-pixels' ),
      createTexture = require( 'gl-texture2d' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' ), 
      { Vec2, Vec3, Vec4 } = require( './vec.js' )


const __Textures = function( SDF ) {
  const gens = { 
    int:   int_var_gen,
    float: float_var_gen,
    vec2: vec2_var_gen,
    vec3: vec3_var_gen,
    vec4: vec4_var_gen,
  }

  const vars = { 
    vec2: Vec2,
    vec3: Vec3,
    vec4: Vec4
  }

  const Textures = {
    textures:[],
    __textures:[],

    __texturePrefaces:[],
    __textureBodies:  [],

    __types: require( './textureDescriptions.js' ),
    __wrap : require( './textureWrap.js' ), 
    
    __emitFunction() {
      let pushedWrap = false

      let decl = `
      vec3 getTexture( int id, vec3 pos ) {
        vec3 tex;
        vec2 pos2;

        switch( id ) {\n`
      
      Textures.__textureBodies.length = 0

      let funcdefs = ''
      this.textures.forEach( (t,i) => {
        const mode = t.mode !== '2d' && t.glsl !== undefined ? '3d' : '2d'

        // add texture wrap function if needed
        if( mode === '2d' && pushedWrap === false ) {
          Textures.__textureBodies.push( Textures.__wrap )
          pushedWrap = true
        }

        const glsl = mode === '3d' ? t.glsl : t.glsl2d 
        if( Textures.__textureBodies.indexOf( glsl ) === -1 ) { 
          Textures.__textureBodies.push( glsl )
        }

        const args = t.parameters.map( p => t.__target[ p.name ].emit() ) 
        const functionName = mode === '2d' ? t.name + '2d' : t.name 

        //decl += `
        //  case ${i}:
        //      ${mode === '2d' 
        //      ? `    
        //      vec3 n = normalize( pos );
        //      vec4 texx =  vec4(${functionName}( .5*n.yz+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      vec4 texy =  vec4(${functionName}( .5*n.zx+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      vec4 texz =  vec4(${functionName}( .5*n.xy+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      tex = triplanar( n, texx, texy,texz,false,false ).xyz;`
        //      : ` 
        //      tex = ${functionName}( pos ${ args.length > 0 ? ',' + args.join(',') : ''} );
        //   `}
        //    break;\n`


        decl +=`
          case ${i}:
            ${mode === '2d' ? `     pos2 = getUVCubic( pos );\n` : ''} 
            tex = ${functionName}( ${mode === '2d' ?'pos2':'pos'} ${ args.length > 0 ? ',' + args.join(',') : ''} );
            break;\n`            

      })

      decl += `
          default:
            tex = vec3(0.);
            break;
        }

        return tex;
      }

      vec3 getTexture( int id, vec3 pos, vec3 nor, SDF sdf, bool useTransform ) {
        vec3 tex;
        vec2 pos2;
        vec3 tpos = pos;
        if( useTransform == true ) {
          if( length(sdf.repeat) != 0. ) {
            tpos = mod( (vec4(pos,1.) * sdf.repeatTransform).xyz, sdf.repeat) - .5 * sdf.repeat;
            tpos = ( vec4(tpos, 1.) * sdf.transform).xyz;
          }else{
            tpos = (vec4(tpos,1.) * sdf.transform).xyz;
          }
        }

        return getTexture( id, tpos );
      }
      `
     
      return { glsldefs: Textures.__textureBodies.join( '\n' ), mainfunc:decl }
    },

    clear() {
      Textures.textures.length = 0
    },

    addTexture( tex ) {
      // we have to dirty the texture so that its data
      // will be uploaded to new shaders, otherwise the
      // texture will only work the first time it's used, when
      // it's dirty on initialization.
      Textures.dirty( tex )

      // if texture with same name is already found, replace it,
      // otherwise push texture
      //const oldTex = Textures.textures.find( __tex => tex.name === __tex.name )
      //if( oldTex !== undefined ) {
      //  const idx = Textures.textures.indexOf( oldTex )
      //  Textures.textures.splice( idx, 1, tex )

      //  tex.id = idx 
      //}else{
        tex.id = Textures.textures.length
        Textures.textures.push( tex )
      //}

      return tex
    },

    texture( presetName='noise', props={}, target=null ){
      //const isPreset = filenameOrPreset.indexOf( '.' ) === -1
      //const defaults = { wrap:SDF.gl.MIRRORED_REPEAT }

      if( Textures.__types[ presetName ] === undefined ) {
        console.log( `the texture type '${presetName}' does not exist.` )
      }
      const tex = Object.assign( { mode:'3d' }, Textures.__types[ presetName ], props )

      if( target === null ) target = tex
      tex.__target = target

      for( let param of tex.parameters ) {
        const defaultValues = param.default
        const isArray = Array.isArray( defaultValues )

        let count = 0
        if( isArray ) {
          let val = props[ param.name ], __var

          if( typeof val === 'number' ) {
            __var = Var( vars[ param.type ]( val ), null, 'vec3' )
          }else{
            const initvalues = val !== undefined ? val : defaultValues
            __var = Var( vars[ param.type ]( ...initvalues ), null, param.type )
          }

          // for assigning entire new vectors to property
          Object.defineProperty( target, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              if( typeof v === 'object' ) {
                __var.set( v )
              }else{
                __var.value.x = v
                __var.value.y = v
                __var.value.z = v
                __var.value.w = v
                __var.dirty = true
              }
            }
          })

        }else{
          let __var  = param_wrap( 
            props[ param.name ], 
            gens[ param.type ]( defaultValues ) 
          )

          //__var.set( defaultValues )
          Object.defineProperty( target, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              __var.set( v )
            }
          })
        }
      }

      if( presetName === 'image' ) {
        if( props.filename !== undefined ) {
          tex.image = getPixels( props.filename, (err,pixels) => {
            if( err !== null ) {
              console.error( err )
              return
            }
            tex.pixels = pixels
            tex.gltexture = createTexture( SDF.gl, pixels )
            tex.gltexture.wrap = props.wrap === undefined ? Marching.gl.REPEAT : props.wrap
          })
        }else{
          tex.image = null
          console.error('You must specify a filename when using the iamge preset.')
        }
      }else if( presetName === 'canvas' ) {
        if( props.canvas === undefined ) {
          tex.canvas = tex.image = document.createElement('canvas')
          tex.ctx    = tex.canvas.getContext('2d')
        }else{
          tex.image = props.canvas
        }

        tex.update = function() {
          tex.gltexture.setPixels( tex.image )
        }

        tex.gltexture = createTexture( SDF.gl, tex.image )
        tex.gltexture.wrap = props.wrap === undefined ? Marching.gl.REPEAT : props.wrap

        tex.update()
      }


      Object.defineProperty( tex, 'wrap', {
        get() { return this.gltexture.wrap },
        set(v){ this.gltexture.wrap = v }
      })

      tex.name = presetName

      return tex 
    },

    dirty( tex ) {},
   
    emit_decl() {
      if( this.textures.length === 0 ) return '' 

      let decl = ''

      const memo = []
      let imageCount = 0;
      this.textures.forEach( (tex,i) => {
        if( memo.indexOf( tex ) === -1 ) {
          for( let param of tex.parameters ) {
            if( param.name !== 'material' )
              decl += tex.__target[ param.name ].emit_decl()
          }
          memo.push( tex )
        }
        if( tex.name === 'image' || tex.name === 'canvas' ) {
          imageCount++

          // for some reason can't immediately call update... 
          // have to wait for some type of dom initialization?
          // so call here
          if( tex.update ) tex.update()
        }
      })

      if( imageCount > 0 ) {
        decl += `\n      uniform sampler2D textures[${imageCount}];\n`
      }
      return decl
    },
    
    update_location( gl, program ) {
      if( this.textures.length > 0 ) {
        this.textures.forEach( (tex,i) => {
          for( let param of tex.parameters ) {
            if( param.type !== 'obj' ) {
              if( param.name !== 'material' ) 
                tex.__target[ param.name ].update_location( gl,program )
            }
          }
          if( tex.name === 'image' || tex.name === 'canvas' ) {
            tex.loc = gl.getUniformLocation( program, `textures[${tex.id}]` )
            tex.gltexture.bind( i )
          }
        })
      }

      //if( this.textures.length > 0 ) {
      //  this.textures.sort( (a,b) => a.id > b.id ? 1 : -1 ) 

      //  for( let tex of this.textures ) {
      //    tex.loc = gl.getUniformLocation( program, `textures[${tex.id}]` )
      //    tex.gltexture.bind( tex.id )
      //  }

      //  this.__textures = this.textures.slice( 0 )
      //  this.textures.length = 0
      //}
    },

    upload_data( gl, program ) {
      if( this.textures.length > 0 ) {
        this.textures.forEach( (tex,i) => {
          for( let param of tex.parameters ) {
            if( param.type !== 'obj' && param.name !== 'material' )
              tex.__target[ param.name ].upload_data( gl )
          }
          if( tex.name === 'image' || tex.name === 'canvas' ) {
            gl.uniform1i( tex.loc, i )
          }
        })
      }
    }

  }

  Textures.texture.create = function( props ) {
    Textures.__types[ props.name ] = props
  }

  Object.defineProperties( Textures.texture, {
    'repeat': { get() { return Marching.gl.REPEAT } },
    'mirror': { get() { return Marching.gl.MIRRORED_REPEAT } },
    'clamp': { get() { return Marching.gl.CLAMP_TO_EDGE } },
  })

  const f = value => value % 1 === 0 ? value.toFixed(1) : value 

  return Textures
}

module.exports = __Textures

},{"./sceneNode.js":22,"./textureDescriptions.js":24,"./textureWrap.js":25,"./utils.js":27,"./var.js":28,"./vec.js":29,"get-pixels":42,"gl-texture2d":73}],24:[function(require,module,exports){
const glsl = require( 'glslify' )

const textures = {
  image: {
    name:'image',
    glsl2d:`
      vec3 image2d( vec2 uv, float scale, float strength ) {
        return texture( textures[ 0 ], uv*scale ).xyz * strength;
      }
    `,
    parameters:[
      { name:'scale', type:'float', default:1 },
      { name:'strength', type:'float', default:1 },   
    ]
  },
  canvas: {
    name:'canvas',
    glsl2d:`
      vec3 canvas2d( vec2 uv, float scale, float strength ) {
        return texture( textures[ 0 ], uv*scale ).xyz * strength;
      }
    `,
    parameters:[
      { name:'scale', type:'float', default:1 },
      { name:'strength', type:'float', default:1 },   
    ]
  },
  rainbow: {
    name:'rainbow',
    parameters: [
      { name:'strength', type:'float', default:1 },
      { name:'shift', type:'float', default:0 },
      { name:'scale', type:'float', default:1 },
    ],
    glsl:` 
    vec3 rainbow( vec3 pos, float strength, float shift, float scale ) {
      pos = pos * scale;
      vec3 a = vec3(0.5,0.5,0.5), b = vec3(0.5,0.5,0.5), c = vec3(1.0,1.0,1.0),d = vec3(0.0,0.33,0.67);
      return a + b * cos( 6.283818 * ( c * mod(length(pos) + shift, 1. ) + d ) ) * strength;
    }` 
  },
  checkers: {
    name:'checkers',
    glsl:`          
        vec3 checkers( vec3 pos, float size, vec3 color1, vec3 color2 ) {
          vec3 tex;
          pos  = pos * size;
          if ((int(floor(pos.x) + floor(pos.y) + floor(pos.z)) & 1) == 0) {
            tex = color1;
          }else{
            tex = color2;
          }

          return tex;
        }`,
    glsl2d:`
        vec3 checkers2d( vec2 uv, float size, vec3 color1, vec3 color2 ) {
          float fmodResult = mod(floor(size * uv.x) + floor(size * uv.y), 2.0);
          float fin = max(sign(fmodResult), 0.0); 

          return vec3(fin);
        }
    `,
    parameters: [
      { name:'scale',  type:'float', default:5 },
      { name:'color1', type:'vec3', default:[1,1,1] },
      { name:'color2', type:'vec3', default:[0,0,0] }
    ],
  },
  noise: {
    name:'noise',
    glsl:glsl(["#define GLSLIFY 1\n          \n        //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n        vec3 noise( vec3 pos, float scale, float strength, float time ) {\n          float n = snoise( vec4(pos*scale, time) );\n          return vec3( n ) * strength;\n        }",""]),
    glsl2d:glsl(["#define GLSLIFY 1\n    \n        //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n        vec3 noise2d( vec2 st, float scale, float strength, float time ) {\n          float col = snoise( vec3( st, time ) * scale );\n\n          return vec3(col) * strength;\n        }\n",""]) ,
    parameters: [
      { name:'scale', type:'float', default:2 },
      { name:'strength', type:'float', default:.1 },
      { name:'time', type:'float', default:1 }
    ],
  },
  // adapted from https://thebookofshaders.com/10/
  truchet: {
    name:'truchet',
    glsl2d:`    
        float random_truchet(in vec2 _st) {
          return fract(sin(dot(_st.xy,
                         vec2(12.9898,78.233)))*
                        43758.5453123);
        }

        vec2 truchetPattern(in vec2 _st, in float _index){
            _index = fract(((_index-0.5)*2.0));
            if (_index > 0.75) {
                _st = vec2(1.0) - _st;
            } else if (_index > 0.5) {
                _st = vec2(1.0-_st.x,_st.y);
            } else if (_index > 0.25) {
                _st = 1.0-vec2(1.0-_st.x,_st.y);
            }
            return _st;
        }

        vec3 truchet2d( vec2 st, float scale, vec3 color ) {
            st = st * scale;
            vec2 ipos = floor(st);  // integer
            vec2 fpos = fract(st);  // fraction

            vec2 tile = truchetPattern(fpos, random_truchet( ipos ));

            float col = smoothstep(tile.x-0.3,tile.x,tile.y)-smoothstep(tile.x,tile.x+.3,tile.y);
            return color * col;
        }

` ,
    parameters: [
      { name:'scale', type:'float', default:10 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  dots: {
    name:'dots',
    glsl:`          
        vec3 dots( vec3 pos, float count, float radius, vec3 color ) {
          vec3 tex;
          tex = vec3( color - smoothstep( radius, radius+.02, length(fract(pos*(round(count/2.)+.5)) -.5 )) );
          return tex;
        }` ,
    glsl2d:`
      vec2 tile(vec2 _st, float _zoom){
        _st *= _zoom;
        return fract(_st);
      }

      float circle(vec2 _st, float _radius){
        vec2 pos = vec2(0.5)-_st;
        _radius *= 0.75;
        return 1.-smoothstep(_radius-(_radius*0.05),_radius+(_radius*0.05),dot(pos,pos)*3.14);
      }
    
      vec3 dots2d( vec2 _st, float scale, float radius, vec3 color ) {
        vec2 st = tile(_st,scale);
        vec3 fin = vec3(circle(st, radius)) * color;
        return fin;
      }
    `,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'radius', type:'float', default:.3 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  stripes: {
    name:'stripes',
    glsl:`          
        vec3 stripes( vec3 pos, float scale, vec3 color ) {
          vec3 tex;
          tex = vec3( color - smoothstep(0.3, 0.32, length(fract((pos.x+pos.y+pos.z)*scale) -.5 )) );
          return tex;
        }` ,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  cellular: {
    name:'cellular',
    glsl:glsl(["#define GLSLIFY 1\n\n        // Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n\n}\n\n        vec3 cellular( vec3 pos, float scale, float jitter, float mode, float strength, float time ) {\n          vec2 w = worley( pos * scale + time, jitter, false );\n          vec3 o;\n          if( mode == 0. ) {\n            o = vec3( w.x );\n          } else if ( mode == 1. ) {\n            o = vec3( w.y );\n          } else{\n            o = vec3( w.y - w.x );\n          }\n\n          return o * strength;\n        }\n    ",""]),
    glsl2d:glsl(["#define GLSLIFY 1\n\n        // Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n\n}\n\n        vec3 cellular( vec3 pos, float scale, float jitter, float mode, float strength ) {\n          vec2 w = worley( pos, jitter, false );\n          vec3 o;\n          if( mode == 0. ) {\n            o = vec3( w.x );\n          } else if ( mode == 1. ) {\n            o = vec3( w.y );\n          } else{\n            o = vec3( w.y - w.x );\n          }\n\n          return o * strength;\n        }\n\n        vec3 cellular2d( vec2 st, float scale, float jitter, float mode, float strength, float time ) {\n          return cellular( vec3(st * scale, time), nor, scale, jitter, mode, strength );\n        }\n    ",""]),
    parameters: [
      { name:'scale', type:'float', default:1 },
      { name:'jitter', type:'float', default:1 },
      { name:'type',  type:'float', default: 0 },
      { name:'strength', type:'float', default:2 },
      { name:'time', type:'float', default:1 }
    ],     
  },

  voronoi: {
    name:'voronoi',
    parameters: [
      { name:'scale', type:'float', default:1 },
      { name:'res', type:'float', default:100 },
      { name:'time', type:'float', default:1 },
      { name:'mode', type:'float', default:0 }
    ],
    glsl:`
    vec3 voronoi_hash(vec3 p) {
      return fract(
          sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),
                   dot(p, vec3(113.0, 1.0, 57.0)))) *
          43758.5453);
    }

    vec3 voronoi_3d(const in vec3 x, float _res ) {
      vec3 p = floor(x);
      vec3 f = fract(x);

      float id = 0.0;
      vec2 res = vec2( _res );
      for (int k = -1; k <= 1; k++) {
        for (int j = -1; j <= 1; j++) {
          for (int i = -1; i <= 1; i++) {
            vec3 b = vec3(float(i), float(j), float(k));
            vec3 r = vec3(b) - f + voronoi_hash(p + b);
            float d = dot(r, r);

            float cond = max(sign(res.x - d), 0.0);
            float nCond = 1.0 - cond;

            float cond2 = nCond * max(sign(res.y - d), 0.0);
            float nCond2 = 1.0 - cond2;

            id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);
            res = vec2(d, res.x) * cond + res * nCond;

            res.y = cond2 * d + nCond2 * res.y;
          }
        }
      }

      return vec3(sqrt(res), abs(id));
    }

    vec3 voronoi( vec3 pos, float scale, float res, float time, float mode ) {
      vec3 v = voronoi_3d( pos * scale, res );
      vec3 fin;
      if( mode == 0. ) fin = vec3(v.x);
      if( mode == 1. ) fin = vec3(v.y);
      if( mode == 2. ) fin = vec3(v.y - v.x); 

      return fin;
    }
`,
    glsl2d:glsl(["#define GLSLIFY 1\n    \n    vec3 voronoi_hash(vec3 p) {\n      return fract(\n          sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n                   dot(p, vec3(113.0, 1.0, 57.0)))) * 43758.5453);\n    }\n\n    vec3 voronoi_3d(const in vec3 x, float _res ) {\n      vec3 p = floor(x);\n      vec3 f = fract(x);\n\n      float id = 0.0;\n      vec2 res = vec2( _res );\n      for (int k = -1; k <= 1; k++) {\n        for (int j = -1; j <= 1; j++) {\n          for (int i = -1; i <= 1; i++) {\n            vec3 b = vec3(float(i), float(j), float(k));\n            vec3 r = vec3(b) - f + voronoi_hash(p + b);\n            float d = dot(r, r);\n\n            float cond = max(sign(res.x - d), 0.0);\n            float nCond = 1.0 - cond;\n\n            float cond2 = nCond * max(sign(res.y - d), 0.0);\n            float nCond2 = 1.0 - cond2;\n\n            id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n            res = vec2(d, res.x) * cond + res * nCond;\n\n            res.y = cond2 * d + nCond2 * res.y;\n          }\n        }\n      }\n\n      return vec3(sqrt(res), abs(id));\n    }\n\n    vec3 voronoi2d( vec2 st, float scale, float res, float time, float mode ) {\n      vec3 v = voronoi_3d( vec3(st* scale, time), res );\n      vec3 fin;\n      if( mode == 0. ) fin = vec3(v.x);\n      if( mode == 1. ) fin = vec3(v.y);\n      if( mode == 2. ) fin = vec3(v.y - v.x); \n\n      return fin;\n    }\n\n",""]) ,
  },
  // adapted from https://thebookofshaders.com/edit.php#09/zigzag.frag
  zigzag: {
    name:'zigzag',
    glsl2d:`    
       vec2 mirrorTile(vec2 _st, float _zoom){
         _st *= _zoom;
         if (fract(_st.y * 0.5) > 0.5){
           _st.x = _st.x+0.5;
           _st.y = 1.0-_st.y;
         }
         return fract(_st);
       }

       float fillY(vec2 _st, float _pct,float _antia){
         return smoothstep( _pct-_antia, _pct, _st.y);
       }

       vec3 zigzag2d( vec2 st, float scale, float time ) {
         st = mirrorTile(st*vec2(1.,2.),scale);
         float x = st.x*2.;
         float a = floor(1.+sin(x*3.14));
         float b = floor(1.+sin((x+1.)*3.14));
         float f = fract(x);

         vec3 color = vec3( fillY(st,mix(a,b,f),0.01) ); 

         return vec3(color);
       }
` ,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'time', type:'float', default:1 }
    ],
  }
}

module.exports = textures

},{"glslify":120}],25:[function(require,module,exports){
module.exports = `
    // p = point on surface, p0 = object center
    vec2 getUVCubic(vec3 p ){
      vec3 absp = abs(p);
        
      // First conditional: If the point is in one of the sextants to the 
      // left or right of the x-axis, the uv cordinate will be (0.5*p.zy)/(p.x).
      // If you trace a line out to a zy plane that is 0.5 units from the zero origin,  
      // (0.5*p.xyz)/(p.x) will be the result, and
      // the yz components will be our uv coordinates, hence (0.5*p.zy)/(p.x).

      vec2 uv = ((absp.x>=absp.y)&&(absp.x>=absp.z)) 
        ? (0.5*p.zy)/(p.x) 
        : ((absp.y>=absp.z)&&(absp.y>=absp.x)) ? (0.5*p.xz)/(p.y) : (-0.5*p.xy)/(p.z);

      //We still need to determine which side our uv cordinates are on so
      //that the texture orients the right way. Note that there's some 
      // redundancy there, which I'll fix at some stage. For now, it works, so I'm not touching it. :)
      if( ((p.x<0.)&&(absp.x>=absp.y)&&(absp.x>=absp.z)) 
       || ((p.y<0.)&&(absp.y>=absp.z)&&(absp.y>=absp.x)) 
       || ((p.z>0.)&&(absp.z>=absp.x)&&(absp.z>=absp.y)) ) uv.y*=-1.;
             
      // Mapping the uv range from [-0.5, 0.5] to [0.0, 1.0].
      return (uv+0.5);
    }
    vec4 triplanar(vec3 n, vec4 texx, vec4 texy, vec4 texz, bool adjust3d, bool rescale) {
      //if (doflipz) n.z = -n.z;
      if (rescale) {
        texx = 2.0*texx - 1.0;
        texy = 2.0*texy - 1.0;
        texz = 2.0*texz - 1.0;
      }
      if (adjust3d) {
        texx.x *= sign(n.x);
        texy.y *= sign(n.y);
        texz.z *= sign(n.z);
      }
      //if (justtexy) return texy;
      vec3 weights = abs(n);
      //if (doweightcorrection) weights /= dot(weights,vec3(1)); // Keep spherical!
        return mat4(texx,texy,texz,vec4(0))*vec4(weights,0);
    } 
    `
/*
module.exports = `vec3 t3(sampler2D tex, vec3 p, vec3 n)
{
  mat3 R = mat3(vec3(cos(T),sin(T),0),vec3(-sin(T),cos(T),0),vec3(0,0,-1));
  p *= R/8.0;
  n *= R;
  #ifdef Smooth
  return  (texture(tex,p.xy).rgb*n.z*n.z
    +texture(tex,p.zy).rgb*n.x*n.x
    +texture(tex,p.xz).rgb*n.y*n.y);
  #else
    return (texture(tex,p.xy).rgb
      +texture(tex,p.zy).rgb
      +texture(tex,p.xz).rgb)/3.0;
    #endif
    }`
    */

},{}],26:[function(require,module,exports){
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' )
const Matrix = require( './external/matrix.js' )
window.Matrix = Matrix
const MatrixWrap = function ( shouldInvert = false ) {
  const m = Object.create( MatrixWrap.prototype )
  m.dirty = true
  m.translation = {}
  m.scale = {}
  m.shouldInvert = shouldInvert
  m.rotation = {
    axis: {}
  }
  m.parent = null

  let tx = 0, ty = 0, tz = 0
  Object.defineProperties( m.translation, {
    x: {
      get() { return tx },
      set(v){
        tx = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
    y: {
      get() { return ty },
      set(v){
        ty = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
    z: {
      get() { return tz },
      set(v){
        tz = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
  })

  // scaling must be sent as separate uniform to avoid sdf over estimation 
  let scale = 1
  Object.defineProperty( m,'scale', {
    get() { return scale },
    set(v){
      scale = v
      //m.__data = m.__data.multiply( Matrix.rotate( angle, rx, ry, rz ) )
      m.dirty = true
    } 
  })

  /* FOR NON-UNIFORM SCALING:
   *
   * 1. comment out scale property above
   * 2. uncomment scale property below
   * 3. change emit_decl to use a vec3 for scale
   * 4. change upload_data to upload a 3f
   * 5. In "primitives.js", replace line 155 (part of emit) to use compensated scaling
   */ 

  //let sx = 1, sy = 1, sz = 1
  //Object.defineProperties( m.scale, {
  //  x: {
  //    get() { return sx },
  //    set(v){
  //      sx = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //  y: {
  //    get() { return sy },
  //    set(v){
  //      sy = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //  z: {
  //    get() { return sz },
  //    set(v){
  //      sz = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //})

  let angle = 0
  Object.defineProperty( m.rotation, 'angle', {
    get() { return angle },
    set(v){
      angle = v
      //m.__data = m.__data.multiply( Matrix.rotate( angle, rx, ry, rz ) )
      m.dirty = true
    } 
  })

  let rx = 0, ry = 0, rz = 0
  Object.defineProperties( m.rotation.axis, {
    x: {
      get() { return rx },
      set(v){
        rx = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
    y: {
      get() { return ry },
      set(v){
        ry = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
    z: {
      get() { return rz },
      set(v){
        rz = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
  })

  m.__rotations = []
  m.__id   = VarAlloc.alloc()  
  m.__dirty = function() {}
  m.__data = Matrix.identity()
  m.__Matrix = Matrix
  m.varName = 'transform' + m.__id

  return m
}

MatrixWrap.prototype = {
  type: 'matrix',

  emit() { return this.varName },

  emit_scale() { return this.varName + '_scale' },

  emit_decl() { 
    const decl =  `    uniform mat4 ${this.varName};
    uniform float ${this.varName}_scale;
    ` 

    return decl
  },

	update_location(gl, program) {
		this.loc = gl.getUniformLocation( program, this.varName )
		this.loc_scale = gl.getUniformLocation( program, this.varName+'_scale' )
	},	

	upload_data(gl) {
		if( !this.dirty ) return
		
    this.internal()

    if( this.shouldInvert === true ) {
      const inverse = Matrix.inverse( this.__data )
      gl.uniformMatrix4fv( this.loc, false, inverse.m )
    }else{
      gl.uniformMatrix4fv( this.loc, false, this.__data.m )
    }
    //gl.uniform3f(this.loc_scale, this.scale.x, this.scale.y, this.scale.z )
    
    // scaling must be sent as separate uniform to avoid sdf over-estimation 
    gl.uniform1f(this.loc_scale, this.scale )

		this.dirty = false
  },


  internal() {
    this.__data = Matrix.identity()
    if( this.parent != null ) this.__data = this.parent.__data

    this.__data = this.__data.multiply( Matrix.translate( this.translation.x, this.translation.y, this.translation.z ) ) 

    // handle cumulative rotations via .rotateBy() method
    this.__rotations.forEach( r => this.__data = this.__data.multiply( r ) )

    // handle absolute rotations via .rotate() method... should this be aliased to rotateTo() ?
    this.__data = this.__data.multiply( Matrix.rotate( this.rotation.angle, this.rotation.axis.x, this.rotation.axis.y, this.rotation.axis.z ) )

    this.__data = this.__data.multiply( Matrix.scale( this.scale, this.scale, this.scale ) )
  },

  invert( shouldInvert = true) {
    this.shouldInvert = shouldInvert
    this.dirty = true
  },

  apply( transform = null, shouldInvert = false ) {
    this.parent = transform
    this.dirty = true
  } 

}

module.exports = MatrixWrap

},{"./external/matrix.js":9,"./utils.js":27,"./var.js":28}],27:[function(require,module,exports){
const Var = require('./var.js').Var

// Wrapper
function param_wrap( v, __default, name=null ) {
	if( v === undefined || v === null ) return __default()
	if( v.__isVar === true ) return v
	
	return Var( v, name )
}

const MaterialID = {
	current: 0,
	alloc() {
		return MaterialID.current++
  },
  clear() {
    MaterialID.current = 0
  }
}

module.exports = { param_wrap, MaterialID }

},{"./var.js":28}],28:[function(require,module,exports){
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const float = require( './float.js' )
const int   = require( './int.js' )

// Var
const VarAlloc = {
	current: 0,
  clear() {
    VarAlloc.current = 0
  },
	alloc() {
		return VarAlloc.current++
	}
}

let Var = function( value, fixedName = null, __type ) {
  const v = Object.create( Var.prototype )
	v.varName = fixedName !== null ? fixedName : 'var' + VarAlloc.alloc()
  v.value = value
  v.type = v.value.type
  if( v.type === undefined ) v.type = __type || 'float' 

  value.var = v

  if( v.type !== 'float' && v.type !== 'int' ) {
    Object.defineProperties( v, {
      x: {
        get() { return this.value.x },
        set(v){ this.value.x = v; this.dirty = true }
      },
      y: {
        get() { return this.value.y },
        set(v){ this.value.y = v; this.dirty = true }
      },
      z: {
        get() { return this.value.z },
        set(v){ this.value.z = v; this.dirty = true }
      },
      w: {
        get() { return this.value.w },
        set(v){ this.value.w = v; this.dirty = true }
      },
    })
  }/*else{
    let __value = v.value
    Object.defineProperty( v, 'value', {
      get() { return __value },
      set(v){ __value = v; this.dirty = true }
    })
  }*/

  return v
}

Var.hardcode = false
const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

Var.prototype = {
	dirty: true,

	loc: -1,

  emit() { 
    let out
    if( this.value.isGen ) {
      const vecOut = this.value.emit() 
      out = vecOut.preface + vecOut.out
        
    }else{
      out = this.varName 
    } 

    return out
  },

  emit_decl() { 
    let out = ''
    if( this.value.isGen ) {
      out = this.value.emit_decl()
    }else{
      if( Var.hardcode === true ) {

        if( typeof this.value.emit !== 'function' ) {
          if( this.type === 'float' ) {
            out = `${this.type} ${this.varName} = ${emit_float(this.value)};\n`
          }else{
            out = `${this.type} ${this.varName} = ${this.value};\n`
          }
        }else{
          let val = this.value.emit()
          if( typeof val !== 'string' ) val = val.out
          out = val !== undefined ? `${this.type} ${this.varName} = ${val};\n` : ''
        }
      }else{
        out = `uniform ${this.type} ${this.varName};\n`
      }
    }
    return out
  },

	set(v) { this.value = v; this.dirty = true; },

	update_location(gl, program) {
    if( this.value.isGen ) {
      this.value.update_location( gl, program )
      return
    }
		this.loc = gl.getUniformLocation(program, this.varName)
	},	

	upload_data(gl) {
		if( !this.dirty ) return
		
    if( this.value.isGen ) {
      this.value.upload_data( gl  )
      this.dirty = false
      return
    }
		let v = this.value
		if (typeof v === 'number' ) {
			gl.uniform1f( this.loc, v )
		}else if ( v instanceof Vec2 ) {
			gl.uniform2f(this.loc, v.x, v.y )
		} else if( v instanceof Vec3 ) {
			gl.uniform3f(this.loc, v.x, v.y, v.z )
		} else if( v instanceof Vec4 ) {
			gl.uniform4f(this.loc, v.x, v.y, v.z, v.w )
    } else {
      // for color variables
      if( this.type === 'float' ) {
        gl.uniform1f( this.loc, v.x )
      }else{
        gl.uniform1i( this.loc, v.x )
      }
    }

		this.dirty = false
	}
}


function int_var_gen(x,name=null) { 
  let output = ()=> {
    let out = Var( int(x), name, 'int' ) 
    return out
  }

  return output
}
function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

function vec2_var_gen(x, y,name=null) { 
  if( y === undefined ) y = x
  return ()=> Var( Vec2(x, y), name  ) 
}

function vec3_var_gen(x=0, y, z,name=null) { 
  if( y === undefined ) y = x
  if( z === undefined ) z = x
  return ()=> Var( Vec3(x, y, z), name ) 
}

function vec4_var_gen( x, y, z, w, name=null ) { 
  if( y === undefined ) y = x
  if( z === undefined ) z = x
  if( w === undefined ) w = x
  return Var( Vec4( x, y, z, w ), name ) 
}
//function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

//function vec2_var_gen(x, y,name=null) { return ()=> Var( Vec2(x, y), name  ) }

//function vec3_var_gen(x, y, z,name=null) { return ()=> Var( Vec3(x, y, z), name ) }

//function vec4_var_gen( x, y, z, w, name=null ) { return Var( Vec4( x, y, z, w ), name ) }

module.exports = { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }

/*function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

function vec2_var_gen(x, y,name=null) { 
  if( y === undefined ) y = x
  return ()=> Var( Vec2(x, y), name  ) 
}

function vec3_var_gen(x, y, z,name=null) { 
  if( y === undefined ) y = x
  if( z === undefined ) z = x
  return ()=> Var( Vec3(x, y, z), name ) 
}

function vec4_var_gen( x, y, z, w, name=null ) { 
  if( y === undefined ) y = x
  if( z === undefined ) z = x
  if( w === undefined ) w = x
  return Var( Vec4( x, y, z, w ), name ) 
}
*/

},{"./float.js":10,"./int.js":13,"./vec.js":29}],29:[function(require,module,exports){
const Vec2 = function (x=0, y=0) {
  const v = Object.create( Vec2.prototype )
  v.x = x; v.y = y

  return v
}

Vec2.prototype = {
  type: 'vec2',
	emit() { return "vec2(" + this.x + "," + this.y + ")" },
  emit_decl() { return ""; },
  copy() {
    return Vec2( this.x, this.y )
  }
}

const Vec3 = function (x=0, y, z) {
  const v = Object.create( Vec3.prototype )
  let vx =0,vy=0,vz=0
  Object.defineProperties( v, {
    x: {
      get()  { return vx },
      set(v) { vx = v; this.dirty = true; }
    },

    y: {
      get()  { return vy },
      set(v) { vy = v; this.dirty = true; }
    },

    z: {
      get()  { return vz },
      set(v) { vz = v; this.dirty = true; }
    },
  })

  if( y === undefined && z === undefined) {
    v.x = v.y = v.z = x
  }else{
    v.x = x; v.y = y; v.z = z;
  }
 
  v.isGen = v.x.type === 'string' || v.y.type === 'string' || v.z.type === 'string'
  return v
};

Vec3.prototype = {
  type: 'vec3',
  emit() { 
    let out = `vec3(`
    let preface = ''

    if( this.x.type === 'string' ) {
      const xout = this.x.emit()
      out += xout.out + ','
    }else{
      out += this.x + ','
    }

    if( this.y.type === 'string' ) {
      const yout = this.y.emit()
      out += yout.out + ',' 
    }else{
      out += this.y + ','
    }
    if( this.z.type === 'string' ) {
      const zout = this.z.emit()
      out += zout.out
    }else{
      out += this.z 
    }

    out += ')'

    return { out, preface }
  },
  emit_decl() { 
    let out = ''
    if( this.x.type === 'string' ) {
      out += this.x.emit_decl()
    } 
    if( this.y.type === 'string' && this.x !== this.y  ) {
      out += this.y.emit_decl()
    } 
    if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
      out += this.z.emit_decl()
    } 
    return out
  },

	update_location(gl, program) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.update_location(gl,program)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.update_location(gl,program)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.update_location(gl,program)
      }      
    }
  },
  
  upload_data(gl) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.upload_data(gl)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.upload_data(gl)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.upload_data(gl)
      }      
    }
  },

  copy() {
    return Vec3( this.x, this.y, this.z )
  }

}

const Vec4 = function (x=0, y, z) {
  const v = Object.create( Vec4.prototype )

  if( y === undefined && z === undefined) {
    v.x = v.y = v.z = x
  }else{
    v.x = x; v.y = y; v.z = z;
  }

  v.isGen = v.x.type === 'string' || v.y.type === 'string' || v.z.type === 'string'

  return v
};

Vec4.prototype = {
  type: 'vec4',
  emit() { 
    let out = `vec4(`
    let preface = ''

    if( this.x.type === 'string' ) {
      const xout = this.x.emit()
      out += xout.out + ','
    }else{
      out += this.x + ','
    }

    if( this.y.type === 'string' ) {
      const yout = this.y.emit()
      out += yout.out + ',' 
    }else{
      out += this.y + ','
    }

    if( this.z.type === 'string' ) {
      const zout = this.z.emit()
      out += zout.out
    }else{
      out += this.z 
    }
    
    if( this.w.type === 'string' ) {
      const wout = this.w.emit()
      out += wout.out
    }else{
      out += this.w 
    }

    out += ')'

    return { out, preface }
  },
  emit_decl() { 
    let out = ''
    if( this.x.type === 'string' ) {
      out += this.x.emit_decl()
    } 
    if( this.y.type === 'string' && this.x !== this.y  ) {
      out += this.y.emit_decl()
    } 
    if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
      out += this.z.emit_decl()
    } 
    if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
      out += this.w.emit_decl()
    }
    return out
  },

	update_location(gl, program) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.update_location(gl,program)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.update_location(gl,program)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.update_location(gl,program)
      }      
      if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
        this.w.update_location(gl,program)
      }  
    }
  },
  
  upload_data(gl) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.upload_data(gl)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.upload_data(gl)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.upload_data(gl)
      } 
      if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
        this.w.upload_data(gl)
      }      
    }
  },

  copy() {
    return Vec4( this.x, this.y, this.z, this.w )
  }
}
// Vec4

//let Vec4 = function (x, y, z, w) {
//  const v = Object.create( Vec4.prototype )
//  v.x = x; v.y = y; v.z = z; v.w = w

//  return v
//};

//Vec4.prototype = {
//  type: 'vec4',
//  emit() { return "vec4(" + this.x + "," + this.y + "," + this.z + "," + this.w + ")"; },
//  emit_decl() { return ""; }
//}





module.exports = { Vec2, Vec3, Vec4 } 

},{}],30:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )

const Vignette = function( Scene, SDF ) {

  const Vgn = function( radius=0.1, smoothness=.1 ) {
    const vgn = Object.create( Vgn.prototype )
    const __radius = param_wrap( radius, float_var_gen( radius ) )  
    
    Object.defineProperty( vgn, 'radius', {
      get() { return __radius },
      set( v ) {
        __radius.set( v )
      }
    })

    const __smoothness = param_wrap( smoothness, float_var_gen( smoothness ) )  
    
    Object.defineProperty( vgn, 'smoothness', {
      get() { return __smoothness },
      set( v ) {
        __smoothness.set( v )
      }
    })
    
    // this refers to the current scene via implicit binding in scene.js
    this.postprocessing.push( vgn )

    return this
  }

  Vgn.prototype = SceneNode()
 
  Object.assign( Vgn.prototype, {
    emit() {
      return `  color *= vignette( v_uv, ${this.radius.emit()}, ${this.smoothness.emit()} );`
    },
   
    emit_decl() {
      let str = this.radius.emit_decl() + this.smoothness.emit_decl()
      // taken from https://gist.github.com/r-lyeh-archived/170b53fcdc0e17afcf15
      // originally iq
      const preface = `  float vignette(vec2 uv, float radius, float smoothness) {
        return radius + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y); 
      }
  `
      if( SDF.memo.vgn === undefined ) {
        str = str + preface
        SDF.memo.vgn = true
      }else{
        str = ''
      }

      return str
    },

    update_location( gl, program ) {
      this.radius.update_location( gl, program )
      this.smoothness.update_location( gl, program )
    },

    upload_data( gl ) {
      this.radius.upload_data( gl )
      this.smoothness.upload_data( gl )
    }
  })

  return Vgn
}

module.exports = Vignette 

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28}],31:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],32:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],33:[function(require,module,exports){

},{}],34:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":31,"ieee754":121}],35:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":124}],36:[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.arrayBlockIndices = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array"
      proc.arrayArgs.push(i)
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":38}],37:[function(require,module,exports){
"use strict"

var uniq = require("uniq")

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr)
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]")
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g")
          ptrStr = ptrStrArr.join("+")
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
  var loopBegin = [], loopEnd = [] // These indices are iterated over
  var loopOrders = [] // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0)
      loopEnd.push(dimension)
      blockBegin.push(dimension)
      blockEnd.push(dimension+proc.arrayBlockIndices[i])
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
      blockBegin.push(0)
      blockEnd.push(proc.arrayBlockIndices[i])
    }
    var newOrder = []
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder)
  }

  //First create arguments for procedure
  var arglist = ["SS"] // SS is the overall shape over which we iterate
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i) // Actual data array
    arglist.push("t"+i) // Strides
    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(loopOrders)
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp

},{"uniq":153}],38:[function(require,module,exports){
"use strict"

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
  var shapeLengthConditions = [], shapeConditions = []
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
    code.push("}")
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":37}],39:[function(require,module,exports){
(function (Buffer){

/**
 * Module exports.
 */

module.exports = dataUriToBuffer;

/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @return {Buffer} Buffer instance from Data URI
 * @api public
 */

function dataUriToBuffer (uri) {
  if (!/^data\:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }

  // strip newlines
  uri = uri.replace(/\r?\n/g, '');

  // split the URI up into the "metadata" and the "data" portions
  var firstComma = uri.indexOf(',');
  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI');

  // remove the "data:" scheme and parse the metadata
  var meta = uri.substring(5, firstComma).split(';');

  var base64 = false;
  var charset = 'US-ASCII';
  for (var i = 0; i < meta.length; i++) {
    if ('base64' == meta[i]) {
      base64 = true;
    } else if (0 == meta[i].indexOf('charset=')) {
      charset = meta[i].substring(8);
    }
  }

  // get the encoded data portion and decode URI-encoded chars
  var data = unescape(uri.substring(firstComma + 1));

  var encoding = base64 ? 'base64' : 'ascii';
  var buffer = new Buffer(data, encoding);

  // set `.type` property to MIME type
  buffer.type = meta[0] || 'text/plain';

  // set the `.charset` property
  buffer.charset = charset;

  return buffer;
}

}).call(this,require("buffer").Buffer)

},{"buffer":34}],40:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],41:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],42:[function(require,module,exports){
(function (Buffer,process){
'use strict'

var path          = require('path')
var ndarray       = require('ndarray')
var GifReader     = require('omggif').GifReader
var pack          = require('ndarray-pack')
var through       = require('through')
var parseDataURI  = require('data-uri-to-buffer')

function defaultImage(url, cb) {
  var img = new Image()
  img.crossOrigin = "Anonymous"
  img.onload = function() {
    var canvas = document.createElement('canvas')
    canvas.width = img.width
    canvas.height = img.height
    var context = canvas.getContext('2d')
    context.drawImage(img, 0, 0)
    var pixels = context.getImageData(0, 0, img.width, img.height)
    cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4*img.width, 1], 0))
  }
  img.onerror = function(err) {
    cb(err)
  }
  img.src = url
}

//Animated gif loading
function handleGif(data, cb) {
  var reader
  try {
    reader = new GifReader(data)
  } catch(err) {
    cb(err)
    return
  }
  if(reader.numFrames() > 0) {
    var nshape = [reader.numFrames(), reader.height, reader.width, 4]
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3])
    var result = ndarray(ndata, nshape)
    try {
      for(var i=0; i<reader.numFrames(); ++i) {
        reader.decodeAndBlitFrameRGBA(i, ndata.subarray(
          result.index(i, 0, 0, 0),
          result.index(i+1, 0, 0, 0)))
      }
    } catch(err) {
      cb(err)
      return
    }
    cb(null, result.transpose(0,2,1))
  } else {
    var nshape = [reader.height, reader.width, 4]
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2])
    var result = ndarray(ndata, nshape)
    try {
      reader.decodeAndBlitFrameRGBA(0, ndata)
    } catch(err) {
      cb(err)
      return
    }
    cb(null, result.transpose(1,0))
  }
}

function httpGif(url, cb) {
  var xhr          = new XMLHttpRequest()
  xhr.open('GET', url, true)
  xhr.responseType = 'arraybuffer'
  if(xhr.overrideMimeType){
    xhr.overrideMimeType('application/binary')
  }
  xhr.onerror = function(err) {
    cb(err)
  }
  xhr.onload = function() {
    if(xhr.readyState !== 4) {
      return
    }
    var data = new Uint8Array(xhr.response)
    handleGif(data, cb)
    return
  }
  xhr.send()
}

function copyBuffer(buffer) {
  if(buffer[0] === undefined) {
    var n = buffer.length
    var result = new Uint8Array(n)
    for(var i=0; i<n; ++i) {
      result[i] = buffer.get(i)
    }
    return result
  } else {
    return new Uint8Array(buffer)
  }
}

function dataGif(url, cb) {
  process.nextTick(function() {
    try {
      var buffer = parseDataURI(url)
      if(buffer) {
        handleGif(copyBuffer(buffer), cb)
      } else {
        cb(new Error('Error parsing data URI'))
      }
    } catch(err) {
      cb(err)
    }
  })
}

module.exports = function getPixels(url, type, cb) {
  if(!cb) {
    cb = type
    type = ''
  }
  var ext = path.extname(url)
  switch(type || ext.toUpperCase()) {
    case '.GIF':
      httpGif(url, cb)
    break
    default:
      if(Buffer.isBuffer(url)) {
        url = 'data:' + type + ';base64,' + url.toString('base64')
      }
      if(url.indexOf('data:image/gif;') === 0) {
        dataGif(url, cb)
      } else {
        defaultImage(url, cb)
      }
  }
}
}).call(this,{"isBuffer":require("../is-buffer/index.js")},require('_process'))

},{"../is-buffer/index.js":124,"_process":133,"data-uri-to-buffer":39,"ndarray":129,"ndarray-pack":127,"omggif":130,"path":131,"through":150}],43:[function(require,module,exports){
module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};
},{}],44:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],45:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],46:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],47:[function(require,module,exports){
module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
},{}],48:[function(require,module,exports){
module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};
},{}],49:[function(require,module,exports){
module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],50:[function(require,module,exports){
module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};
},{}],51:[function(require,module,exports){
module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],52:[function(require,module,exports){
module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}

},{}],53:[function(require,module,exports){
module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],54:[function(require,module,exports){
module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],55:[function(require,module,exports){
module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],56:[function(require,module,exports){
module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};
},{}],57:[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],58:[function(require,module,exports){
module.exports = {
  create: require('./create')
  , clone: require('./clone')
  , copy: require('./copy')
  , identity: require('./identity')
  , transpose: require('./transpose')
  , invert: require('./invert')
  , adjoint: require('./adjoint')
  , determinant: require('./determinant')
  , multiply: require('./multiply')
  , translate: require('./translate')
  , scale: require('./scale')
  , rotate: require('./rotate')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , fromRotation: require('./fromRotation')
  , fromRotationTranslation: require('./fromRotationTranslation')
  , fromScaling: require('./fromScaling')
  , fromTranslation: require('./fromTranslation')
  , fromXRotation: require('./fromXRotation')
  , fromYRotation: require('./fromYRotation')
  , fromZRotation: require('./fromZRotation')
  , fromQuat: require('./fromQuat')
  , frustum: require('./frustum')
  , perspective: require('./perspective')
  , perspectiveFromFieldOfView: require('./perspectiveFromFieldOfView')
  , ortho: require('./ortho')
  , lookAt: require('./lookAt')
  , str: require('./str')
}

},{"./adjoint":43,"./clone":44,"./copy":45,"./create":46,"./determinant":47,"./fromQuat":48,"./fromRotation":49,"./fromRotationTranslation":50,"./fromScaling":51,"./fromTranslation":52,"./fromXRotation":53,"./fromYRotation":54,"./fromZRotation":55,"./frustum":56,"./identity":57,"./invert":59,"./lookAt":60,"./multiply":61,"./ortho":62,"./perspective":63,"./perspectiveFromFieldOfView":64,"./rotate":65,"./rotateX":66,"./rotateY":67,"./rotateZ":68,"./scale":69,"./str":70,"./translate":71,"./transpose":72}],59:[function(require,module,exports){
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
},{}],60:[function(require,module,exports){
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":57}],61:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],62:[function(require,module,exports){
module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};
},{}],63:[function(require,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],64:[function(require,module,exports){
module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}


},{}],65:[function(require,module,exports){
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
},{}],66:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};
},{}],67:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};
},{}],68:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};
},{}],69:[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],70:[function(require,module,exports){
module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};
},{}],71:[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],72:[function(require,module,exports){
module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};
},{}],73:[function(require,module,exports){
'use strict'

var ndarray = require('ndarray')
var ops     = require('ndarray-ops')
var pool    = require('typedarray-pool')

module.exports = createTexture2D

var linearTypes = null
var filterTypes = null
var wrapTypes   = null

function lazyInitLinearTypes(gl) {
  linearTypes = [
    gl.LINEAR,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_NEAREST
  ]
  filterTypes = [
    gl.NEAREST,
    gl.LINEAR,
    gl.NEAREST_MIPMAP_NEAREST,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_LINEAR
  ]
  wrapTypes = [
    gl.REPEAT,
    gl.CLAMP_TO_EDGE,
    gl.MIRRORED_REPEAT
  ]
}

function acceptTextureDOM (obj) {
  return (
    ('undefined' != typeof HTMLCanvasElement && obj instanceof HTMLCanvasElement) ||
    ('undefined' != typeof HTMLImageElement && obj instanceof HTMLImageElement) ||
    ('undefined' != typeof HTMLVideoElement && obj instanceof HTMLVideoElement) ||
    ('undefined' != typeof ImageData && obj instanceof ImageData))
}

var convertFloatToUint8 = function(out, inp) {
  ops.muls(out, inp, 255.0)
}

function reshapeTexture(tex, w, h) {
  var gl = tex.gl
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(w < 0 || w > maxSize || h < 0 || h > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  tex._shape = [w, h]
  tex.bind()
  gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null)
  tex._mipLevels = [0]
  return tex
}

function Texture2D(gl, handle, width, height, format, type) {
  this.gl = gl
  this.handle = handle
  this.format = format
  this.type = type
  this._shape = [width, height]
  this._mipLevels = [0]
  this._magFilter = gl.NEAREST
  this._minFilter = gl.NEAREST
  this._wrapS = gl.CLAMP_TO_EDGE
  this._wrapT = gl.CLAMP_TO_EDGE
  this._anisoSamples = 1

  var parent = this
  var wrapVector = [this._wrapS, this._wrapT]
  Object.defineProperties(wrapVector, [
    {
      get: function() {
        return parent._wrapS
      },
      set: function(v) {
        return parent.wrapS = v
      }
    },
    {
      get: function() {
        return parent._wrapT
      },
      set: function(v) {
        return parent.wrapT = v
      }
    }
  ])
  this._wrapVector = wrapVector

  var shapeVector = [this._shape[0], this._shape[1]]
  Object.defineProperties(shapeVector, [
    {
      get: function() {
        return parent._shape[0]
      },
      set: function(v) {
        return parent.width = v
      }
    },
    {
      get: function() {
        return parent._shape[1]
      },
      set: function(v) {
        return parent.height = v
      }
    }
  ])
  this._shapeVector = shapeVector
}

var proto = Texture2D.prototype

Object.defineProperties(proto, {
  minFilter: {
    get: function() {
      return this._minFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!gl.getExtension('OES_texture_float_linear')) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v)
      return this._minFilter = v
    }
  },
  magFilter: {
    get: function() {
      return this._magFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!gl.getExtension('OES_texture_float_linear')) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v)
      return this._magFilter = v
    }
  },
  mipSamples: {
    get: function() {
      return this._anisoSamples
    },
    set: function(i) {
      var psamples = this._anisoSamples
      this._anisoSamples = Math.max(i, 1)|0
      if(psamples !== this._anisoSamples) {
        var ext = this.gl.getExtension('EXT_texture_filter_anisotropic')
        if(ext) {
          this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples)
        }
      }
      return this._anisoSamples
    }
  },
  wrapS: {
    get: function() {
      return this._wrapS
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v)
      return this._wrapS = v
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v)
      return this._wrapT = v
    }
  },
  wrap: {
    get: function() {
      return this._wrapVector
    },
    set: function(v) {
      if(!Array.isArray(v)) {
        v = [v,v]
      }
      if(v.length !== 2) {
        throw new Error('gl-texture2d: Must specify wrap mode for rows and columns')
      }
      for(var i=0; i<2; ++i) {
        if(wrapTypes.indexOf(v[i]) < 0) {
          throw new Error('gl-texture2d: Unknown wrap mode ' + v)
        }
      }
      this._wrapS = v[0]
      this._wrapT = v[1]

      var gl = this.gl
      this.bind()
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT)

      return v
    }
  },
  shape: {
    get: function() {
      return this._shapeVector
    },
    set: function(x) {
      if(!Array.isArray(x)) {
        x = [x|0,x|0]
      } else {
        if(x.length !== 2) {
          throw new Error('gl-texture2d: Invalid texture shape')
        }
      }
      reshapeTexture(this, x[0]|0, x[1]|0)
      return [x[0]|0, x[1]|0]
    }
  },
  width: {
    get: function() {
      return this._shape[0]
    },
    set: function(w) {
      w = w|0
      reshapeTexture(this, w, this._shape[1])
      return w
    }
  },
  height: {
    get: function() {
      return this._shape[1]
    },
    set: function(h) {
      h = h|0
      reshapeTexture(this, this._shape[0], h)
      return h
    }
  }
})

proto.bind = function(unit) {
  var gl = this.gl
  if(unit !== undefined) {
    gl.activeTexture(gl.TEXTURE0 + (unit|0))
  }
  gl.bindTexture(gl.TEXTURE_2D, this.handle)
  if(unit !== undefined) {
    return (unit|0)
  }
  return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0
}

proto.dispose = function() {
  this.gl.deleteTexture(this.handle)
}

proto.generateMipmap = function() {
  this.bind()
  this.gl.generateMipmap(this.gl.TEXTURE_2D)

  //Update mip levels
  var l = Math.min(this._shape[0], this._shape[1])
  for(var i=0; l>0; ++i, l>>>=1) {
    if(this._mipLevels.indexOf(i) < 0) {
      this._mipLevels.push(i)
    }
  }
}

proto.setPixels = function(data, x_off, y_off, mip_level) {
  var gl = this.gl
  this.bind()
  if(Array.isArray(x_off)) {
    mip_level = y_off
    y_off = x_off[1]|0
    x_off = x_off[0]|0
  } else {
    x_off = x_off || 0
    y_off = y_off || 0
  }
  mip_level = mip_level || 0
  var directData = acceptTextureDOM(data) ? data : data.raw
  if(directData) {
    var needsMip = this._mipLevels.indexOf(mip_level) < 0
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, directData)
      this._mipLevels.push(mip_level)
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, directData)
    }
  } else if(data.shape && data.stride && data.data) {
    if(data.shape.length < 2 ||
       x_off + data.shape[1] > this._shape[1]>>>mip_level ||
       y_off + data.shape[0] > this._shape[0]>>>mip_level ||
       x_off < 0 ||
       y_off < 0) {
      throw new Error('gl-texture2d: Texture dimensions are out of bounds')
    }
    texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data)
  } else {
    throw new Error('gl-texture2d: Unsupported data type')
  }
}


function isPacked(shape, stride) {
  if(shape.length === 3) {
    return  (stride[2] === 1) &&
            (stride[1] === shape[0]*shape[2]) &&
            (stride[0] === shape[2])
  }
  return  (stride[0] === 1) &&
          (stride[1] === shape[0])
}

function texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  if(shape.length < 2 || shape.length > 3) {
    throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d')
  }
  var type = 0, format = 0
  var packed = isPacked(shape, array.stride.slice())
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var channels = 1
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
    channels = shape[2]
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  //For 1-channel textures allow conversion between formats
  if((format  === gl.LUMINANCE || format  === gl.ALPHA) &&
     (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {
    format = cformat
  }
  if(format !== cformat) {
    throw new Error('gl-texture2d: Incompatible texture format for setPixels')
  }
  var size = array.size
  var needsMip = mipLevels.indexOf(mip_level) < 0
  if(needsMip) {
    mipLevels.push(mip_level)
  }
  if(type === ctype && packed) {
    //Array data types are compatible, can directly copy into texture
    if(array.offset === 0 && array.data.length === size) {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data)
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data)
      }
    } else {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      }
    }
  } else {
    //Need to do type conversion to pack data into buffer
    var pack_buffer
    if(ctype === gl.FLOAT) {
      pack_buffer = pool.mallocFloat32(size)
    } else {
      pack_buffer = pool.mallocUint8(size)
    }
    var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2]*shape[0], 1])
    if(type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(pack_view, array)
    } else {
      ops.assign(pack_view, array)
    }
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size))
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size))
    }
    if(ctype === gl.FLOAT) {
      pool.freeFloat32(pack_buffer)
    } else {
      pool.freeUint8(pack_buffer)
    }
  }
}

function initTexture(gl) {
  var tex = gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D, tex)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  return tex
}

function createTextureShape(gl, width, height, format, type) {
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(width < 0 || width > maxTextureSize || height < 0 || height  > maxTextureSize) {
    throw new Error('gl-texture2d: Invalid texture shape')
  }
  if(type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {
    throw new Error('gl-texture2d: Floating point textures not supported on this platform')
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null)
  return new Texture2D(gl, tex, width, height, format, type)
}

function createTextureDOM(gl, directData, width, height, format, type) {
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, directData)
  return new Texture2D(gl, tex, width, height, format, type)
}

//Creates a texture from an ndarray
function createTextureArray(gl, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  var packed = isPacked(shape, array.stride.slice())
  var type = 0
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var format = 0
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  if(type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {
    type = gl.UNSIGNED_BYTE
    packed = false
  }
  var buffer, buf_store
  var size = array.size
  if(!packed) {
    var stride = [shape[2], shape[2]*shape[0], 1]
    buf_store = pool.malloc(size, dtype)
    var buf_array = ndarray(buf_store, shape, stride, 0)
    if((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(buf_array, array)
    } else {
      ops.assign(buf_array, array)
    }
    buffer = buf_store.subarray(0, size)
  } else if (array.offset === 0 && array.data.length === size) {
    buffer = array.data
  } else {
    buffer = array.data.subarray(array.offset, array.offset + size)
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer)
  if(!packed) {
    pool.free(buf_store)
  }
  return new Texture2D(gl, tex, shape[0], shape[1], format, type)
}

function createTexture2D(gl) {
  if(arguments.length <= 1) {
    throw new Error('gl-texture2d: Missing arguments for texture2d constructor')
  }
  if(!linearTypes) {
    lazyInitLinearTypes(gl)
  }
  if(typeof arguments[1] === 'number') {
    return createTextureShape(gl, arguments[1], arguments[2], arguments[3]||gl.RGBA, arguments[4]||gl.UNSIGNED_BYTE)
  }
  if(Array.isArray(arguments[1])) {
    return createTextureShape(gl, arguments[1][0]|0, arguments[1][1]|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
  }
  if(typeof arguments[1] === 'object') {
    var obj = arguments[1]
    var directData = acceptTextureDOM(obj) ? obj : obj.raw
    if (directData) {
      return createTextureDOM(gl, directData, obj.width|0, obj.height|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
    } else if(obj.shape && obj.data && obj.stride) {
      return createTextureArray(gl, obj)
    }
  }
  throw new Error('gl-texture2d: Invalid arguments for texture2d constructor')
}

},{"ndarray":129,"ndarray-ops":126,"typedarray-pool":152}],74:[function(require,module,exports){
module.exports = add;

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
    out[0] = a[0] + b[0]
    out[1] = a[1] + b[1]
    out[2] = a[2] + b[2]
    return out
}
},{}],75:[function(require,module,exports){
module.exports = angle

var fromValues = require('./fromValues')
var normalize = require('./normalize')
var dot = require('./dot')

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2])
    var tempB = fromValues(b[0], b[1], b[2])
 
    normalize(tempA, tempA)
    normalize(tempB, tempB)
 
    var cosine = dot(tempA, tempB)

    if(cosine > 1.0){
        return 0
    } else {
        return Math.acos(cosine)
    }     
}

},{"./dot":85,"./fromValues":91,"./normalize":102}],76:[function(require,module,exports){
module.exports = ceil

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0])
  out[1] = Math.ceil(a[1])
  out[2] = Math.ceil(a[2])
  return out
}

},{}],77:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
    var out = new Float32Array(3)
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}
},{}],78:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}
},{}],79:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
    var out = new Float32Array(3)
    out[0] = 0
    out[1] = 0
    out[2] = 0
    return out
}
},{}],80:[function(require,module,exports){
module.exports = cross;

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2]

    out[0] = ay * bz - az * by
    out[1] = az * bx - ax * bz
    out[2] = ax * by - ay * bx
    return out
}
},{}],81:[function(require,module,exports){
module.exports = require('./distance')

},{"./distance":82}],82:[function(require,module,exports){
module.exports = distance;

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return Math.sqrt(x*x + y*y + z*z)
}
},{}],83:[function(require,module,exports){
module.exports = require('./divide')

},{"./divide":84}],84:[function(require,module,exports){
module.exports = divide;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
    out[0] = a[0] / b[0]
    out[1] = a[1] / b[1]
    out[2] = a[2] / b[2]
    return out
}
},{}],85:[function(require,module,exports){
module.exports = dot;

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}
},{}],86:[function(require,module,exports){
module.exports = 0.000001

},{}],87:[function(require,module,exports){
module.exports = equals

var EPSILON = require('./epsilon')

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0]
  var a1 = a[1]
  var a2 = a[2]
  var b0 = b[0]
  var b1 = b[1]
  var b2 = b[2]
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))
}

},{"./epsilon":86}],88:[function(require,module,exports){
module.exports = exactEquals

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
}

},{}],89:[function(require,module,exports){
module.exports = floor

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0])
  out[1] = Math.floor(a[1])
  out[2] = Math.floor(a[2])
  return out
}

},{}],90:[function(require,module,exports){
module.exports = forEach;

var vec = require('./create')()

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
function forEach(a, stride, offset, count, fn, arg) {
        var i, l
        if(!stride) {
            stride = 3
        }

        if(!offset) {
            offset = 0
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length)
        } else {
            l = a.length
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i] 
            vec[1] = a[i+1] 
            vec[2] = a[i+2]
            fn(vec, vec, arg)
            a[i] = vec[0] 
            a[i+1] = vec[1] 
            a[i+2] = vec[2]
        }
        
        return a
}
},{"./create":79}],91:[function(require,module,exports){
module.exports = fromValues;

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
    var out = new Float32Array(3)
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],92:[function(require,module,exports){
module.exports = {
  EPSILON: require('./epsilon')
  , create: require('./create')
  , clone: require('./clone')
  , angle: require('./angle')
  , fromValues: require('./fromValues')
  , copy: require('./copy')
  , set: require('./set')
  , equals: require('./equals')
  , exactEquals: require('./exactEquals')
  , add: require('./add')
  , subtract: require('./subtract')
  , sub: require('./sub')
  , multiply: require('./multiply')
  , mul: require('./mul')
  , divide: require('./divide')
  , div: require('./div')
  , min: require('./min')
  , max: require('./max')
  , floor: require('./floor')
  , ceil: require('./ceil')
  , round: require('./round')
  , scale: require('./scale')
  , scaleAndAdd: require('./scaleAndAdd')
  , distance: require('./distance')
  , dist: require('./dist')
  , squaredDistance: require('./squaredDistance')
  , sqrDist: require('./sqrDist')
  , length: require('./length')
  , len: require('./len')
  , squaredLength: require('./squaredLength')
  , sqrLen: require('./sqrLen')
  , negate: require('./negate')
  , inverse: require('./inverse')
  , normalize: require('./normalize')
  , dot: require('./dot')
  , cross: require('./cross')
  , lerp: require('./lerp')
  , random: require('./random')
  , transformMat4: require('./transformMat4')
  , transformMat3: require('./transformMat3')
  , transformQuat: require('./transformQuat')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , forEach: require('./forEach')
}

},{"./add":74,"./angle":75,"./ceil":76,"./clone":77,"./copy":78,"./create":79,"./cross":80,"./dist":81,"./distance":82,"./div":83,"./divide":84,"./dot":85,"./epsilon":86,"./equals":87,"./exactEquals":88,"./floor":89,"./forEach":90,"./fromValues":91,"./inverse":93,"./len":94,"./length":95,"./lerp":96,"./max":97,"./min":98,"./mul":99,"./multiply":100,"./negate":101,"./normalize":102,"./random":103,"./rotateX":104,"./rotateY":105,"./rotateZ":106,"./round":107,"./scale":108,"./scaleAndAdd":109,"./set":110,"./sqrDist":111,"./sqrLen":112,"./squaredDistance":113,"./squaredLength":114,"./sub":115,"./subtract":116,"./transformMat3":117,"./transformMat4":118,"./transformQuat":119}],93:[function(require,module,exports){
module.exports = inverse;

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0]
  out[1] = 1.0 / a[1]
  out[2] = 1.0 / a[2]
  return out
}
},{}],94:[function(require,module,exports){
module.exports = require('./length')

},{"./length":95}],95:[function(require,module,exports){
module.exports = length;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return Math.sqrt(x*x + y*y + z*z)
}
},{}],96:[function(require,module,exports){
module.exports = lerp;

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2]
    out[0] = ax + t * (b[0] - ax)
    out[1] = ay + t * (b[1] - ay)
    out[2] = az + t * (b[2] - az)
    return out
}
},{}],97:[function(require,module,exports){
module.exports = max;

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0])
    out[1] = Math.max(a[1], b[1])
    out[2] = Math.max(a[2], b[2])
    return out
}
},{}],98:[function(require,module,exports){
module.exports = min;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0])
    out[1] = Math.min(a[1], b[1])
    out[2] = Math.min(a[2], b[2])
    return out
}
},{}],99:[function(require,module,exports){
module.exports = require('./multiply')

},{"./multiply":100}],100:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
    out[0] = a[0] * b[0]
    out[1] = a[1] * b[1]
    out[2] = a[2] * b[2]
    return out
}
},{}],101:[function(require,module,exports){
module.exports = negate;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
    out[0] = -a[0]
    out[1] = -a[1]
    out[2] = -a[2]
    return out
}
},{}],102:[function(require,module,exports){
module.exports = normalize;

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    var len = x*x + y*y + z*z
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len)
        out[0] = a[0] * len
        out[1] = a[1] * len
        out[2] = a[2] * len
    }
    return out
}
},{}],103:[function(require,module,exports){
module.exports = random;

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
    scale = scale || 1.0

    var r = Math.random() * 2.0 * Math.PI
    var z = (Math.random() * 2.0) - 1.0
    var zScale = Math.sqrt(1.0-z*z) * scale

    out[0] = Math.cos(r) * zScale
    out[1] = Math.sin(r) * zScale
    out[2] = z * scale
    return out
}
},{}],104:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
    var by = b[1]
    var bz = b[2]

    // Translate point to the origin
    var py = a[1] - by
    var pz = a[2] - bz

    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = a[0]
    out[1] = by + py * cc - pz * sc
    out[2] = bz + py * sc + pz * cc

    return out
}

},{}],105:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
    var bx = b[0]
    var bz = b[2]

    // translate point to the origin
    var px = a[0] - bx
    var pz = a[2] - bz
    
    var sc = Math.sin(c)
    var cc = Math.cos(c)
  
    // perform rotation and translate to correct position
    out[0] = bx + pz * sc + px * cc
    out[1] = a[1]
    out[2] = bz + pz * cc - px * sc
  
    return out
}

},{}],106:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
    var bx = b[0]
    var by = b[1]

    //Translate point to the origin
    var px = a[0] - bx
    var py = a[1] - by
  
    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = bx + px * cc - py * sc
    out[1] = by + px * sc + py * cc
    out[2] = a[2]
  
    return out
}

},{}],107:[function(require,module,exports){
module.exports = round

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0])
  out[1] = Math.round(a[1])
  out[2] = Math.round(a[2])
  return out
}

},{}],108:[function(require,module,exports){
module.exports = scale;

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b
    out[1] = a[1] * b
    out[2] = a[2] * b
    return out
}
},{}],109:[function(require,module,exports){
module.exports = scaleAndAdd;

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale)
    out[1] = a[1] + (b[1] * scale)
    out[2] = a[2] + (b[2] * scale)
    return out
}
},{}],110:[function(require,module,exports){
module.exports = set;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],111:[function(require,module,exports){
module.exports = require('./squaredDistance')

},{"./squaredDistance":113}],112:[function(require,module,exports){
module.exports = require('./squaredLength')

},{"./squaredLength":114}],113:[function(require,module,exports){
module.exports = squaredDistance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return x*x + y*y + z*z
}
},{}],114:[function(require,module,exports){
module.exports = squaredLength;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return x*x + y*y + z*z
}
},{}],115:[function(require,module,exports){
module.exports = require('./subtract')

},{"./subtract":116}],116:[function(require,module,exports){
module.exports = subtract;

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
    out[0] = a[0] - b[0]
    out[1] = a[1] - b[1]
    out[2] = a[2] - b[2]
    return out
}
},{}],117:[function(require,module,exports){
module.exports = transformMat3;

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2]
    out[0] = x * m[0] + y * m[3] + z * m[6]
    out[1] = x * m[1] + y * m[4] + z * m[7]
    out[2] = x * m[2] + y * m[5] + z * m[8]
    return out
}
},{}],118:[function(require,module,exports){
module.exports = transformMat4;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15]
    w = w || 1.0
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
    return out
}
},{}],119:[function(require,module,exports){
module.exports = transformQuat;

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
    return out
}
},{}],120:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],121:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],122:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],123:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],124:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],125:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],126:[function(require,module,exports){
"use strict"

var compile = require("cwise-compiler")

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})



},{"cwise-compiler":36}],127:[function(require,module,exports){
"use strict"

var ndarray = require("ndarray")
var do_convert = require("./doConvert.js")

module.exports = function convert(arr, result) {
  var shape = [], c = arr, sz = 1
  while(Array.isArray(c)) {
    shape.push(c.length)
    sz *= c.length
    c = c[0]
  }
  if(shape.length === 0) {
    return ndarray()
  }
  if(!result) {
    result = ndarray(new Float64Array(sz), shape)
  }
  do_convert(result, arr)
  return result
}

},{"./doConvert.js":128,"ndarray":129}],128:[function(require,module,exports){
module.exports=require('cwise-compiler')({"args":["array","scalar","index"],"pre":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"body":{"body":"{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}","args":[{"name":"_inline_1_arg0_","lvalue":true,"rvalue":false,"count":1},{"name":"_inline_1_arg1_","lvalue":false,"rvalue":true,"count":1},{"name":"_inline_1_arg2_","lvalue":false,"rvalue":true,"count":4}],"thisVars":[],"localVars":["_inline_1_i","_inline_1_v"]},"post":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"funcName":"convert","blockSize":64})

},{"cwise-compiler":36}],129:[function(require,module,exports){
var iota = require("iota-array")
var isBuffer = require("is-buffer")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor

},{"iota-array":123,"is-buffer":124}],130:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.

"use strict";

function GifWriter(buf, width, height, gopts) {
  var p = 0;

  var gopts = gopts === undefined ? { } : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;

  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
    throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;
    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {
      throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256.");
    }
    return num_colors;
  }

  // - Header.
  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

  // Handling of Global Color Table (palette) and background index.
  var gp_num_colors_pow2 = 0;
  var background = 0;
  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);
    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;
    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors)
        throw new Error("Background index out of range.");
      // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).
      if (background === 0)
        throw new Error("Background index explicitly passed as 0.");
    }
  }

  // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
  // NOTE: Indicates 0-bpp original color resolution (unused?).
  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
  buf[p++] = background;  // Background Color Index.
  buf[p++] = 0;  // Pixel aspect ratio (unused?).

  // - Global Color Table
  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {  // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535)
      throw new Error("Loop count invalid.")
    // Extension code, label, and length.
    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
    // NETSCAPE2.0
    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
    // Sub-block
    buf[p++] = 0x03; buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00;  // Terminator.
  }


  var ended = false;

  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
    if (ended === true) { --p; ended = false; }  // Un-end.

    opts = opts === undefined ? { } : opts;

    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?
    if (x < 0 || y < 0 || x > 65535 || y > 65535)
      throw new Error("x/y invalid.")

    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
      throw new Error("Width/Height invalid.")

    if (indexed_pixels.length < w * h)
      throw new Error("Not enough pixels for the frame size.");

    var using_local_palette = true;
    var palette = opts.palette;
    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null)
      throw new Error("Must supply either a local or global palette.");

    var num_colors = check_palette_and_num_colors(palette);

    // Compute the min_code_size (power of 2), destroying num_colors.
    var min_code_size = 0;
    while (num_colors >>= 1) ++min_code_size;
    num_colors = 1 << min_code_size;  // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay;

    // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.
    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
      throw new Error("Disposal out of range.");

    var use_transparency = false;
    var transparent_index = 0;
    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors)
        throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
      buf[p++] = 4;  // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index;  // Transparent color index.
      buf[p++] = 0;  // Block Terminator.
    }

    // - Image Descriptor
    buf[p++] = 0x2c;  // Image Seperator.
    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
    // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.
    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

    // - Local Color Table
    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(
            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);

    return p;
  };

  this.end = function() {
    if (ended === false) {
      buf[p++] = 0x3b;  // Trailer.
      ended = true;
    }
    return p;
  };

  this.getOutputBuffer = function() { return buf; };
  this.setOutputBuffer = function(v) { buf = v; };
  this.getOutputBufferPosition = function() { return p; };
  this.setOutputBufferPosition = function(v) { p = v; };
}

// Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.
function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++;  // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  var cur_shift = 0;
  // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).
  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8; cur_shift -= 8;
      if (p === cur_subblock + 256) {  // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  }

  // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.

  // Output code for the current contents of the index buffer.
  var ib_code = index_stream[0] & code_mask;  // Load first input index.
  var code_table = { };  // Key'd on our 20-bit "tuple".

  emit_code(clear_code);  // Spec says first code should be a clear code.

  // First index already loaded, process the rest of the stream.
  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
    var cur_code = code_table[cur_key];  // buffer + k.

    // Check if we have to create a new code table entry.
    if (cur_code === undefined) {  // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;
      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8; cur_shift -= 8;
        if (p === cur_subblock + 256) {  // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {  // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = { };
      } else {  // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= (1 << cur_code_size)) ++cur_code_size;
        code_table[cur_key] = next_code++;  // Insert into code table.
      }

      ib_code = k;  // Index buffer to single input k.
    } else {
      ib_code = cur_code;  // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code);  // There will still be something in the index buffer.
  emit_code(eoi_code);  // End Of Information.

  // Flush / finalize the sub-blocks stream to the buffer.
  emit_bytes_to_buffer(1);

  // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.
  if (cur_subblock + 1 === p) {  // Started but unused.
    buf[cur_subblock] = 0;
  } else {  // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }
  return p;
}

function GifReader(buf) {
  var p = 0;

  // - Header (GIF87a or GIF89a).
  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  }

  // - Logical Screen Descriptor.
  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++];  // <Packed Fields>.
  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << (num_global_colors_pow2 + 1);
  var background = buf[p++];
  buf[p++];  // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size   = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3;  // Seek past palette.
  }

  var no_eof = true;

  var frames = [ ];

  var delay = 0;
  var transparent_index = null;
  var disposal = 0;  // 0 - No disposal specified.
  var loop_count = null;

  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:  // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:  // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
                // NETSCAPE2.0
                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
                // Sub-block
                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++;  // Skip terminator.
            } else {  // We don't know what it is, just try to get past it.
              p += 12;
              while (true) {  // Seek through subblocks.
                var block_size = buf[p++];
                // Bad block size (ex: undefined from an out of bounds read).
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;  // 0 size is terminator
                p += block_size;
              }
            }
            break;

          case 0xf9:  // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p+4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++;  // Skip terminator.
            break;

          case 0xfe:  // Comment Extension.
            while (true) {  // Seek through subblocks.
              var block_size = buf[p++];
              // Bad block size (ex: undefined from an out of bounds read).
              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break;  // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));
              p += block_size;
            }
            break;

          default:
            throw new Error(
                "Unknown graphic control label: 0x" + buf[p-1].toString(16));
        }
        break;

      case 0x2c:  // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << (num_local_colors_pow2 + 1);
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;
        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p;  // Override with local palette.
          palette_size = num_local_colors;
          p += num_local_colors * 3;  // Seek past palette.
        }

        var data_offset = p;

        p++;  // codesize
        while (true) {
          var block_size = buf[p++];
          // Bad block size (ex: undefined from an out of bounds read).
          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break;  // 0 size is terminator
          p += block_size;
        }

        frames.push({x: x, y: y, width: w, height: h,
                     has_local_palette: has_local_palette,
                     palette_offset: palette_offset,
                     palette_size: palette_size,
                     data_offset: data_offset,
                     data_length: p - data_offset,
                     transparent_index: transparent_index,
                     interlaced: !!interlace_flag,
                     delay: delay,
                     disposal: disposal});
        break;

      case 0x3b:  // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));
        break;
    }
  }

  this.numFrames = function() {
    return frames.length;
  };

  this.loopCount = function() {
    return loop_count;
  };

  this.frameInfo = function(frame_num) {
    if (frame_num < 0 || frame_num >= frames.length)
      throw new Error("Frame index out of range.");
    return frames[frame_num];
  }

  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };

  // I will go to copy and paste hell one day...
  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];

  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.
  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;

  var op = 0;  // Output pointer.

  var subblock_size = code_stream[p++];

  // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);
  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

  var prev_code = null;  // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break;  // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++];  // Next subblock.
      } else {
        --subblock_size;
      }
    }

    // TODO(deanm): We should never really get here, we should have received
    // and EOI.
    if (cur_shift < cur_code_size)
      break;

    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size;

    // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.
    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.

      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1;

      // Don't update prev_code ?
      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    }

    // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.

    var chase_code = code < next_code ? code : prev_code;

    // Chase what we will output, either {CODE} or {CODE-1}.
    var chase_length = 0;
    var chase = chase_code;
    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;

    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    }

    // Already have the first byte from the chase, might as well write it fast.
    output[op++] = k;

    op += chase_length;
    var b = op;  // Track pointer, writing backwards.

    if (chase_code !== code)  // The case of emitting {CODE-1} + k.
      output[op++] = k;

    chase = chase_code;
    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff;  // Write backwards.
      chase >>= 8;  // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k;
      // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).
      if (next_code >= code_mask+1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
}

// CommonJS.
try { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) {}

},{}],131:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":133}],132:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))

},{"_process":133}],133:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],134:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":135}],135:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":137,"./_stream_writable":139,"core-util-is":35,"inherits":122,"process-nextick-args":132}],136:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":138,"core-util-is":35,"inherits":122}],137:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":135,"./internal/streams/BufferList":140,"./internal/streams/destroy":141,"./internal/streams/stream":142,"_process":133,"core-util-is":35,"events":41,"inherits":122,"isarray":125,"process-nextick-args":132,"safe-buffer":148,"string_decoder/":143,"util":33}],138:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":135,"core-util-is":35,"inherits":122}],139:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":135,"./internal/streams/destroy":141,"./internal/streams/stream":142,"_process":133,"core-util-is":35,"inherits":122,"process-nextick-args":132,"safe-buffer":148,"timers":151,"util-deprecate":154}],140:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":148,"util":33}],141:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":132}],142:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":41}],143:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":148}],144:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":145}],145:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":135,"./lib/_stream_passthrough.js":136,"./lib/_stream_readable.js":137,"./lib/_stream_transform.js":138,"./lib/_stream_writable.js":139}],146:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":145}],147:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":139}],148:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":34}],149:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":41,"inherits":122,"readable-stream/duplex.js":134,"readable-stream/passthrough.js":144,"readable-stream/readable.js":145,"readable-stream/transform.js":146,"readable-stream/writable.js":147}],150:[function(require,module,exports){
(function (process){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,require('_process'))

},{"_process":133,"stream":149}],151:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":133,"timers":151}],152:[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"bit-twiddle":32,"buffer":34,"dup":40}],153:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],154:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[12])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9hbHRlcmF0aW9ucy5qcyIsImpzL2F1ZGlvLmpzIiwianMvYmFja2dyb3VuZC5qcyIsImpzL2NhbWVyYS5qcyIsImpzL2Rpc3RhbmNlRGVmb3JtYXRpb25zLmpzIiwianMvZGlzdGFuY2VPcGVyYXRpb25zLmpzIiwianMvZGlzdGFuY2VPcGVyYXRpb25zR0xTTC5qcyIsImpzL2RvbWFpbk9wZXJhdGlvbnMuanMiLCJqcy9leHRlcm5hbC9tYXRyaXguanMiLCJqcy9mbG9hdC5qcyIsImpzL2ZvZy5qcyIsImpzL2luZGV4LmpzIiwianMvaW50LmpzIiwianMvbGlnaHRpbmcuanMiLCJqcy9tYWluLmpzIiwianMvbWF0ZXJpYWwuanMiLCJqcy9ub2lzZS5qcyIsImpzL3ByaW1pdGl2ZURlc2NyaXB0aW9ucy5qcyIsImpzL3ByaW1pdGl2ZXMuanMiLCJqcy9yZW5kZXJGcmFnbWVudFNoYWRlci5qcyIsImpzL3NjZW5lLmpzIiwianMvc2NlbmVOb2RlLmpzIiwianMvdGV4dHVyZS5qcyIsImpzL3RleHR1cmVEZXNjcmlwdGlvbnMuanMiLCJqcy90ZXh0dXJlV3JhcC5qcyIsImpzL3RyYW5zZm9ybS5qcyIsImpzL3V0aWxzLmpzIiwianMvdmFyLmpzIiwianMvdmVjLmpzIiwianMvdmlnbmV0dGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwibm9kZV9tb2R1bGVzL2RhdGEtdXJpLXRvLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZ2V0LXBpeGVscy9kb20tcGl4ZWxzLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvYWRqb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2RldGVybWluYW50LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVF1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb25UcmFuc2xhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21TY2FsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVRyYW5zbGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVhSb3RhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21ZUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tWlJvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJ1c3R1bS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9sb29rQXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L29ydGhvLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcGVyc3BlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZVguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9yb3RhdGVZLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcm90YXRlWi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvc3RyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNwb3NlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC90ZXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvYW5nbGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9jZWlsLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9jb3B5LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY3Jvc3MuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZGlzdGFuY2UuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXYuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXZpZGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZXhhY3RFcXVhbHMuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9mbG9vci5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9pbnZlcnNlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVycC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL21heC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL21pbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL211bC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL211bHRpcGx5LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbmVnYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbm9ybWFsaXplLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVkuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVaLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcm91bmQuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlQW5kQWRkLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyRGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3Nxckxlbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWRMZW5ndGguanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zdWIuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zdWJ0cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDMuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1NYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtUXVhdC5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9uZGFycmF5LW9wcy5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svZG9Db252ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9vbWdnaWYvb21nZ2lmLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL3VuaXEvdW5pcS5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDampCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4gfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuXG5jb25zdCBvcHMgPSB7IFxuICBPbmlvbjoge1xuICAgIGZ1bmMoIHNkZix0aGlja25lc3MgKSB7IHJldHVybiBgdmVjMiggb3BPbmlvbiggJHtzZGZ9LngsICR7dGhpY2tuZXNzfSApLCAke3NkZn0ueSApYCB9LFxuICAgIHZhcmlhYmxlczpbWyd0aGlja25lc3MnLCAnZmxvYXQnLCAuMDNdXVxuICB9LFxuICBIYWx2ZToge1xuICAgIGZ1bmMoIHNkZiwgZGlyZWN0aW9uICkgeyByZXR1cm4gYHZlYzIoIG9wSGFsdmUoICR7c2RmfS54LCBwLCAke2RpcmVjdGlvbn0gKSwgJHtzZGZ9LnkgKWAgfSxcbiAgICB2YXJpYWJsZXM6W1snZGlyZWN0aW9uJywnaW50JywwXV1cbiAgfSxcbiAgUm91bmQ6IHtcbiAgICBmdW5jKCBzZGYsIGFtb3VudCApIHsgcmV0dXJuIGB2ZWMyKCAke3NkZn0ueCAtICR7YW1vdW50fSwgJHtzZGZ9LnkgKWAgfSxcbiAgICB2YXJpYWJsZXM6W1snYW1vdW50JywnZmxvYXQnLC4xXV1cbiAgfVxufVxuXG5cbmNvbnN0IEFsdGVyYXRpb25zPSB7fVxuXG5mb3IoIGxldCBuYW1lIGluIG9wcyApIHtcblxuICAvLyBnZXQgY29kZWdlbiBmdW5jdGlvblxuICBsZXQgb3AgPSBvcHNbIG5hbWUgXVxuXG4gIC8vIGNyZWF0ZSBjb25zdHJ1Y3RvclxuICBBbHRlcmF0aW9uc1sgbmFtZSBdID0gZnVuY3Rpb24oIHNkZiwgLi4uYXJncyApIHtcbiAgICBjb25zdCBfX29wID0gT2JqZWN0LmNyZWF0ZSggQWx0ZXJhdGlvbnNbIG5hbWUgXS5wcm90b3R5cGUgKVxuICAgIF9fb3Auc2RmID0gc2RmXG4gICAgX19vcC52YXJpYWJsZXMgPSBbXVxuICAgIF9fb3AuX19kZXNjID0geyBwYXJhbWV0ZXJzOltdIH1cblxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgb3AudmFyaWFibGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgY29uc3QgcHJvcEFycmF5ID0gb3AudmFyaWFibGVzWyBpIF1cbiAgICAgIGNvbnN0IHByb3BOYW1lID0gcHJvcEFycmF5WyAwIF1cbiAgICAgIGNvbnN0IHByb3BUeXBlID0gcHJvcEFycmF5WyAxIF1cbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IGFyZ3NbIGkgXSA9PT0gdW5kZWZpbmVkID8gcHJvcEFycmF5WyAyIF0gOiBhcmdzWyBpIF1cblxuICAgICAgX19vcC5fX2Rlc2MucGFyYW1ldGVycy5wdXNoKHsgbmFtZTpwcm9wTmFtZSwgdmFsdWU6cHJvcFZhbHVlIH0pXG4gICAgICBsZXQgcGFyYW1cblxuICAgICAgc3dpdGNoKCBwcm9wVHlwZSApIHtcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICBwYXJhbSA9IGludF92YXJfZ2VuKCBwcm9wVmFsdWUgKSgpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGFyYW0gPSBmbG9hdF92YXJfZ2VuKCBwcm9wVmFsdWUgKSgpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggX19vcCwgcHJvcE5hbWUsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gcGFyYW0gfSxcbiAgICAgICAgc2V0KHYpIHsgcGFyYW0uc2V0KCB2ICkgfVxuICAgICAgfSlcblxuICAgICAgX19vcC52YXJpYWJsZXMucHVzaCggcGFyYW0gKVxuICAgIH1cbiAgICAgIFxuICAgIF9fb3AubWF0SWQgPSBNYXRlcmlhbElELmFsbG9jKClcblxuICAgIHJldHVybiBfX29wXG4gIH0gXG5cbiAgQWx0ZXJhdGlvbnNbIG5hbWUgXS5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuXG4gIEFsdGVyYXRpb25zWyBuYW1lIF0ucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoIF9fbmFtZSApIHtcbiAgICBjb25zdCBlbWl0dGVyQSA9IHRoaXMuc2RmLmVtaXQoIF9fbmFtZSApXG4gICAgLy9jb25zdCBlbWl0dGVyQiA9IHRoaXMuYi5lbWl0KClcblxuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIG91dDogb3AuZnVuYyggZW1pdHRlckEub3V0LCAuLi50aGlzLnZhcmlhYmxlcy5tYXAoIHYgPT4gdi5lbWl0KCkgKSApLCBcbiAgICAgIHByZWZhY2U6IChlbWl0dGVyQS5wcmVmYWNlIHx8ICcnKSBcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cblxuICBBbHRlcmF0aW9uc1tuYW1lXS5wcm90b3R5cGUuZW1pdF9kZWNsID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBzdHIgPSAgdGhpcy5zZGYuZW1pdF9kZWNsKCkgXG4gICAgZm9yKCBsZXQgdiBvZiB0aGlzLnZhcmlhYmxlcyApIHtcbiAgICAgIHN0ciArPSB2LmVtaXRfZGVjbCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0clxuICB9O1xuXG4gIEFsdGVyYXRpb25zW25hbWVdLnByb3RvdHlwZS51cGRhdGVfbG9jYXRpb24gPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIHRoaXMuc2RmLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIGZvciggbGV0IHYgb2YgdGhpcy52YXJpYWJsZXMgKSB2LnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICB9XG5cbiAgQWx0ZXJhdGlvbnNbbmFtZV0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLnNkZi51cGxvYWRfZGF0YSggZ2wgKVxuICAgIGZvciggbGV0IHYgb2YgdGhpcy52YXJpYWJsZXMgKSB2LnVwbG9hZF9kYXRhKCBnbCApXG4gICAgXG4gIH1cbn1cblxuQWx0ZXJhdGlvbnMuSGFsdmUuVVAgPSAwXG5BbHRlcmF0aW9ucy5IYWx2ZS5ET1dOID0gMVxuQWx0ZXJhdGlvbnMuSGFsdmUuTEVGVCA9IDNcbkFsdGVyYXRpb25zLkhhbHZlLlJJR0hUID0gMlxuXG5tb2R1bGUuZXhwb3J0cyA9IEFsdGVyYXRpb25zXG4iLCJjb25zdCBBdWRpbyA9IHtcbiAgX19oYXNJbnB1dDogZmFsc2UsXG4gIGN0eDogbnVsbCxcblxuICBzdGFydCgpIHtcbiAgICBpZiggQXVkaW8uX19oYXNJbnB1dCA9PT0gZmFsc2UgKSB7XG4gICAgICBBdWRpby5jdHggPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICAgIEF1ZGlvLmNyZWF0ZUlucHV0KCkudGhlbiggaW5wdXQgPT4ge1xuICAgICAgICBBdWRpby5jcmVhdGVGRlQoKVxuICAgICAgICBpbnB1dC5jb25uZWN0KCBBdWRpby5GRlQgKVxuXG4gICAgICAgIEF1ZGlvLmludGVydmFsID0gc2V0SW50ZXJ2YWwoIEF1ZGlvLmZmdENhbGxiYWNrLCAxMDAwLzYwIClcbiAgICAgICAgLy93aW5kb3cuRkZUID0gQXVkaW8uRkZUXG4gICAgICB9KVxuICAgIH1cbiAgICBBdWRpby5fX2hhc0lucHV0ID0gdHJ1ZVxuICB9LFxuXG4gIGNyZWF0ZUlucHV0KCkge1xuICAgIGNvbnNvbGUubG9nKCAnY29ubmVjdGluZyBhdWRpbyBpbnB1dC4uLicgKVxuICAgIFxuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyggJ3N0YXJ0PycgKVxuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzp0cnVlLCB2aWRlbzpmYWxzZSB9KVxuICAgICAgICAudGhlbiggc3RyZWFtID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyggJ2F1ZGlvIGlucHV0IGNvbm5lY3RlZCcgKVxuICAgICAgICAgIEF1ZGlvLmlucHV0ID0gQXVkaW8uY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKCBzdHJlYW0gKVxuICAgICAgICAgIC8vQXVkaW8ubWVkaWFTdHJlYW1Tb3VyY2UuY29ubmVjdCggR2liYmVyaXNoLm5vZGUgKVxuICAgICAgICAgIEF1ZGlvLl9faGFzSW5wdXQgPSB0cnVlXG4gICAgICAgICAgcmVzb2x2ZSggQXVkaW8uaW5wdXQgKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goIGVyciA9PiB7IFxuICAgICAgICAgIGNvbnNvbGUubG9nKCAnZXJyb3Igb3BlbmluZyBhdWRpbyBpbnB1dDonLCBlcnIgKVxuICAgICAgICB9KVxuICAgIH0pXG4gICAgcmV0dXJuIHBcbiAgfSxcblxuICBjcmVhdGVGRlQoKSB7XG4gICAgQXVkaW8uRkZUID0gQXVkaW8uY3R4LmNyZWF0ZUFuYWx5c2VyKClcblxuICAgIGxldCBfX3dpbmRvd1NpemUgPSA1MTJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEF1ZGlvLCAnd2luZG93U2l6ZScsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIF9fd2luZG93U2l6ZSB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICBfX3dpbmRvd1NpemUgPSB2XG4gICAgICAgIEF1ZGlvLkZGVC5mZnRTaXplID0gdiBcbiAgICAgICAgQXVkaW8uRkZULnZhbHVlcyA9IG5ldyBVaW50OEFycmF5KCBBdWRpby5GRlQuZnJlcXVlbmN5QmluQ291bnQgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBBdWRpby53aW5kb3dTaXplID0gNTEyXG4gIH0sXG5cbiAgZmZ0Q2FsbGJhY2soKSB7XG4gICAgQXVkaW8uRkZULmdldEJ5dGVGcmVxdWVuY3lEYXRhKCBBdWRpby5GRlQudmFsdWVzIClcbiAgICBcbiAgICBsZXQgbG93U3VtLCBtaWRTdW0sIGhpZ2hTdW0sIGxvd0NvdW50LCBtaWRDb3VudCwgaGlnaENvdW50XG4gICAgbG93U3VtID0gbWlkU3VtID0gaGlnaFN1bSA9IGxvd0NvdW50ID0gbWlkQ291bnQgPSBoaWdoQ291bnQgPSAwXG5cbiAgICBsZXQgZnJlcXVlbmN5Q291bnRlciA9IDBcblxuICAgIC8vIGRvZXMgdGhpcyBzdGFydCBhdCAwSHo/IGFjay4uLiBjYW4ndCByZW1lbWJlci4uLiBkb2VzIGl0IGluY2x1ZGUgREMgb2Zmc2V0P1xuICAgIGNvbnN0IGh6UGVyQmluID0gKEF1ZGlvLmN0eC5zYW1wbGVSYXRlIC8gMikgLyBBdWRpby5GRlQuZnJlcXVlbmN5QmluQ291bnRcbiAgICBjb25zdCBsb3dSYW5nZSA9IDE1MCwgbWlkUmFuZ2UgPSAxNDAwLCBoaWdoUmFuZ2UgPSBBdWRpby5jdHguc2FtcGxlUmF0ZSAvIDJcblxuICAgIGZvciggbGV0IGkgPSAxOyBpIDwgQXVkaW8uRkZULmZyZXF1ZW5jeUJpbkNvdW50OyBpKysgKSB7XG4gICAgICBpZiggZnJlcXVlbmN5Q291bnRlciA8IGxvd1JhbmdlICkge1xuICAgICAgICBsb3dTdW0gKz0gQXVkaW8uRkZULnZhbHVlc1sgaSBdXG4gICAgICAgIGxvd0NvdW50KytcbiAgICAgIH1lbHNlIGlmKCBmcmVxdWVuY3lDb3VudGVyIDwgbWlkUmFuZ2UgKSB7XG4gICAgICAgIG1pZFN1bSArPSBBdWRpby5GRlQudmFsdWVzWyBpIF1cbiAgICAgICAgbWlkQ291bnQrK1xuICAgICAgfWVsc2V7XG4gICAgICAgIGhpZ2hTdW0gKz0gQXVkaW8uRkZULnZhbHVlc1sgaSBdXG4gICAgICAgIGhpZ2hDb3VudCsrXG4gICAgICB9XG5cbiAgICAgIGZyZXF1ZW5jeUNvdW50ZXIgKz0gaHpQZXJCaW5cbiAgICB9XG5cbiAgICBBdWRpby5sb3cgPSAobG93U3VtIC8gbG93Q291bnQpIC8gMjU1XG4gICAgQXVkaW8ubWlkID0gKG1pZFN1bSAvIG1pZENvdW50KSAvIDI1NSB8fCAwXG4gICAgQXVkaW8uaGlnaCA9IChoaWdoU3VtIC8gaGlnaENvdW50KSAvIDI1NVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXVkaW9cbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiB9ID0gcmVxdWlyZSggJy4vdmFyLmpzJyApXG5cbmNvbnN0IEJHID0gZnVuY3Rpb24oIFNjZW5lLCBTREYgKSB7XG5cbiAgY29uc3QgQmFja2dyb3VuZCA9IGZ1bmN0aW9uKCBjb2xvciApIHtcbiAgICBpZiggU0RGLm1lbW8uYmFja2dyb3VuZCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgY29uc3QgYmcgPSBPYmplY3QuY3JlYXRlKCBCYWNrZ3JvdW5kLnByb3RvdHlwZSApXG5cbiAgICAgIGNvbnN0IF9fY29sb3IgPSBwYXJhbV93cmFwKCBjb2xvciwgdmVjM192YXJfZ2VuKCAwLDAsMCwgJ2JnJyApLCAnYmcnICkgIFxuICAgICAgXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGJnLCAnY29sb3InLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIF9fY29sb3IgfSxcbiAgICAgICAgc2V0KCB2ICkge1xuICAgICAgICAgIF9fY29sb3IudmFyLnNldCggdiApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIHRoaXMgcmVmZXJzIHRvIHRoZSBjdXJyZW50IHNjZW5lIHZpYSBpbXBsaWNpdCBiaW5kaW5nIGluIHNjZW5lLmpzXG4gICAgICB0aGlzLnBvc3Rwcm9jZXNzaW5nLnB1c2goIGJnIClcblxuICAgICAgU0RGLm1lbW8uYmFja2dyb3VuZCA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEJhY2tncm91bmQucHJvdG90eXBlID0gU2NlbmVOb2RlKClcbiBcbiAgT2JqZWN0LmFzc2lnbiggQmFja2dyb3VuZC5wcm90b3R5cGUsIHtcbiAgICBlbWl0KCkge1xuICAgICAgcmV0dXJuICcnLy90aGlzLmNvbG9yLmVtaXQoKVxuICAgIH0sXG4gICBcbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBsZXQgc3RyID0gdGhpcy5jb2xvci5lbWl0X2RlY2woKVxuICAgICAgU0RGLm1lbW8uYmFja2dyb3VuZCA9IHRydWVcblxuICAgICAgcmV0dXJuIHN0clxuICAgIH0sXG5cbiAgICB1cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgdGhpcy5jb2xvci51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICB9LFxuXG4gICAgdXBsb2FkX2RhdGEoIGdsICkge1xuICAgICAgdGhpcy5jb2xvci51cGxvYWRfZGF0YSggZ2wgKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gQmFja2dyb3VuZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJHIFxuIiwiY29uc3QgdmVjMyA9IHJlcXVpcmUoJ2dsLXZlYzMnKVxuY29uc3QgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdDQnKVxuXG4vLyBjYW1lcmEgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGFtYS9maXJzdC1wZXJzb24tY2FtZXJhXG5mdW5jdGlvbiBGaXJzdFBlcnNvbkNhbWVyYShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaXJzdFBlcnNvbkNhbWVyYSkpIHJldHVybiBuZXcgRmlyc3RQZXJzb25DYW1lcmEob3B0cylcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgdGhpcy5wb3NpdGlvbiA9IG9wdHMucG9zaXRpb24gfHwgdmVjMy5jcmVhdGUoKVxuICB0aGlzLnJvdGF0aW9uID0gb3B0cy5yb3RhdGlvbiB8fCB2ZWMzLmNyZWF0ZSgpXG4gIHRoaXMucG9zaXRpb25TcGVlZCA9IG9wdHMucG9zaXRpb25TcGVlZCB8fCAtLjVcbiAgdGhpcy5yb3RhdGlvblNwZWVkID0gb3B0cy5yb3RhdGlvblNwZWVkIHx8IC4wMVxufVxubW9kdWxlLmV4cG9ydHMgPSBGaXJzdFBlcnNvbkNhbWVyYVxuXG5GaXJzdFBlcnNvbkNhbWVyYS5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKG91dCkge1xuICBpZiAoIW91dCkgb3V0ID0gbWF0NC5jcmVhdGUoKVxuICAvLyBhbHRlcmVkIHgveSBvcmRlcmluZyBmcm9tIG9yaWdpbmFsXG4gIG1hdDQucm90YXRlWShvdXQsIG91dCwgdGhpcy5yb3RhdGlvblsxXSlcbiAgbWF0NC5yb3RhdGVYKG91dCwgb3V0LCB0aGlzLnJvdGF0aW9uWzBdKVxuICBtYXQ0LnJvdGF0ZVoob3V0LCBvdXQsIHRoaXMucm90YXRpb25bMl0gLSBNYXRoLlBJKVxuICBtYXQ0LnRyYW5zbGF0ZShvdXQsIG91dCwgWy10aGlzLnBvc2l0aW9uWzBdLCAtdGhpcy5wb3NpdGlvblsxXSwgLXRoaXMucG9zaXRpb25bMl1dKVxuXG4gIHJldHVybiBvdXRcbn1cblxuRmlyc3RQZXJzb25DYW1lcmEucHJvdG90eXBlLmNvbnRyb2wgPSBmdW5jdGlvbihkdCwgbW92ZSwgbW91c2UsIHByZXZNb3VzZSkge1xuICB2YXIgc3BlZWQgPSAodGhpcy5wb3NpdGlvblNwZWVkIC8gMTAwMCkgKiBkdFxuICB2YXIgZGlyID0gWzAsMCwwXVxuICBpZiAobW92ZVswXSkgZGlyWzJdIC09IHNwZWVkICogKE1hcmNoaW5nLmtleXMuQWx0ID8gNCA6IDEgKVxuICBlbHNlIGlmIChtb3ZlWzFdKSBkaXJbMl0gKz0gc3BlZWQgKiAoTWFyY2hpbmcua2V5cy5BbHQgPyA0IDogMSApXG4gIGlmIChtb3ZlWzJdKSBkaXJbMF0gKz0gc3BlZWQgKiAoTWFyY2hpbmcua2V5cy5BbHQgPyA0IDogMSApXG4gIGVsc2UgaWYgKG1vdmVbM10pIGRpclswXSAtPSBzcGVlZCAqIChNYXJjaGluZy5rZXlzLkFsdCA/IDQgOiAxIClcbiAgaWYgKG1vdmVbNF0pIGRpclsxXSAtPSBzcGVlZCAqIChNYXJjaGluZy5rZXlzLkFsdCA/IDQgOiAxIClcbiAgZWxzZSBpZiAobW92ZVs1XSkgZGlyWzFdICs9IHNwZWVkICogKE1hcmNoaW5nLmtleXMuQWx0ID8gNCA6IDEgKVxuICB0aGlzLm1vdmUoZGlyKVxuICAvLyBqdXN0IHVzZSBhcnJvdyBrZXlzIGluc3RlYWQgb2YgbW91c2VcbiAgLy8gdGhpcy5wb2ludGVyKG1vdXNlLCBwcmV2TW91c2UpXG59XG5cbkZpcnN0UGVyc29uQ2FtZXJhLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGlyKSB7XG4gIGlmIChkaXJbMF0gIT09IDAgfHwgZGlyWzFdICE9PSAwIHx8IGRpclsyXSAhPT0gMCkge1xuICAgIHZhciBjYW0gPSBtYXQ0LmNyZWF0ZSgpXG4gICAgbWF0NC5yb3RhdGVZKGNhbSwgY2FtLCB0aGlzLnJvdGF0aW9uWzFdKVxuICAgIG1hdDQucm90YXRlWChjYW0sIGNhbSwgdGhpcy5yb3RhdGlvblswXSlcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoZGlyLCBkaXIsIGNhbSlcbiAgICB2ZWMzLmFkZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLCBkaXIpXG4gIH1cbn1cblxuLy9GaXJzdFBlcnNvbkNhbWVyYS5wcm90b3R5cGUucG9pbnRlciA9IGZ1bmN0aW9uKGRhLCBkYikge1xuLy8gIHZhciBkdCA9IFtkYVswXSAtIGRiWzBdLCBkYVsxXS0gZGJbMV1dXG4vLyAgdmFyIHJvdCA9IHRoaXMucm90YXRpb25cbi8vICByb3RbMV0gLT0gZHRbMF0gKiB0aGlzLnJvdGF0aW9uU3BlZWRcbi8vICBpZiAocm90WzFdIDwgMCkgcm90WzFdICs9IE1hdGguUEkgKiAyXG4vLyAgaWYgKHJvdFsxXSA+PSBNYXRoLlBJICogMikgcm90WzFdIC09IE1hdGguUEkgKiAyXG4vLyAgcm90WzBdIC09IGR0WzFdICogdGhpcy5yb3RhdGlvblNwZWVkXG4vLyAgaWYgKHJvdFswXSA8IC1NYXRoLlBJICogLjUpIHJvdFswXSA9IC1NYXRoLlBJKjAuNVxuLy8gIGlmIChyb3RbMF0gPiBNYXRoLlBJICogLjUpIHJvdFswXSA9IE1hdGguUEkqMC41XG4vL31cblxuY29uc3QgQ2FtZXJhID0ge1xuICBpbml0KCBnbCwgcHJvZ3JhbSwgaGFuZGxlciApIHtcbiAgICBjb25zdCBjYW1lcmEgPSBGaXJzdFBlcnNvbkNhbWVyYSh7XG4gICAgICBmb3Y6IDE5MCxcbiAgICAgIG5lYXI6LjAxLFxuICAgICAgZmFyOjEwLFxuICAgICAgZGlyZWN0aW9uOlswLDAsMV0sXG4gICAgICB2aWV3cG9ydDpbMSwxLDEsLTFdXG4gICAgfSlcbiAgICBjYW1lcmEucm90YXRpb24gPSBbMCxNYXRoLlBJLE1hdGguUEldIFxuICAgIENhbWVyYS5fX2NhbWVyYSA9IGNhbWVyYVxuXG4gICAgY29uc3QgY2FtZXJhX3BvcyAgICA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NhbWVyYV9wb3MnIClcbiAgICBjb25zdCBjYW1lcmFfbm9ybWFsID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY2FtZXJhX25vcm1hbCcgKVxuICAgIGNvbnN0IGNhbWVyYV9yb3QgICAgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjYW1lcmFfcm90JyApXG4gICAgY29uc3QgdWNhbWVyYSAgICAgICA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NhbWVyYScgKVxuXG4gICAgdGhpcy5wb3MgPSB7IGRpcnR5OmZhbHNlIH1cbiAgICB0aGlzLmRpciA9IHsgZGlydHk6dHJ1ZSB9XG4gICAgdGhpcy5fX3JvdCA9IHsgZGlydHk6dHJ1ZSwgdmFsdWU6MCB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdyb3RhdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5fX3JvdC52YWx1ZSB9LFxuICAgICAgc2V0KHYpIHsgXG4gICAgICAgIHRoaXMuX19yb3QudmFsdWUgPSB2IFxuICAgICAgICB0aGlzLl9fcm90LmRpcnR5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBsZXQgcHggPSAwLCBweSA9MCwgcHogPSA1LCBueCA9IDAsIG55ID0gMCwgbnogPSAwXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMucG9zLCB7XG4gICAgICB4OiB7XG4gICAgICAgIGdldCgpICB7IHJldHVybiBweCB9LFxuICAgICAgICBzZXQodikgeyBweCA9IGNhbWVyYS5wb3NpdGlvblswXSA9IHY7dGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG5cbiAgICAgIHk6IHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIHB5IH0sXG4gICAgICAgIHNldCh2KSB7IHB5ID0gY2FtZXJhLnBvc2l0aW9uWzFdID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG5cbiAgICAgIHo6IHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIHB6IH0sXG4gICAgICAgIHNldCh2KSB7IHB6ID0gY2FtZXJhLnBvc2l0aW9uWzJdID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG4gICAgfSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLmRpciwge1xuICAgICAgeDoge1xuICAgICAgICBnZXQoKSAgeyByZXR1cm4gbnggfSxcbiAgICAgICAgc2V0KHYpIHsgbnggPSBjYW1lcmEucm90YXRpb25bMF0gPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfVxuICAgICAgfSxcblxuICAgICAgeToge1xuICAgICAgICBnZXQoKSAgeyByZXR1cm4gbnkgfSxcbiAgICAgICAgc2V0KHYpIHsgbnkgPSBjYW1lcmEucm90YXRpb25bMV0gPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfVxuICAgICAgfSxcblxuICAgICAgejoge1xuICAgICAgICBnZXQoKSAgeyByZXR1cm4gbnogfSxcbiAgICAgICAgc2V0KHYpIHsgbnogPSBjYW1lcmEucm90YXRpb25bMl0gPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfVxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgbGV0IGluaXQgPSBmYWxzZVxuICAgIGdsLnVuaWZvcm0zZiggY2FtZXJhX25vcm1hbCwgdGhpcy5kaXIueCwgdGhpcy5kaXIueSwgdGhpcy5kaXIueiApXG4gICAgY2FtZXJhLnBvc2l0aW9uID0gW3RoaXMucG9zLngsIHRoaXMucG9zLnksIHRoaXMucG9zLnogXSBcbiAgICAvL2NhbWVyYS51cGRhdGUoKVxuICAgIGdsLnVuaWZvcm0zZiggY2FtZXJhX3BvcywgdGhpcy5wb3MueCwgdGhpcy5wb3MueSwgdGhpcy5wb3MueiApXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdWNhbWVyYSwgZmFsc2UsIGNhbWVyYS52aWV3KCkgKVxuICAgIGdsLnVuaWZvcm0xZiggY2FtZXJhX3JvdCwgdGhpcy5yb3QgKSBcblxuICAgIENhbWVyYS5tb3ZlID0gKHgseSx6KSA9PiB7XG4gICAgICAvLyBYWFggZG9lcyB0aGlzIG5lZWQgdG8gdXBkYXRlIHByb3BlcnR5IHZhbHVlcz9cbiAgICAgIGNhbWVyYS5tb3ZlKFt4LHksel0pXG4gICAgICBDYW1lcmEudXBkYXRlKClcbiAgICB9XG4gICAgQ2FtZXJhLm1vdmVUbyA9ICh4LHkseikgPT4ge1xuICAgICAgQ2FtZXJhLnBvcy54ID0geFxuICAgICAgQ2FtZXJhLnBvcy55ID0geVxuICAgICAgQ2FtZXJhLnBvcy56ID0gelxuICAgIH1cbiAgICBDYW1lcmEudXBkYXRlID0gKCk9PiB7XG4gICAgICBjb25zdCBwb3MgPSBjYW1lcmEucG9zaXRpb25cbiAgICAgIGdsLnVuaWZvcm0zZiggY2FtZXJhX3BvcywgcG9zWzBdLCBwb3NbMV0sIHBvc1syXSAgKVxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdWNhbWVyYSwgZmFsc2UsIGNhbWVyYS52aWV3KCkgKVxuICAgIH1cblxuICAgIGxldCBwcnZ4ID0gMCwgcHJ2eSA9IDAsIHggPSAwLCB5ID0gMFxuICAgIENhbWVyYS5fX21vdXNlbW92ZWZuYyA9IGUgPT4ge1xuICAgICAgcHJ2eCA9IHhcbiAgICAgIHBydnkgPSB5XG4gICAgICB4ID0gZS5wYWdlWFxuICAgICAgeSA9IGUucGFnZVlcbiAgICB9XG5cbiAgICBsZXQgcHJldlRpbWUgPSAwXG4gICAgbGV0IGsgID0gTWFyY2hpbmcua2V5c1xuICAgIENhbWVyYS5fX2ZyYW1lZm5jID0gdCA9PiB7XG4gICAgICBpZiggay5BcnJvd0xlZnQgKSBjYW1lcmEucm90YXRpb25bMV0gKz0gY2FtZXJhLnJvdGF0aW9uU3BlZWRcbiAgICAgIGlmKCBrLkFycm93UmlnaHQgKSBjYW1lcmEucm90YXRpb25bMV0gLT0gY2FtZXJhLnJvdGF0aW9uU3BlZWRcbiAgICAgIGlmKCBrLkFycm93VXAgJiYgIWsuU2hpZnQgKSBjYW1lcmEucm90YXRpb25bMF0gLT0gY2FtZXJhLnJvdGF0aW9uU3BlZWRcbiAgICAgIGlmKCBrLkFycm93RG93biAmJiAhay5TaGlmdCkgY2FtZXJhLnJvdGF0aW9uWzBdICs9IGNhbWVyYS5yb3RhdGlvblNwZWVkXG4gICAgICBcbiAgICAgIGlmKCBNYXJjaGluZy5jYW1lcmFFbmFibGVkICkgeyBcbiAgICAgICAgY2FtZXJhLmNvbnRyb2woIFxuICAgICAgICAgIHQqMTAwMCAtIHByZXZUaW1lLFxuICAgICAgICAgIFtrLncsay5zLGsuZCxrLmEsay5BcnJvd1VwICYmIGsuU2hpZnQsIGsuQXJyb3dEb3duICYmIGsuU2hpZnRdLCBcbiAgICAgICAgICBbeCx5XSwgW3BydngscHJ2eV0gXG4gICAgICAgIClcbiAgICAgICAgQ2FtZXJhLnVwZGF0ZSgpXG4gICAgICAgIHBydnggPSB4XG4gICAgICAgIHBydnkgPSB5XG4gICAgICAgIHByZXZUaW1lID0gdCoxMDAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgQ2FtZXJhLl9fbW91c2Vtb3ZlID0gbnVsbFxuICAgIENhbWVyYS5vbiA9ICgpPT4ge1xuICAgICAgaWYoIENhbWVyYS5fX21vdXNlbW92ZSA9PT0gbnVsbCApIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBDYW1lcmEuX19tb3VzZW1vdmVmbmMgKVxuICAgICAgICBDYW1lcmEuX19tb3VzZW1vdmUgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiggTWFyY2hpbmcuY2FsbGJhY2tzLmluZGV4T2YoIENhbWVyYS5fX2ZyYW1lZm5jICkgPT09IC0xICkge1xuICAgICAgICBNYXJjaGluZy5jYWxsYmFja3MucHVzaCggQ2FtZXJhLl9fZnJhbWVmbmMgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZXIoICgpPT4ge1xuICAgICAgaWYoIHRoaXMucG9zLmRpcnR5ID09PSB0cnVlICkge1xuICAgICAgICAvL2NhbWVyYS5wb3NpdGlvbiA9IFt0aGlzLnBvcy54LCB0aGlzLnBvcy55LCB0aGlzLnBvcy56IF1cbiBcbiAgICAgICAgLy9jYW1lcmEucG9zaXRpb24gPSBbdGhpcy5wb3MueCwgdGhpcy5wb3MueSwgdGhpcy5wb3MueiBdXG4gICAgICAgIC8vY2FtZXJhLnVwZGF0ZSgpXG4gICAgICAgIGNvbnN0IHBvcyA9IGNhbWVyYS5wb3NpdGlvblxuICAgICAgICBnbC51bmlmb3JtM2YoIGNhbWVyYV9wb3MsIHBvc1swXSwgcG9zWzFdLCBwb3NbMl0gKVxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KCB1Y2FtZXJhLCBmYWxzZSwgY2FtZXJhLnZpZXcoKSApXG4gICAgICAgIHRoaXMucG9zLmRpcnR5ID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gWFhYIHRoaXMgaXMgYnJva2VuIGFuZCBuZWVkcyB0byBiZSBmaXhlZFxuICAgICAgaWYoIHRoaXMuZGlyLmRpcnR5ID09PSB0cnVlICkge1xuICAgICAgICBnbC51bmlmb3JtM2YoIGNhbWVyYV9ub3JtYWwsIHRoaXMuZGlyLngsIHRoaXMuZGlyLnksIHRoaXMuZGlyLnogKVxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KCB1Y2FtZXJhLCBmYWxzZSwgY2FtZXJhLnZpZXcoKSApXG4gICAgICAgIHRoaXMuZGlyLmRpcnR5ID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmKCB0aGlzLl9fcm90LmRpcnR5ID09PSB0cnVlICkge1xuICAgICAgICBnbC51bmlmb3JtMWYoIGNhbWVyYV9yb3QsIHRoaXMuX19yb3QudmFsdWUgKVxuICAgICAgICB0aGlzLl9fcm90LmRpcnR5ID0gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW1lcmFcbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKVxuY29uc3QgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxuY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9ID0gcmVxdWlyZSggJy4vdmFyLmpzJyApXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCAnLi90cmFuc2Zvcm0uanMnIClcblxuY29uc3Qgb3BzID0geyBcbiAgLy8gdGhpcyBuZWVkcyB0byBjcmVhdGUgYW4gb3BPdXQsIG5vdCByZXR1cm4gYSB2ZWMyXG4gIERpc3BsYWNlKCBfX25hbWUgKSB7XG4gICAgbGV0IG5hbWUgPSBfX25hbWUgPT09IHVuZGVmaW5lZCA/ICdwJyA6IF9fbmFtZVxuICAgIGNvbnN0IHNkZiA9IHRoaXMuc2RmLmVtaXQoIG5hbWUgKTtcblxuICAgIGNvbnN0IHNkZlN0ciA9IGBmbG9hdCBkMSR7dGhpcy5pZH0gPSAke3NkZi5vdXR9Lng7XFxuYFxuXG4gICAgbGV0IGRpc3BsYWNlU3RyaW5nID0gYGZsb2F0IGQyJHt0aGlzLmlkfSA9IHNpbiggJHt0aGlzLmFtb3VudC5lbWl0KCl9LnggKiAke25hbWV9LnggKSAqIGAgIFxuICAgIGRpc3BsYWNlU3RyaW5nICs9IGBzaW4oICR7dGhpcy5hbW91bnQuZW1pdCgpfS55ICogJHtuYW1lfS55ICkgKiBgXG4gICAgZGlzcGxhY2VTdHJpbmcgKz0gYHNpbiggJHt0aGlzLmFtb3VudC5lbWl0KCl9LnogKiAke25hbWV9LnogKTtcXG5gXG4gICAgZGlzcGxhY2VTdHJpbmcgKz0gYCR7c2RmLm91dH0ueCA9IChkMSR7dGhpcy5pZH0gKyBkMiR7dGhpcy5pZH0qJHt0aGlzLnNpemUuZW1pdCgpfSkqLjU7XFxuYFxuXG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgb3V0OiBgJHtzZGYub3V0fWAsIFxuICAgICAgcHJlZmFjZTogc2RmLnByZWZhY2UgKyBzZGZTdHIgKyBkaXNwbGFjZVN0cmluZyBcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH0sXG5cbiAgQmVuZCggX19uYW1lICkge1xuICAgIGxldCBuYW1lID0gX19uYW1lID09PSB1bmRlZmluZWQgPyAncCcgOiBfX25hbWVcbiAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCAncScrdGhpcy5pZCApO1xuXG4gICAgbGV0IHByZWZhY2U9YCAgICAgICAgZmxvYXQgYyR7dGhpcy5pZH0gPSBjb3MoICR7dGhpcy5hbW91bnQuZW1pdCgpfS54ICogJHtuYW1lfS54ICk7XG4gICAgICAgIGZsb2F0IHMke3RoaXMuaWR9ID0gc2luKCAke3RoaXMuYW1vdW50LmVtaXQoKX0ueCAqICR7bmFtZX0ueCApO1xuICAgICAgICBtYXQyICBtJHt0aGlzLmlkfSA9IG1hdDIoIGMke3RoaXMuaWR9LC1zJHt0aGlzLmlkfSxzJHt0aGlzLmlkfSxjJHt0aGlzLmlkfSApO1xuICAgICAgICB2ZWM0ICBxJHt0aGlzLmlkfSA9IHZlYzQoIG0ke3RoaXMuaWR9ICogJHtuYW1lfS54eSwgJHtuYW1lfS56LCAxLiApO1xcbmBcblxuICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkge1xuICAgICAgcHJlZmFjZSArPSBzZGYucHJlZmFjZVxuICAgIH1cblxuICAgIHJldHVybiB7IHByZWZhY2UsIG91dDpzZGYub3V0IH1cbiAgfSxcblxuICBUd2lzdCggX19uYW1lICkge1xuICAgIGxldCBuYW1lID0gX19uYW1lID09PSB1bmRlZmluZWQgPyAncCcgOiBfX25hbWVcbiAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCAncScrdGhpcy5pZCApO1xuXG4gICAgbGV0IHByZWZhY2U9YCAgICAgICAgZmxvYXQgYyR7dGhpcy5pZH0gPSBjb3MoICR7dGhpcy5hbW91bnQuZW1pdCgpfS54ICogJHtuYW1lfS55ICk7XG4gICAgICAgIGZsb2F0IHMke3RoaXMuaWR9ID0gc2luKCAke3RoaXMuYW1vdW50LmVtaXQoKX0ueCAqICR7bmFtZX0ueSApO1xuICAgICAgICBtYXQyICBtJHt0aGlzLmlkfSA9IG1hdDIoIGMke3RoaXMuaWR9LC1zJHt0aGlzLmlkfSxzJHt0aGlzLmlkfSxjJHt0aGlzLmlkfSApO1xuICAgICAgICB2ZWM0ICBxJHt0aGlzLmlkfSA9IHZlYzQoIG0ke3RoaXMuaWR9ICogJHtuYW1lfS54eiwgJHtuYW1lfS55LCAxLiApO1xcbmBcblxuICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkge1xuICAgICAgcHJlZmFjZSArPSBzZGYucHJlZmFjZVxuICAgIH1cblxuICAgIHJldHVybiB7IHByZWZhY2UsIG91dDpzZGYub3V0IH1cbiAgfSxcbiAgX19CdW1wKCBfX25hbWUgKSB7XG4gICAgbGV0IG5hbWUgPSBfX25hbWUgPT09IHVuZGVmaW5lZCA/ICdwJyA6IF9fbmFtZVxuXG4gICAgY29uc3QgYnVtcFN0cmluZyA9ICBgICAgICAgICB2ZWM0IHRyYW5zZm9ybUJ1bXAke3RoaXMuaWR9ID0gJHtuYW1lfSAqICR7dGhpcy50cmFuc2Zvcm0uZW1pdCgpfTtcXG5gXG4gICAgY29uc3QgdGV4ID0gdGhpcy5hbW91bnQuZW1pdCggbmFtZSApXG5cbiAgICBjb25zdCBwb2ludFN0cmluZyA9IGAodHJhbnNmb3JtQnVtcCR7dGhpcy5pZH0gKiAke3RoaXMuc2RmLnRyYW5zZm9ybS5lbWl0KCl9KWBcblxuICAgIGNvbnN0IHNkZiA9IHRoaXMuc2RmLmVtaXQoIHBvaW50U3RyaW5nLCB0aGlzLnRyYW5zZm9ybSwgYHRleCR7dGhpcy5pZH1gICkgXG5cbiAgICBNYXJjaGluZy50ZXh0dXJlcy5hZGRUZXh0dXJlKCB0aGlzLmFtb3VudC52YWx1ZSApXG5cbiAgICBsZXQgcHJlZmFjZT1gICB2ZWMzIHRleCR7dGhpcy5pZH0gPSBnZXRUZXh0dXJlKCAke3RoaXMuYW1vdW50LnZhbHVlLmlkfSwgJHtwb2ludFN0cmluZ30ueHl6ICkgKiAke3RoaXMuc2l6ZS5lbWl0KCl9O1xcblxuICAgICAgICAvL3ZlYzQgZGlzcGxhY2VCdW1wJHt0aGlzLmlkfSA9IHZlYzQoKCR7cG9pbnRTdHJpbmd9IC0gdGV4JHt0aGlzLmlkfSksIDEuKTtcbiAgICBgXG4gICAgICAgIC8vJHtzZGYub3V0fS54ID0gKHRleCR7dGhpcy5pZH0ueCArIHRleCR7dGhpcy5pZH0ueSArIHRleCR7dGhpcy5pZH0ueiApIC8gMy4gKiAuNSArICR7c2RmLm91dH0ueDtcXG5gXG4gICAgICAgIC8vdmVjNCAkeydwJyt0aGlzLmlkfSA9IHZlYzQoJHtwb2ludFN0cmluZ30gKyB0ZXgke3RoaXMuaWR9LCAxLik7XFxuYFxuXG4gICAgLy9zZGYucHJlZmFjZSArPSBgXFxuICAgICAgICBcbiAgICAvLyAgICAke3NkZi5vdXR9LnggLT0gbWluKHRleCR7dGhpcy5pZH0ueCwgbWluKHRleCR7dGhpcy5pZH0ueSwgdGV4JHt0aGlzLmlkfS56KSk7XFxuYCBcblxuICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkge1xuICAgICAgcHJlZmFjZSA9IHByZWZhY2UgKyBzZGYucHJlZmFjZVxuICAgIH1cblxuICAgIHByZWZhY2UgPSAgYnVtcFN0cmluZyArIHByZWZhY2VcblxuICAgIHJldHVybiB7IHByZWZhY2UsIG91dDpzZGYub3V0IH1cbiAgfSxcbiAgLy8gWFhYIHRvZG86IHNvbWV0aGluZyBsaWtlIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9sZFNHelJcbiAgLy8gaHR0cHM6Ly93d3cuZHJvcGJveC5jb20vcy9sMXlsMTY0amIzcmhvbXEvbW1fc2ZncmFkX2J1bXAucGRmP2RsPTBcbiAgQnVtcCggX19uYW1lICkge1xuICAgIGxldCBuYW1lID0gX19uYW1lID09PSB1bmRlZmluZWQgPyAncCcgOiBfX25hbWVcblxuICAgIGNvbnN0IGJ1bXBTdHJpbmcgPSAgYCAgICAgICAgdmVjNCB0cmFuc2Zvcm1CdW1wJHt0aGlzLmlkfSA9ICR7bmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX07XFxuYFxuICAgIGNvbnN0IHRleCA9IHRoaXMuYW1vdW50LmVtaXQoIG5hbWUgKVxuXG4gICAgY29uc3QgcG9pbnRTdHJpbmcgPSBgKHRyYW5zZm9ybUJ1bXAke3RoaXMuaWR9ICogJHt0aGlzLnNkZi50cmFuc2Zvcm0uZW1pdCgpfSkueHl6YFxuXG4gICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggYHRyYW5zZm9ybUJ1bXAke3RoaXMuaWR9YCwgdGhpcy50cmFuc2Zvcm0gKSBcblxuICAgIE1hcmNoaW5nLnRleHR1cmVzLmFkZFRleHR1cmUoIHRoaXMuYW1vdW50LnZhbHVlIClcblxuICAgIGxldCBwcmVmYWNlPWAgIHZlYzMgdGV4JHt0aGlzLmlkfSA9IGdldFRleHR1cmUoICR7dGhpcy5hbW91bnQudmFsdWUuaWR9LCAke3BvaW50U3RyaW5nfSkgKiAke3RoaXMuc2l6ZS5lbWl0KCl9O1xuICAgICAgICAke3NkZi5vdXR9LnggPSAodGV4JHt0aGlzLmlkfS54ICsgdGV4JHt0aGlzLmlkfS55ICsgdGV4JHt0aGlzLmlkfS56KS8zLiArICR7c2RmLm91dH0ueDtcXG5gXG5cbiAgICBpZiggdHlwZW9mIHNkZi5wcmVmYWNlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIHByZWZhY2UgPSBzZGYucHJlZmFjZSArIHByZWZhY2VcbiAgICB9XG5cbiAgICBwcmVmYWNlID0gYnVtcFN0cmluZyArIHByZWZhY2VcblxuICAgIHJldHVybiB7IHByZWZhY2UsIG91dDpzZGYub3V0IH1cbiAgfSxcbn1cblxuY29uc3QgRGlzdGFuY2VPcHMgPSB7fVxuXG5mb3IoIGxldCBuYW1lIGluIG9wcyApIHtcblxuICAvLyBnZXQgY29kZWdlbiBmdW5jdGlvblxuICBsZXQgX19vcCA9IG9wc1sgbmFtZSBdXG5cbiAgLy8gY3JlYXRlIGNvbnN0cnVjdG9yXG4gIERpc3RhbmNlT3BzWyBuYW1lIF0gPSBmdW5jdGlvbiggYSxiLGMgKSB7XG4gICAgY29uc3Qgb3AgPSBPYmplY3QuY3JlYXRlKCBEaXN0YW5jZU9wc1sgbmFtZSBdLnByb3RvdHlwZSApXG4gICAgb3Auc2RmID0gYVxuICAgIG9wLmFtb3VudCA9IGJcbiAgICBvcC5lbWl0ID0gX19vcFxuICAgIG9wLm5hbWUgPSBuYW1lXG4gICAgb3AudHJhbnNmb3JtID0gVHJhbnNmb3JtKClcblxuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBbLjUsLjUsLjVdXG5cbiAgICBvcC5pZCA9IFZhckFsbG9jLmFsbG9jKClcbiAgICBjb25zdCBpc0FycmF5ID0gdHJ1ZSBcbiAgICBcbiAgICBpZiggdHlwZW9mIGIgPT09ICdudW1iZXInICkge1xuICAgICAgYiA9IFtiLGIsYl1cbiAgICAgIGIudHlwZSA9ICd2ZWMzJ1xuICAgIH1cbiAgICBcbiAgICBpZiggbmFtZSAhPT0gJ0J1bXB6JyApIHtcbiAgICAgIGxldCBfX3ZhciA9ICBwYXJhbV93cmFwKCBcbiAgICAgICAgYiwgXG4gICAgICAgIHZlYzNfdmFyX2dlbiggLi4uZGVmYXVsdFZhbHVlcyApIFxuICAgICAgKVxuXG4gICAgICAvLyBmb3IgYXNzaWduaW5nIGVudGlyZSBuZXcgdmVjdG9ycyB0byBwcm9wZXJ0eVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvcCwgJ2Ftb3VudCcsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgX192YXIuc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIF9fdmFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICBfX3Zhci52YWx1ZS55ID0gdlxuICAgICAgICAgICAgX192YXIudmFsdWUueiA9IHZcbiAgICAgICAgICAgIF9fdmFyLnZhbHVlLncgPSB2XG4gICAgICAgICAgICBfX3Zhci5kaXJ0eSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIG9wLnBhcmFtcyA9IFt7IG5hbWU6J2Ftb3VudCcgfV1cbiAgICB9ZWxzZXtcbiAgICAgIG9wLnBhcmFtcyA9IFtdXG4gICAgICBvcC5lbWl0X2RlY2wgPSBmdW5jdGlvbigpIHt9XG4gICAgICBvcC5lbWl0ID0gZnVuY3Rpb24oKSB7fVxuICAgICAgb3AudXBkYXRlX2RhdGE9IGZ1bmN0aW9uKCkge31cbiAgICAgIG9wLnVwbG9hZF9sb2NhdGlvbiA9IGZ1bmN0aW9uKCkge31cbiAgICB9XG4gICAgb3AuX19zZXRNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdCkge1xuICAgICAgaWYoIHR5cGVvZiBtYXQgPT09ICdzdHJpbmcnICkgbWF0ID0gTWFyY2hpbmcuTWF0ZXJpYWxbIG1hdCBdXG4gICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IE1hcmNoaW5nLm1hdGVyaWFscy5hZGRNYXRlcmlhbCggbWF0IClcbiAgICAgIG9wLnNkZi5tYXRlcmlhbCggdGhpcy5fX21hdGVyaWFsIClcbiAgICB9XG4gICAgaWYoIG5hbWUgPT09ICdEaXNwbGFjZScgfHwgbmFtZSA9PT0gJ0J1bXAnICkge1xuICAgICAgbGV0IF9fdmFyMiA9ICBwYXJhbV93cmFwKCBcbiAgICAgICAgYywgXG4gICAgICAgIGZsb2F0X3Zhcl9nZW4oIC4wMyApIFxuICAgICAgKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvcCwgJ3NpemUnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyMiB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIF9fdmFyMi5zZXQoIHYgKVxuICAgICAgICAgIF9fdmFyMi5kaXJ0eSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgb3AucGFyYW1zLnB1c2goeyBuYW1lOidzaXplJyB9KVxuICAgIH1cbiAgICBvcC5fX2Rlc2MgPSB7IHBhcmFtZXRlcnM6b3AucGFyYW1zIH1cbiAgICByZXR1cm4gb3BcbiAgfSBcblxuICBEaXN0YW5jZU9wc1sgbmFtZSBdLnByb3RvdHlwZSA9IFNjZW5lTm9kZSgpXG5cbiAgRGlzdGFuY2VPcHNbbmFtZV0ucHJvdG90eXBlLmVtaXRfZGVjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgc3RyID0gIHRoaXMuc2RmLmVtaXRfZGVjbCgpICsgKHRoaXMubmFtZSAhPT0gJ0J1bXAnID8gdGhpcy5hbW91bnQuZW1pdF9kZWNsKCkgOiAnJylcbiAgICBzdHIgKz0gdGhpcy50cmFuc2Zvcm0uZW1pdF9kZWNsKClcbiAgICBpZiggdGhpcy5uYW1lID09PSAnRGlzcGxhY2UnIHx8IHRoaXMubmFtZSA9PT0gJ0J1bXAnICkgc3RyICs9IHRoaXMuc2l6ZS5lbWl0X2RlY2woKSAgXG5cbiAgICByZXR1cm4gc3RyXG4gIH07XG5cbiAgRGlzdGFuY2VPcHNbbmFtZV0ucHJvdG90eXBlLnVwZGF0ZV9sb2NhdGlvbiA9IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgdGhpcy5zZGYudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgaWYoIHRoaXMubmFtZSAhPT0gJ0J1bXAnICkgdGhpcy5hbW91bnQudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgaWYoIHRoaXMubmFtZSA9PT0gJ0Rpc3BsYWNlJyB8fCB0aGlzLm5hbWUgPT09ICdCdW1wJykgdGhpcy5zaXplLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSBcbiAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgfVxuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS51cGxvYWRfZGF0YSA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdGhpcy5zZGYudXBsb2FkX2RhdGEoIGdsIClcbiAgICBpZiggdGhpcy5uYW1lICE9PSAnQnVtcCcgKSB0aGlzLmFtb3VudC51cGxvYWRfZGF0YSggZ2wgKVxuICAgIGlmKCB0aGlzLm5hbWUgPT09ICdEaXNwbGFjZScgfHwgdGhpcy5uYW1lID09PSAnQnVtcCcpIHRoaXMuc2l6ZS51cGxvYWRfZGF0YSggZ2wgKVxuICAgIHRoaXMudHJhbnNmb3JtLnVwbG9hZF9kYXRhKCBnbCApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZU9wc1xuXG4iLCJjb25zdCBTY2VuZU5vZGUgPSByZXF1aXJlKCAnLi9zY2VuZU5vZGUuanMnIClcbmNvbnN0IHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnIClcbmNvbnN0IHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuLCBpbnRfdmFyX2dlbiwgVmFyQWxsb2MgfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSggJy4vdHJhbnNmb3JtLmpzJyApXG5jb25zdCBnbHNsb3BzID0gcmVxdWlyZSggJy4vZGlzdGFuY2VPcGVyYXRpb25zR0xTTC5qcycgKVxuXG5jb25zdCBvcHNsZW4gPSB7IFxuICBVbmlvbjoyLFxuICBJbnRlcnNlY3Rpb246MixcbiAgRGlmZmVyZW5jZToyLFxuICBTdGFpcnNVbmlvbjo0LFxuICBTdGFpcnNJbnRlcnNlY3Rpb246NCxcbiAgU3RhaXJzRGlmZmVyZW5jZTo0LFxuICBSb3VuZFVuaW9uOjMsXG4gIFJvdW5kRGlmZmVyZW5jZTozLFxuICBSb3VuZEludGVyc2VjdGlvbjozLFxuICBDaGFtZmVyVW5pb246MyxcbiAgQ2hhbWZlckRpZmZlcmVuY2U6MyxcbiAgQ2hhbWZlckludGVyc2VjdGlvbjozLFxuICBQaXBlOjMsXG4gIEVuZ3JhdmU6MyxcbiAgR3Jvb3ZlOjQsXG4gIFRvbmd1ZTo0LFxuICBcbiAgLy8gdGhlc2UgdHdvIGRvIG5vdCBjdXJyZW50bHkgaGF2ZSBzdXBwb3J0IGZvciB0cmFuc2Zvcm1zIG9yIHJlcGVhdHMuLi5cbiAgT25pb246MixcbiAgU3dpdGNoOjJcbn1cblxuY29uc3Qgb3BzID0geyBcbiAgVW5pb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgb3BVKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBTbW9vdGhVbmlvbiggLi4uYXJncyAgKSB7IHJldHVybiBgb3BTbW9vdGhVbmlvbiggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgSW50ZXJzZWN0aW9uKCAuLi5hcmdzICkgeyByZXR1cm4gYG9wSSggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgU21vb3RoSW50ZXJzZWN0aW9uKCAuLi5hcmdzICkgeyByZXR1cm4gYG9wU21vb3RoSW50ZXJzZWN0aW9uKCAke2FyZ3Muam9pbignLCcpfSApYCB9LCAgXG4gIERpZmZlcmVuY2UoIC4uLmFyZ3MgKSB7IHJldHVybiBgb3BTKCAke2FyZ3Muam9pbignLCcpfSApYCB9LCAgXG4gIFNtb290aERpZmZlcmVuY2UoIC4uLmFyZ3MgKSB7IHJldHVybiBgb3BTbW9vdGhTdWJ0cmFjdGlvbiggJHthcmdzLmpvaW4oJywnKX0gKWAgfSwgIFxuICBTdGFpcnNVbmlvbiggIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wVW5pb25TdGFpcnMoICR7YXJncy5qb2luKCcsJyl9IClgICB9LFxuICBTdGFpcnNJbnRlcnNlY3Rpb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wSW50ZXJzZWN0aW9uU3RhaXJzKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBTdGFpcnNEaWZmZXJlbmNlKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcFN1YnN0cmFjdGlvblN0YWlycyggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgUm91bmRVbmlvbiggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BVbmlvblJvdW5kKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBSb3VuZERpZmZlcmVuY2UoIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wRGlmZmVyZW5jZVJvdW5kKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBSb3VuZEludGVyc2VjdGlvbiggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BJbnRlcnNlY3Rpb25Sb3VuZCggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgQ2hhbWZlclVuaW9uKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcFVuaW9uQ2hhbWZlciggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgQ2hhbWZlckRpZmZlcmVuY2UoIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wRGlmZmVyZW5jZUNoYW1mZXIoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIENoYW1mZXJJbnRlcnNlY3Rpb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wSW50ZXJzZWN0aW9uQ2hhbWZlciggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgUGlwZSggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BQaXBlKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBFbmdyYXZlKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcEVuZ3JhdmUoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIEdyb292ZSggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BHcm9vdmUoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFRvbmd1ZSggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BUb25ndWUoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFxuICAvLyB0aGVzZSB0d28gZG8gbm90IGN1cnJlbnRseSBoYXZlIHN1cHBvcnQgZm9yIHRyYW5zZm9ybXMgb3IgcmVwZWF0cy4uLlxuICBPbmlvbiggYSxiICkgeyByZXR1cm4gYG9wT25pb24oICR7YX0sICR7Yn0gKWAgfSxcbiAgU3dpdGNoKCBhLGIsYyxkLGUsZiApIHsgcmV0dXJuIGBvcFN3aXRjaCggJHthfSwgJHtifSwgJHtjfSApYCB9XG59XG5cbmNvbnN0IGVtaXRfZmxvYXQgPSBmdW5jdGlvbiggYSApIHtcblx0aWYgKGEgJSAxID09PSAwKVxuXHRcdHJldHVybiBhLnRvRml4ZWQoIDEgKVxuXHRlbHNlXG5cdFx0cmV0dXJuIGFcbn1cblxuY29uc3QgRGlzdGFuY2VPcHMgPSB7XG4gIF9fZ2xzbDpbXSxcbiAgX19nZXRHTFNMKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2xzbC5qb2luKCdcXG4nKVxuICB9LFxuICBfX2NsZWFyKCkgeyB0aGlzLl9fZ2xzbC5sZW5ndGggPSAwIH1cbn1cblxuXG5mb3IoIGxldCBuYW1lIGluIG9wcyApIHtcblxuICAvLyBnZXQgY29kZWdlbiBmdW5jdGlvblxuICBsZXQgb3AgPSBvcHNbIG5hbWUgXVxuICBjb25zdCBuYW1lMiA9IG5hbWUgKyAnMidcblxuICAvLyBjcmVhdGUgY29uc3RydWN0b3JcbiAgRGlzdGFuY2VPcHNbIG5hbWUgXSA9IGZ1bmN0aW9uKCBhLGIsYyxkICkge1xuICAgIGNvbnN0IG9wID0gT2JqZWN0LmNyZWF0ZSggRGlzdGFuY2VPcHNbIG5hbWUgXS5wcm90b3R5cGUgKVxuICAgIG9wLmEgPSBhXG4gICAgb3AuYiA9IGJcbiAgICBvcC50cmFuc2Zvcm0gPSBUcmFuc2Zvcm0oIGZhbHNlIClcbiAgICBvcC5pZCA9IFZhckFsbG9jLmFsbG9jKClcbiAgICBvcC50eXBlID0gJ2RvbWFpbl9vcCdcblxuICAgIGxldCBfX2MgPSBwYXJhbV93cmFwKCBjLCBmbG9hdF92YXJfZ2VuKC4zKSApXG5cbiAgICBvcC5fX2xlbiA9IG9wc2xlblsgbmFtZSBdXG4gICAgaWYoIG9wLl9fbGVuID4gMiApIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICdjJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBfX2MgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBfX2Muc2V0KCB2IClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgaWYoIG9wLl9fbGVuID4gMyApIHtcbiAgICAgICAgbGV0IF9fZCA9IHBhcmFtX3dyYXAoIGQsIGZsb2F0X3Zhcl9nZW4oNCkgKVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICdkJywge1xuICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fZCB9LFxuICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICBfX2Quc2V0KCB2IClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3AuX19zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICBpZiggdHlwZW9mIHRleCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG9wLnRleHR1cmUuYmluZCggdGhpcyApXG4gICAgICAgIHRoaXMuX190ZXh0dXJlT2JqID0gdGhpcy50ZXggPSBNYXJjaGluZy5UZXh0dXJlKCB0ZXgscHJvcHMsdGhpcy50ZXh0dXJlIClcbiAgICAgICAgdGhpcy5fX3RleHR1cmVJRCA9IHRoaXMuX190ZXh0dXJlT2JqLmlkXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IE9iamVjdC5hc3NpZ24oIHRleCwgcHJvcHMgKVxuICAgICAgICB0aGlzLl9fdGV4dHVyZUlEID0gdGhpcy5fX3RleHR1cmVPYmouaWRcbiAgICAgIH1cbiAgICB9XG4gICAgb3AuX19zZXRNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdCkge1xuICAgICAgaWYoIHR5cGVvZiBtYXQgPT09ICdzdHJpbmcnICkgbWF0ID0gTWFyY2hpbmcuTWF0ZXJpYWxbIG1hdCBdXG4gICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IE1hcmNoaW5nLm1hdGVyaWFscy5hZGRNYXRlcmlhbCggbWF0IClcbiAgICB9XG4gICAgb3AuX19zZXRCdW1wID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAvL3RoaXMuYnVtcCA9IHAuYnVtcC5iaW5kKCB0aGlzIClcbiAgICAgIGNvbnN0IGIgPSB0aGlzLmJ1bXAgPSB0aGlzLl9fYnVtcE9iaiA9IE1hcmNoaW5nLkJ1bXAoIHRoaXMsIHRleCwgcHJvcHMgKVxuICAgICAgdGhpcy5idW1wLnRleHR1cmUgPSB0aGlzLmJ1bXAuYW1vdW50LnZhbHVlXG4gICAgICB0aGlzLl9fYnVtcElEID0gdGhpcy5fX2J1bXBPYmouaWRcbiAgICAgIHRoaXMucm90YXRlID0gdGhpcy5idW1wLnJvdGF0ZVxuICAgICAgdGhpcy50cmFuc2xhdGUgPSB0aGlzLmJ1bXAudHJhbnNsYXRlXG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5idW1wLnNjYWxlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuYnVtcCwgJ3N0cmVuZ3RoJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBiLnNpemUgfSxcbiAgICAgICAgc2V0KHYpeyBiLnNpemUgPSB2IH1cbiAgICAgIH0pXG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oIG9wLCB7XG4gICAgICByZW5kZXJpbmdCdW1wIDogZmFsc2UsXG4gICAgICBlbWl0dGluZ0RlY2wgIDogZmFsc2UsXG4gICAgICB1cGxvYWRpbmcgICAgIDogZmFsc2UsXG4gICAgICB1cGRhdGluZyAgICAgIDogZmFsc2VcbiAgICB9KVxuXG4gICAgbGV0IHJlcGVhdCA9IG51bGxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9wLCAncmVwZWF0Jywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gcmVwZWF0IH0sXG4gICAgICBzZXQodil7IFxuICAgICAgICByZXBlYXQgPSB2XG4gICAgICAgIHRoaXMuYS5yZXBlYXQgPSB2XG4gICAgICAgIHRoaXMuYi5yZXBlYXQgPSB2XG4gICAgICB9XG4gICAgfSlcblxuICAgIG9wLm1hdElkID0gTWF0ZXJpYWxJRC5hbGxvYygpXG5cbiAgICBvcC5wYXJhbXMgPSBbe25hbWU6J2MnfSx7IG5hbWU6J2QnfV1cbiAgICBvcC5fX2Rlc2MgPSB7IHBhcmFtZXRlcnM6IG9wLnBhcmFtcyB9XG5cbiAgICByZXR1cm4gb3BcbiAgfSBcbiAgXG4gIERpc3RhbmNlT3BzWyBuYW1lMiBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgLy8gYWNjZXB0cyB1bmxpbWl0ZWQgYXJndW1lbnRzLCBidXQgdGhlIGxhc3Qgb25lIGNvdWxkIGJlIGEgYmxlbmRpbmcgY29lZmZpY2llbnRcbiAgICBsZXQgYmxlbmQgPSAuMjUsIGNvZWZmPTQsIHVcblxuICAgIGlmKCB0eXBlb2YgYXJnc1sgYXJncy5sZW5ndGggLSAxIF0gPT09ICdudW1iZXInICkge1xuICAgICAgYmxlbmQgPSBhcmdzLnBvcCgpXG5cbiAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gbm9uLXNkZiBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLi4uXG4gICAgICBpZiggdHlwZW9mIGFyZ3NbIGFyZ3MubGVuZ3RoIC0gMSBdID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgY29lZmYgPSBibGVuZFxuICAgICAgICBibGVuZCA9IGFyZ3MucG9wKClcbiAgICAgIH1cblxuICAgICAgdSA9IGFyZ3MucmVkdWNlKCAoc3RhdGUsbmV4dCkgPT4gRGlzdGFuY2VPcHNbIG5hbWUgXSggc3RhdGUsIG5leHQsIGJsZW5kLCBjb2VmZiApIClcbiAgICB9ZWxzZXtcbiAgICAgIHUgPSBhcmdzLnJlZHVjZSggKHN0YXRlLG5leHQpID0+IERpc3RhbmNlT3BzWyBuYW1lIF0oIHN0YXRlLCBuZXh0ICkgKVxuICAgIH1cblxuICAgIHJldHVybiB1XG4gIH1cblxuICBEaXN0YW5jZU9wc1sgbmFtZSBdLnByb3RvdHlwZSA9IFNjZW5lTm9kZSgpXG5cbiAgRGlzdGFuY2VPcHNbIG5hbWUgXS5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgIHRoaXMuX19zZXRUZXh0dXJlKCAuLi5hcmdzIClcbiAgICB0aGlzLmEudGV4dHVyZSggdGhpcy5fX3RleHR1cmVPYmogKVxuICAgIHRoaXMuYi50ZXh0dXJlKCB0aGlzLl9fdGV4dHVyZU9iaiApXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlLm1hdGVyaWFsID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgdGhpcy5fX3NldE1hdGVyaWFsKCAuLi5hcmdzIClcbiAgICB0aGlzLmEubWF0ZXJpYWwoIHRoaXMuX19tYXRlcmlhbCApXG4gICAgdGhpcy5iLm1hdGVyaWFsKCB0aGlzLl9fbWF0ZXJpYWwgKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNvbnN0IHB1c2hTdHJpbmcgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgICBjb25zdCBnbHNsb2JqID0gZ2xzbG9wc1sgbmFtZSBdXG4gICAgXG4gICAgLy8gc29tZSBkZWZpbml0aW9ucyBhcmUgYSBzaW5nbGUgc3RyaW5nLCBhbmQgbm90IHNwbGl0IGludG9cbiAgICAvLyBzZXBhcmF0ZSBmbG9hdCBhbmQgb3BPdXQgZnVuY3Rpb25zXG4gICAgaWYoIHR5cGVvZiBnbHNsb2JqID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGlmKCBEaXN0YW5jZU9wcy5fX2dsc2wuaW5kZXhPZiggZ2xzbG9iaiApID09PSAtMSApIHtcbiAgICAgICAgRGlzdGFuY2VPcHMuX19nbHNsLnB1c2goIGdsc2xvYmogKVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgLy8gc29tZSBkaXN0YW5jZSBvcGVyYXRpb25zIGFyZSBkZXBlbmRlbnQgb24gb3RoZXIgb25lcy4uLlxuICAgICAgLy8gaWYgdGhpcyBvbmUgaGFzIGRlcGVuZGVuY2llcyBhZGQgdGhlbS5cbiAgICAgIC8vIGRlcGVuZGVuY2llcyBtdXN0IGJlIGFkZGVkIGJlZm9yZSBhZGRpbmcgb3RoZXIgZnVuY3Rpb25zXG4gICAgICAvLyBzbyB0aGF0IHRoZXkncmUgYWJvdmUgdGhlbSBpbiB0aGUgZmluYWwgR0xTTCBjb2RlLlxuICAgICAgaWYoIGdsc2xvYmouZGVwZW5kZW5jaWVzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGZvciggbGV0IGRuYW1lIG9mIGdsc2xvYmouZGVwZW5kZW5jaWVzICkge1xuICAgICAgICAgIGNvbnN0IGQgPSBnbHNsb3BzWyBkbmFtZSBdXG4gICAgICAgICAgaWYoIERpc3RhbmNlT3BzLl9fZ2xzbC5pbmRleE9mKCBkLmZsb2F0ICkgPT09IC0xICkge1xuICAgICAgICAgICAgRGlzdGFuY2VPcHMuX19nbHNsLnB1c2goIGQuZmxvYXQgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAgXG4gICAgICBpZiggRGlzdGFuY2VPcHMuX19nbHNsLmluZGV4T2YoIGdsc2xvYmouZmxvYXQgKSA9PT0gLTEgKSB7XG4gICAgICAgIERpc3RhbmNlT3BzLl9fZ2xzbC5wdXNoKCBnbHNsb2JqLmZsb2F0IClcbiAgICAgIH1cbiAgICAgIGlmKCBEaXN0YW5jZU9wcy5fX2dsc2wuaW5kZXhPZiggZ2xzbG9iai52ZWMyKSA9PT0gLTEgKSB7XG4gICAgICAgIERpc3RhbmNlT3BzLl9fZ2xzbC5wdXNoKCBnbHNsb2JqLnZlYzIgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoIHBuYW1lPSdwJywgdHJhbnNmb3JtID0gbnVsbCApe1xuICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmVuZGVyaW5nQnVtcCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmVuZGVyaW5nQnVtcCA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzLl9fYnVtcE9iai5lbWl0KCBwbmFtZSwgdHJhbnNmb3JtIClcbiAgICB9XG4gICAgcHVzaFN0cmluZyggbmFtZSApXG5cbiAgICBpZiggdHJhbnNmb3JtICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgIC8vdGhpcy50cmFuc2Zvcm0uaW50ZXJuYWwoKVxuXG4gICAgLy8gZmlyc3QgdHdvIGFyZ3MgYXJlIGZpeGVkLCByZXN0IGFyZSB2YXJpYWJsZVxuICAgIGxldCBlbWl0dGVycyA9IFtdXG4gICAgY29uc3QgYSA9IHRoaXMuYS5lbWl0KCBwbmFtZSwgdGhpcy50cmFuc2Zvcm0gKSwgXG4gICAgICAgICAgYiA9IHRoaXMuYi5lbWl0KCBwbmFtZSwgdGhpcy50cmFuc2Zvcm0gKSBcblxuICAgIGVtaXR0ZXJzWzBdID0gYS5vdXRcbiAgICBlbWl0dGVyc1sxXSA9IGIub3V0XG4gICAgaWYoIHRoaXMuX19sZW4gPiAyICkgZW1pdHRlcnMucHVzaCggdGhpcy5jLmVtaXQoKSApXG4gICAgaWYoIHRoaXMuX19sZW4gPiAzICkgZW1pdHRlcnMucHVzaCggdGhpcy5kLmVtaXQoKSApXG4gICAgXG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdmVjMiBkbyR7dGhpcy5pZH0gPSAke29wKCAuLi5lbWl0dGVycyApfTtcbiAgICAgICAgZG8ke3RoaXMuaWR9LnggKj0gJHt0aGlzLnRyYW5zZm9ybS5lbWl0KCl9X3NjYWxlO1xuICAgIGBcblxuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIG91dDogJ2RvJyt0aGlzLmlkLFxuICAgICAgcHJlZmFjZTogKGEucHJlZmFjZSB8fCAnJykgKyAoYi5wcmVmYWNlIHx8ICcnKSArIGJvZHlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmluZ0J1bXAgPSBmYWxzZVxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS5lbWl0X2RlY2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5lbWl0dGluZ0RlY2wgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzLl9fYnVtcE9iai5lbWl0X2RlY2woKSBcbiAgICB9XG4gICAgbGV0IHN0ciA9ICB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKSArIHRoaXMuYS5lbWl0X2RlY2woKSArIHRoaXMuYi5lbWl0X2RlY2woKVxuICAgIGlmKCB0aGlzLmMgIT09IHVuZGVmaW5lZCApIHN0ciArPSB0aGlzLmMuZW1pdF9kZWNsKClcbiAgICBpZiggdGhpcy5kICE9PSB1bmRlZmluZWQgKSBzdHIgKz0gdGhpcy5kLmVtaXRfZGVjbCgpXG5cbiAgICBpZiggb3BzWyBuYW1lIF0uY29kZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgLy9zdHIgKz0gb3BzWyBuYW1lIF0uY29kZVxuICAgICAgaWYoIE1hcmNoaW5nLnJlcXVpcmVkT3BzLmluZGV4T2YoIG9wc1sgbmFtZSBdLmNvZGUgKSA9PT0gLSAxICkge1xuICAgICAgICBNYXJjaGluZy5yZXF1aXJlZE9wcy5wdXNoKCBvcHNbIG5hbWUgXS5jb2RlIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IGZhbHNlXG4gICAgcmV0dXJuIHN0clxuICB9O1xuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS51cGRhdGVfbG9jYXRpb24gPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMudXBkYXRpbmcgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnVwZGF0aW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIH1cbiAgICB0aGlzLmEudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgdGhpcy5iLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIGlmKCB0aGlzLmMgIT09IHVuZGVmaW5lZCApIHRoaXMuYy51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICBpZiggdGhpcy5kICE9PSB1bmRlZmluZWQgKSB0aGlzLmQudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG5cbiAgICB0aGlzLnVwZGF0aW5nID0gZmFsc2VcbiAgfVxuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS51cGxvYWRfZGF0YSA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cGxvYWRpbmcgID09PSBmYWxzZSApIHtcbiAgICAgIHRoaXMudXBsb2FkaW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtLmludGVybmFsKClcbiAgICB0aGlzLnRyYW5zZm9ybS51cGxvYWRfZGF0YSggZ2wgKVxuICAgIHRoaXMuYS50cmFuc2Zvcm0uYXBwbHkoIHRoaXMudHJhbnNmb3JtIClcbiAgICB0aGlzLmIudHJhbnNmb3JtLmFwcGx5KCB0aGlzLnRyYW5zZm9ybSApXG4gICAgdGhpcy5hLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgdGhpcy5iLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgaWYoIHRoaXMuYyAhPT0gdW5kZWZpbmVkICkgdGhpcy5jLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgaWYoIHRoaXMuZCAhPT0gdW5kZWZpbmVkICkgdGhpcy5kLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgdGhpcy51cGxvYWRpbmcgPSBmYWxzZVxuICAgIFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VPcHNcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgb3BVKCBmbG9hdCBkMSwgZmxvYXQgZDIgKSB7XG4gICAgICAgIHJldHVybiBtaW4oZDEsZDIpO1xuICAgICAgfVxuICAgICAgYCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgb3BVKCB2ZWMyIGQxLCB2ZWMyIGQyICkge1xuICAgICAgICB2ZWMyIG87XG5cbiAgICAgICAgaWYoIGQxLnggPCBkMi54ICkge1xuICAgICAgICAgIG8gPSBkMTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbyA9IGQyOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBJbnRlcnNlY3Rpb246e1xuICAgIGZsb2F0OmBcbiAgICAgIGZsb2F0IG9wSSggZmxvYXQgZDEsIGZsb2F0IGQyICkge1xuICAgICAgICByZXR1cm4gbWF4KGQxLGQyKTtcbiAgICAgIH1cbiAgICAgIGAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIG9wSSggdmVjMiBkMSwgdmVjMiBkMiAgKSB7XG4gICAgICAgIHZlYzIgbztcblxuICAgICAgICBpZiggZDEueCA+IGQyLnggKSB7XG4gICAgICAgICAgbyA9IGQxOyBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbyA9IGQyOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIERpZmZlcmVuY2U6e1xuICAgIGZsb2F0OmBcbiAgICAgIGZsb2F0IG9wUyggZmxvYXQgZDEsIGZsb2F0IGQyICkgeyByZXR1cm4gbWF4KGQxLC1kMik7IH1cbiAgICAgIGAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIG9wUyggdmVjMiBkMSwgdmVjMiBkMiAgKSB7XG4gICAgICAgIHZlYzIgbztcblxuICAgICAgICBpZiggZDEueCA+PSAtZDIueCApIHtcbiAgICAgICAgICBvID0gZDE7IFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBkMi54ICo9IC0xLjtcbiAgICAgICAgICBvID0gZDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGBcbiAgfSxcblxuICBTdGFpcnNVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wVW5pb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICBmbG9hdCBzID0gci9uO1xuICAgICAgICBmbG9hdCB1ID0gYi1yO1xuICAgICAgICByZXR1cm4gbWluKG1pbihhLGIpLCAwLjUgKiAodSArIGEgKyBhYnMgKChtb2QgKHUgLSBhICsgcywgMi4gKiBzKSkgLSBzKSkpO1xuICAgICAgfWAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcFVuaW9uU3RhaXJzKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByLCBmbG9hdCBuICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG5cbiAgICAgICAgaWYoIGQxLnggPD0gZDIueCApIHtcbiAgICAgICAgICBvLnkgPSBkMS55OyBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTsgXG4gICAgICAgIH1cblxuICAgICAgICBvLnggPSBmT3BVbmlvblN0YWlycyggZDEueCwgZDIueCwgciwgbiApO1xuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBTdGFpcnNJbnRlcnNlY3Rpb246e1xuICAgIGRlcGVuZGVuY2llczogWydTdGFpcnNVbmlvbiddLFxuICAgIGZsb2F0OmBcbiAgICAgIC8vIFdlIGNhbiBqdXN0IGNhbGwgVW5pb24gc2luY2Ugc3RhaXJzIGFyZSBzeW1tZXRyaWMuXG4gICAgICBmbG9hdCBmT3BJbnRlcnNlY3Rpb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICByZXR1cm4gLWZPcFVuaW9uU3RhaXJzKC1hLCAtYiwgciwgbik7XG4gICAgICB9XG4gICAgICBgLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BJbnRlcnNlY3Rpb25TdGFpcnMoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gLWZPcFVuaW9uU3RhaXJzKCAtZDEueCwgLWQyLngsIHIsIG4gKTtcblxuICAgICAgICBpZiggLWQxLnggPD0gLWQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBTdGFpcnNEaWZmZXJlbmNlOntcbiAgICBkZXBlbmRlbmNpZXM6IFsnU3RhaXJzVW5pb24nXSxcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BTdWJzdHJhY3Rpb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICByZXR1cm4gLWZPcFVuaW9uU3RhaXJzKC1hLCBiLCByLCBuKTtcbiAgICAgIH1gLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BTdWJzdHJhY3Rpb25TdGFpcnMoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gLWZPcFVuaW9uU3RhaXJzKCAtZDEueCwgZDIueCwgciwgbiApO1xuXG4gICAgICAgIGlmKCAtZDEueCA8PSBkMi54ICkge1xuICAgICAgICAgIG8ueSA9IGQxLnk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIG8ueSA9IGQyLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGBcbiAgfSxcblxuICBSb3VuZFVuaW9uOntcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BVbmlvblJvdW5kKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgdmVjMiB1ID0gbWF4KHZlYzIociAtIGEsciAtIGIpLCB2ZWMyKDApKTtcbiAgICAgICAgcmV0dXJuIG1heChyLCBtaW4gKGEsIGIpKSAtIGxlbmd0aCh1KTtcbiAgICAgIH1gLFxuXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcFVuaW9uUm91bmQoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wVW5pb25Sb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54IDw9IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBSb3VuZEludGVyc2VjdGlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wSW50ZXJzZWN0aW9uUm91bmQoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICB2ZWMyIHUgPSBtYXgodmVjMihyICsgYSxyICsgYiksIHZlYzIoMCkpO1xuICAgICAgICByZXR1cm4gbWluKC1yLCBtYXggKGEsIGIpKSArIGxlbmd0aCh1KTtcbiAgICAgIH1gLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BJbnRlcnNlY3Rpb25Sb3VuZCggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BJbnRlcnNlY3Rpb25Sb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIFJvdW5kRGlmZmVyZW5jZTp7XG4gICAgZGVwZW5kZW5jaWVzOiBbJ1JvdW5kSW50ZXJzZWN0aW9uJ10sXG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wRGlmZmVyZW5jZVJvdW5kIChmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCByKSB7XG4gICAgICAgIHJldHVybiBmT3BJbnRlcnNlY3Rpb25Sb3VuZChhLCAtYiwgcik7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wRGlmZmVyZW5jZVJvdW5kKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcERpZmZlcmVuY2VSb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IC1kMi54ICkge1xuICAgICAgICAgIG8ueSA9IGQxLnk7IFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBvLnkgPSBkMi55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgXG4gIH0sXG4gIENoYW1mZXJVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wVW5pb25DaGFtZmVyKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIG1pbihtaW4oYSwgYiksIChhIC0gciArIGIpKnNxcnQoMC41KSk7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wVW5pb25DaGFtZmVyKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcFVuaW9uQ2hhbWZlciggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54IDw9IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBDaGFtZmVySW50ZXJzZWN0aW9uOntcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BJbnRlcnNlY3Rpb25DaGFtZmVyKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIG1heChtYXgoYSwgYiksIChhICsgciArIGIpKnNxcnQoMC41KSk7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wSW50ZXJzZWN0aW9uQ2hhbWZlciggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wSW50ZXJzZWN0aW9uQ2hhbWZlciggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIENoYW1mZXJEaWZmZXJlbmNlOntcbiAgICBkZXBlbmRlbmNpZXM6WydDaGFtZmVySW50ZXJzZWN0aW9uJ10sXG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wRGlmZmVyZW5jZUNoYW1mZXIgKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIGZPcEludGVyc2VjdGlvbkNoYW1mZXIoYSwgLWIsIHIpO1xuICAgICAgfWAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcERpZmZlcmVuY2VDaGFtZmVyKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcERpZmZlcmVuY2VDaGFtZmVyKCBkMS54LCBkMi54LCByICk7XG5cbiAgICAgICAgaWYoIGQxLnggPj0gLWQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBQaXBlOmBcbiAgICAgIGZsb2F0IGZPcFBpcGUoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoKHZlYzIoYSwgYikpIC0gcjtcbiAgICAgIH1cbiAgICAgIHZlYzIgZk9wUGlwZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wUGlwZSggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYCxcblxuICBFbmdyYXZlOmBcbiAgICAgIGZsb2F0IGZPcEVuZ3JhdmUoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICByZXR1cm4gbWF4KGEsIChhICsgciAtIGFicyhiKSkqc3FydCgwLjUpKTtcbiAgICAgIH1cbiAgICAgIHZlYzIgZk9wRW5ncmF2ZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BFbmdyYXZlKCBkMS54LCBkMi54LCByICk7XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgLFxuICBHcm9vdmU6YFxuICAgICAgZmxvYXQgZk9wR3Jvb3ZlKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHJhLCBmbG9hdCByYikge1xuICAgICAgICByZXR1cm4gbWF4KGEsIG1pbihhICsgcmEsIHJiIC0gYWJzKGIpKSk7XG4gICAgICB9XG4gICAgICB2ZWMyIGZPcEdyb292ZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciwgZmxvYXQgbiAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BHcm9vdmUoIGQxLngsIGQyLngsIHIsIG4gKTtcblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGAsXG5cbiAgVG9uZ3VlOmBcbiAgICAgIGZsb2F0IGZPcFRvbmd1ZShmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCByYSwgZmxvYXQgcmIpIHtcbiAgICAgICAgcmV0dXJuIG1pbihhLCBtYXgoYSAtIHJhLCBhYnMoYikgLSByYikpO1xuICAgICAgfVxuICAgICAgdmVjMiBmT3BUb25ndWUoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wVG9uZ3VlKCBkMS54LCBkMi54LCByLCBuICk7XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgLFxuICBPbmlvbjpgXG4gICAgICBmbG9hdCBvcE9uaW9uKCBpbiBmbG9hdCBzZGYsIGluIGZsb2F0IHRoaWNrbmVzcyApe1xuICAgICAgICByZXR1cm4gYWJzKHNkZiktdGhpY2tuZXNzO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCBvcEhhbHZlKCBpbiBmbG9hdCBzZGYsIHZlYzMgcCwgaW4gaW50IGRpciApe1xuICAgICAgICBmbG9hdCBfb3V0ID0gMC47XG4gICAgICAgIHN3aXRjaCggZGlyICkge1xuICAgICAgICAgIGNhc2UgMDogIFxuICAgICAgICAgICAgX291dCA9IG1heCggc2RmLCBwLnkgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9vdXQgPSBtYXgoIHNkZiwgLXAueSApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX291dCA9IG1heCggc2RmLCBwLnggKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9vdXQgPSBtYXgoIHNkZiwgLXAueCApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX291dDtcbiAgICAgIH1cbiAgICAgIGAsXG5cbiAgU3dpdGNoOmBcbiAgICAgIHZlYzIgb3BTd2l0Y2goIHZlYzIgYSwgdmVjMiBiLCBmbG9hdCBjICkge1xuICAgICAgICBpZiggYyA8IC41ICkge1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICAgIGBcbn1cbiIsImNvbnN0IHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuLCBpbnRfdmFyX2dlbiwgVmFyQWxsb2MgfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSggJy4vdHJhbnNmb3JtLmpzJyApXG5cbmNvbnN0IGRlc2NyaXB0aW9ucyA9IHtcbiAgRWxvbmdhdGlvbjoge1xuICAgIHBhcmFtZXRlcnM6WyB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMygwKSB9IF0sXG4gICAgZnVuYzpgXG4gICAgICB2ZWM0IG9wRWxvbmdhdGUoIGluIHZlYzMgcCwgaW4gdmVjMyBoICkge1xuICAgICAgICAvL3JldHVybiB2ZWM0KCBwLWNsYW1wKHAsLWgsaCksIDAuMCApOyAvLyBmYXN0ZXIsIGJ1dCBwcm9kdWNlcyB6ZXJvIGluIHRoZSBpbnRlcmlvciBlbG9uZ2F0ZWQgYm94XG4gICAgICAgIFxuICAgICAgICB2ZWMzIHEgPSBhYnMocCktaDtcbiAgICAgICAgcmV0dXJuIHZlYzQoIG1heChxLDAuMCksIG1pbihtYXgocS54LG1heChxLnkscS56KSksMC4wKSApO1xuICAgICAgfWAsXG4gICAgZW1pdCggbmFtZT0ncCcgKSB7XG4gICAgICBjb25zdCBwSWQgPSB0aGlzLmdldElEKClcbiAgICAgIGNvbnN0IHBOYW1lID0gJ3AnICsgcElkXG5cbiAgICAgIGxldCBwcmVmYWNlID1cbiAgICAgICAgYCAgICAgICAgdmVjNCAke3BOYW1lfV94eXp3ID0gb3BFbG9uZ2F0ZSggJHtuYW1lfSwgJHt0aGlzLmRpc3RhbmNlLmVtaXQoKX0gKTtcXG5cbiAgICAgICAgdmVjMyAke3BOYW1lfSA9ICR7cE5hbWV9X3h5encueHl6O1xcbmBcblxuXG4gICAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCBwTmFtZSApXG5cbiAgICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkgcHJlZmFjZSArPSBzZGYucHJlZmFjZSBcblxuICAgICAgcmV0dXJuIHsgb3V0OmB2ZWMyKCR7cE5hbWV9X3h5encudyArICR7c2RmLm91dH0ueCwgJHtzZGYub3V0fS55KWAsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgUG9sYXJSZXBldGl0aW9uOiB7XG4gICAgcGFyYW1ldGVyczpbIFxuICAgICAgeyBuYW1lOidjb3VudCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgICB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMyguMjUpIH0sXG5cbiAgICBdLFxuICAgIGVtaXQoIG5hbWU9J3AnLCB0cmFuc2Zvcm09bnVsbCkge1xuICAgICAgY29uc3QgcElkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgICAgY29uc3QgcE5hbWUgPSAncCcgKyBwSWRcbiAgICAgIGNvbnN0IHBvaW50U3RyaW5nID0gIGAoICR7bmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX0gKS54eXpgXG5cbiAgICAgIGlmKCB0cmFuc2Zvcm0gIT09IG51bGwgKSB0aGlzLnRyYW5zZm9ybS5hcHBseSggdHJhbnNmb3JtLCBmYWxzZSApXG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKVxuXG4gICAgICBsZXQgcHJlZmFjZSA9YFxuICAgICAgICAgIHZlYzQgJHtwTmFtZX0gPSB2ZWM0KCBwb2xhclJlcGVhdCggJHtwb2ludFN0cmluZ30sICR7dGhpcy5fX3RhcmdldC5jb3VudC5lbWl0KCkgfSApLCAxLiApOyBcbiAgICAgICAgICAke3BOYW1lfSAtPSB2ZWM0KCR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9LngsMC4sMC4sMC4pO1xcbmBcblxuICAgICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKVxuXG4gICAgICBpZiggdHlwZW9mIHNkZi5wcmVmYWNlID09PSAnc3RyaW5nJyApIHByZWZhY2UgKz0gc2RmLnByZWZhY2VcblxuICAgICAgcmV0dXJuIHsgb3V0OnNkZi5vdXQsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgTWlycm9yOiB7XG4gICAgcGFyYW1ldGVyczogWyB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMygwKSB9IF0sXG4gICAgZXh0cmE6W3sgbmFtZTonZGltcycsIHR5cGU6J2xvY2FsJywgZGVmYXVsdDoneHl6JyB9XSxcblxuICAgIGVtaXQoIG5hbWU9J3AnLCB0cmFuc2Zvcm09bnVsbCwgbm90dXNlZD1udWxsLCBzY2FsZT1udWxsICkge1xuICAgICAgY29uc3QgcElkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgICAgY29uc3QgcE5hbWUgPSAncCcgKyBwSWRcblxuICAgICAgaWYoIHRyYW5zZm9ybSAhPT0gbnVsbCApIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm0uaW52ZXJ0KClcbiAgICAgXG4gICAgICBjb25zdCBwb2ludFN0cmluZyA9ICBgKCAke25hbWV9ICogJHt0aGlzLnRyYW5zZm9ybS5lbWl0KCl9ICkueHl6YCxcbiAgICAgICAgICAgIHMgPSBzY2FsZSA9PT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKSA6IGAke3RoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKX0gKiAke3NjYWxlfWBcbiBcbiAgICAgIGxldCBwcmVmYWNlID1gXG4gICAgICAgIHZlYzQgJHtwTmFtZX0gPSB2ZWM0KCAoICR7cG9pbnRTdHJpbmd9ICkgLCAxLik7XFxuXG4gICAgICAgICR7cE5hbWV9LiR7dGhpcy5kaW1zfSA9IGFicyggJHtwTmFtZX0uJHt0aGlzLmRpbXN9ICk7XFxuYFxuXG4gICAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCBwTmFtZSwgbnVsbCwgbnVsbCwgcyApXG5cbiAgICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkgcHJlZmFjZSArPSBzZGYucHJlZmFjZSBcblxuICAgICAgcmV0dXJuIHsgb3V0OnNkZi5vdXQsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgLy9sZXQgcHJlZmFjZSA9IGAgICAgICAgICB2ZWMzICR7cE5hbWV9ID0gJHtuYW1lfSAvICR7dGhpcy5hbW91bnQuZW1pdCgpfTtcXG5gXG5cbiAgLy9sZXQgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKVxuICAvL2xldCBvdXQgPSBzZGYub3V0IFxuXG4gIC8vc2RmLnByZWZhY2UgKz0gYCAgICAgICR7b3V0fS54ID0gJHtvdXR9LnggKiAke3RoaXMuYW1vdW50LmVtaXQoKX07XFxuYFxuXG4gIC8vaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSBwcmVmYWNlICs9IHNkZi5wcmVmYWNlXG4gIFJlcGV0aXRpb246IHtcbiAgICBwYXJhbWV0ZXJzOiBbIHsgbmFtZTonZGlzdGFuY2UnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpWZWMzKDApIH0gXSxcbiAgICBlbWl0KCBuYW1lPSdwJywgdHJhbnNmb3JtPW51bGwgKSB7XG4gICAgICBjb25zdCBwSWQgPSBWYXJBbGxvYy5hbGxvYygpXG4gICAgICBjb25zdCBwTmFtZSA9ICdwJyArIHBJZFxuXG4gICAgICBpZiggdHJhbnNmb3JtICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgICAgXG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKVxuICAgICBcbiAgICAgIGNvbnN0IHBvaW50U3RyaW5nID0gIGAoICR7bmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX0gKS54eXpgO1xuXG4gICAgICBsZXQgcHJlZmFjZSA9YFxuICAgICAgICB2ZWM0ICR7cE5hbWV9ID0gdmVjNCggKG1vZCggJHtwb2ludFN0cmluZ30sICR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9ICkgLSAuNSAqICR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9KSAqICR7dGhpcy50cmFuc2Zvcm0uZW1pdF9zY2FsZSgpfSwgMS4pO1xcbmBcblxuICAgICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKS8vLCB0aGlzLnRyYW5zZm9ybSApLy8sIDEsIHRoaXMuX190YXJnZXQuZGlzdGFuY2UgKVxuXG4gICAgICBpZiggdHlwZW9mIHNkZi5wcmVmYWNlID09PSAnc3RyaW5nJyApIHByZWZhY2UgKz0gc2RmLnByZWZhY2UgXG5cbiAgICAgIHJldHVybiB7IG91dDpzZGYub3V0LCBwcmVmYWNlIH1cbiAgICB9XG4gIH0sXG59XG4gIFxuY29uc3QgZ2V0RG9tYWluT3BzID0gZnVuY3Rpb24oIFNERiApIHtcbiAgY29uc3Qgb3BzID0ge31cblxuICBmb3IoIGxldCBrZXkgaW4gZGVzY3JpcHRpb25zICkge1xuICAgIGNvbnN0IG9wRGVzYyA9IGRlc2NyaXB0aW9uc1sga2V5IF1cbiAgICBcbiAgICBvcHNbIGtleSBdID0gZnVuY3Rpb24oIHNkZiwgLi4uYXJncyApIHtcbiAgICAgIGNvbnN0IG9wID0gT2JqZWN0LmNyZWF0ZSggb3BzWyBrZXkgXS5wcm90b3R5cGUgKVxuICAgICAgb3Auc2RmID0gc2RmXG4gICAgICBvcC5wYXJhbWV0ZXJzID0gW11cbiAgICAgIG9wLnRyYW5zZm9ybSA9IFRyYW5zZm9ybSgpXG4gICAgICBjb25zdCB0YXJnZXQgPSBvcC5fX3RhcmdldCA9IG9wIC8vIHNkZi5fX3RhcmdldCAhPT0gdW5kZWZpbmVkID8gc2RmLl9fdGFyZ2V0IDogb3BcblxuICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgZm9yKCBsZXQgcHJvcCBvZiBvcERlc2MucGFyYW1ldGVycyApIHtcbiAgICAgICAgb3AucGFyYW1ldGVycy5wdXNoKHsgbmFtZTpwcm9wLm5hbWUgfSlcblxuICAgICAgICBsZXQgYXJnID0gYXJnc1sgY291bnQgXVxuICAgICAgICBsZXQgX192YXJcblxuICAgICAgICBzd2l0Y2goIHByb3AudHlwZSApIHtcbiAgICAgICAgICBjYXNlICd2ZWMyJzpcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyApIGFyZyA9IFZlYzIoIGFyZyApXG4gICAgICAgICAgICBpZiggYXJnID09PSB1bmRlZmluZWQgKSBhcmcgPSBwcm9wLmRlZmF1bHQuY29weSgpXG5cbiAgICAgICAgICAgIF9fdmFyID0gcGFyYW1fd3JhcCggXG4gICAgICAgICAgICAgIGFyZywgXG4gICAgICAgICAgICAgIHZlYzJfdmFyX2dlbiggcHJvcC5kZWZhdWx0ICkgICAgXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGFyZ2V0LCBwcm9wLm5hbWUsIHtcbiAgICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIgfSxcbiAgICAgICAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgX192YXIuc2V0KCB2IClcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS55ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSAgXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgICAgICAgaWYoIHR5cGVvZiBhcmcgPT09ICdudW1iZXInICkgYXJnID0gVmVjMyggYXJnIClcbiAgICAgICAgICAgIGlmKCBhcmcgPT09IHVuZGVmaW5lZCApIGFyZyA9IHByb3AuZGVmYXVsdC5jb3B5KClcblxuICAgICAgICAgICAgX192YXIgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgICAgYXJnLCBcbiAgICAgICAgICAgICAgdmVjM192YXJfZ2VuKCBwcm9wLmRlZmF1bHQgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgcHJvcC5uYW1lLCB7XG4gICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS54ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnogPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci5kaXJ0eSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pICBcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmVjNCc6XG4gICAgICAgICAgICBpZiggdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgKSBhcmcgPSBWZWM0KCBhcmcgKVxuICAgICAgICAgICAgICBfX3ZhciA9IHBhcmFtX3dyYXAoIFxuICAgICAgICAgICAgICBhcmcsIFxuICAgICAgICAgICAgICB2ZWM0X3Zhcl9nZW4oIHByb3AuZGVmYXVsdCApICBcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYoIGFyZyA9PT0gdW5kZWZpbmVkICkgYXJnID0gcHJvcC5kZWZhdWx0LmNvcHkoKVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgcHJvcC5uYW1lLCB7XG4gICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS54ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnogPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS53ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSAgXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IC8vIGZsb2F0XG4gICAgICAgICAgICBfX3ZhciA9ICBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgICAgYXJnLCBcbiAgICAgICAgICAgICAgZmxvYXRfdmFyX2dlbiggcHJvcC5kZWZhdWx0IClcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0YXJnZXQsIHByb3AubmFtZSwge1xuICAgICAgICAgICAgICBnZXQoKSB7IHJldHVybiBfX3ZhciB9LFxuICAgICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjb3VudCsrXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBvcERlc2MuZXh0cmEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgZm9yKCBsZXQgZXh0cmEgb2Ygb3BEZXNjLmV4dHJhICkge1xuICAgICAgICAgIG9wWyBleHRyYS5uYW1lIF0gPSBhcmdzWyBjb3VudCAtIDEgXSB8fCBleHRyYS5kZWZhdWx0XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3AuX19zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgdGV4ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUgPSBvcC50ZXh0dXJlLmJpbmQoIHRoaXMgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlT2JqID0gdGhpcy50ZXggPSBNYXJjaGluZy5UZXh0dXJlKCB0ZXgscHJvcHMsdGhpcy50ZXh0dXJlIClcbiAgICAgICAgICB0aGlzLl9fdGV4dHVyZUlEID0gdGhpcy5fX3RleHR1cmVPYmouaWRcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IE9iamVjdC5hc3NpZ24oIHRleCwgcHJvcHMgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlSUQgPSB0aGlzLl9fdGV4dHVyZU9iai5pZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcC5fX3NldE1hdGVyaWFsID0gZnVuY3Rpb24obWF0KSB7XG4gICAgICAgIGlmKCB0eXBlb2YgbWF0ID09PSAnc3RyaW5nJyApIG1hdCA9IE1hcmNoaW5nLk1hdGVyaWFsWyBtYXQgXVxuICAgICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IE1hcmNoaW5nLm1hdGVyaWFscy5hZGRNYXRlcmlhbCggbWF0IClcbiAgICAgIH1cbiAgICAgIG9wLl9fZGVzYyA9IG9wRGVzY1xuXG4gICAgICBpZigga2V5ICE9PSAnTWlycm9yJyApIG9wLnNkZi5yZXBlYXQgPSBvcFxuICAgICAgcmV0dXJuIG9wXG4gICAgfVxuXG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLmVtaXQgPSBvcERlc2MuZW1pdFxuICAgIFxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLnRleHR1cmUgPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgIHRoaXMuX19zZXRUZXh0dXJlKCAuLi5hcmdzIClcbiAgICAgIHRoaXMuc2RmLnRleHR1cmUoIHRoaXMuX190ZXh0dXJlT2JqIClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUubWF0ZXJpYWwgPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgIHRoaXMuX19zZXRNYXRlcmlhbCggLi4uYXJncyApXG4gICAgICB0aGlzLnNkZi5tYXRlcmlhbCggdGhpcy5fX21hdGVyaWFsIClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBvcHNbIGtleSBdLnByb3RvdHlwZS5lbWl0X2RlY2wgPSBmdW5jdGlvbiggc2hvdWxkRW1pdFNERj10cnVlICkge1xuICAgICAgbGV0IGRlY2wgPSAnJ1xuICAgICAgZGVjbCArPSB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKVxuICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgdGhpcy5wYXJhbWV0ZXJzICkge1xuICAgICAgICBkZWNsICs9IHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS5lbWl0X2RlY2woKSBcbiAgICAgIH1cbiAgICAgIGlmKCBzaG91bGRFbWl0U0RGICkgZGVjbCArPSB0aGlzLnNkZi5lbWl0X2RlY2woKVxuICAgICAgXG4gICAgICAvLyBmb3Igcm90YXRpb24gZXRjLi4uIGFueSBleHRyYSBnbHNsIGZ1bmN0aW9uIHRoYXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIGFkZGVkIHRvIHRoZSBzaGFkZXJcbiAgICAgIGlmKCBvcERlc2MuZ2xzbCAhPT0gdW5kZWZpbmVkICYmIFNERi5tZW1vWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBkZWNsICs9IG9wRGVzYy5nbHNsXG4gICAgICAgIFNERi5tZW1vWyBrZXkgXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY2xcbiAgICB9XG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oIGdsLCBwcm9ncmFtLCBzaG91bGRVcGRhdGVTREY9dHJ1ZSApIHtcbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRoaXMucGFyYW1ldGVycyApIHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtKVxuICAgICAgaWYoIHNob3VsZFVwZGF0ZVNERiApIHRoaXMuc2RmLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgfVxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oIGdsLCBzaG91bGRVcGxvYWRTREY9dHJ1ZSApIHtcbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRoaXMucGFyYW1ldGVycyApIHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgdGhpcy50cmFuc2Zvcm0udXBsb2FkX2RhdGEoIGdsIClcbiAgICAgIGlmKCBzaG91bGRVcGxvYWRTREYgKSB0aGlzLnNkZi51cGxvYWRfZGF0YSggZ2wgKVxuICAgIH1cbiAgfVxuICBcbiAgb3BzLlJlcGVhdCA9IG9wcy5SZXBldGl0aW9uXG4gIG9wcy5SZXBlYXRTY2FsZSA9IG9wcy5SZXBldGl0aW9uU2hyaW5rXG4gIG9wcy5Qb2xhclJlcGVhdCA9IG9wcy5Qb2xhclJlcGV0aXRpb25cblxuICByZXR1cm4gb3BzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RG9tYWluT3BzXG4iLCIvLyBtYXRyaXguanMgLSB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9saWdodGdsLmpzL1xuXG4vLyBSZXByZXNlbnRzIGEgNHg0IG1hdHJpeCBzdG9yZWQgaW4gcm93LW1ham9yIG9yZGVyIHRoYXQgdXNlcyBGbG9hdDMyQXJyYXlzXG4vLyB3aGVuIGF2YWlsYWJsZS4gTWF0cml4IG9wZXJhdGlvbnMgY2FuIGVpdGhlciBiZSBkb25lIHVzaW5nIGNvbnZlbmllbnRcbi8vIG1ldGhvZHMgdGhhdCByZXR1cm4gYSBuZXcgbWF0cml4IGZvciB0aGUgcmVzdWx0IG9yIG9wdGltaXplZCBtZXRob2RzXG4vLyB0aGF0IHN0b3JlIHRoZSByZXN1bHQgaW4gYW4gZXhpc3RpbmcgbWF0cml4IHRvIGF2b2lkIGdlbmVyYXRpbmcgZ2FyYmFnZS5cblxudmFyIGhhc0Zsb2F0MzJBcnJheSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnKTtcblxuLy8gIyMjIG5ldyBHTC5NYXRyaXgoW2VsZW1lbnRzXSlcbi8vXG4vLyBUaGlzIGNvbnN0cnVjdG9yIHRha2VzIDE2IGFyZ3VtZW50cyBpbiByb3ctbWFqb3Igb3JkZXIsIHdoaWNoIGNhbiBiZSBwYXNzZWRcbi8vIGluZGl2aWR1YWxseSwgYXMgYSBsaXN0LCBvciBldmVuIGFzIGZvdXIgbGlzdHMsIG9uZSBmb3IgZWFjaCByb3cuIElmIHRoZVxuLy8gYXJndW1lbnRzIGFyZSBvbWl0dGVkIHRoZW4gdGhlIGlkZW50aXR5IG1hdHJpeCBpcyBjb25zdHJ1Y3RlZCBpbnN0ZWFkLlxuZnVuY3Rpb24gTWF0cml4KCkge1xuICB2YXIgbSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyZ3VtZW50cyk7XG4gIGlmICghbS5sZW5ndGgpIHtcbiAgICBtID0gW1xuICAgICAgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLFxuICAgICAgMCwgMCwgMCwgMVxuICAgIF07XG4gIH1cbiAgdGhpcy5tID0gaGFzRmxvYXQzMkFycmF5ID8gbmV3IEZsb2F0MzJBcnJheShtKSA6IG07XG59XG5cbk1hdHJpeC5wcm90b3R5cGUgPSB7XG4gIC8vICMjIyAuaW52ZXJzZSgpXG4gIC8vXG4gIC8vIFJldHVybnMgdGhlIG1hdHJpeCB0aGF0IHdoZW4gbXVsdGlwbGllZCB3aXRoIHRoaXMgbWF0cml4IHJlc3VsdHMgaW4gdGhlXG4gIC8vIGlkZW50aXR5IG1hdHJpeC5cbiAgaW52ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdHJpeC5pbnZlcnNlKHRoaXMsIG5ldyBNYXRyaXgoKSk7XG4gIH0sXG5cbiAgLy8gIyMjIC50cmFuc3Bvc2UoKVxuICAvL1xuICAvLyBSZXR1cm5zIHRoaXMgbWF0cml4LCBleGNoYW5naW5nIGNvbHVtbnMgZm9yIHJvd3MuXG4gIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdHJpeC50cmFuc3Bvc2UodGhpcywgbmV3IE1hdHJpeCgpKTtcbiAgfSxcblxuICAvLyAjIyMgLm11bHRpcGx5KG1hdHJpeClcbiAgLy9cbiAgLy8gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdHJhbnNmb3JtcyBmb3IgdGhpcyBtYXRyaXggYW5kIGBtYXRyaXhgLlxuICAvLyBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsTXVsdE1hdHJpeCgpYC5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIHJldHVybiBNYXRyaXgubXVsdGlwbHkodGhpcywgbWF0cml4LCBuZXcgTWF0cml4KCkpO1xuICB9LFxuXG4gIC8vICMjIyAudHJhbnNmb3JtUG9pbnQocG9pbnQpXG4gIC8vXG4gIC8vIFRyYW5zZm9ybXMgdGhlIHZlY3RvciBhcyBhIHBvaW50IHdpdGggYSB3IGNvb3JkaW5hdGUgb2YgMS4gVGhpc1xuICAvLyBtZWFucyB0cmFuc2xhdGlvbnMgd2lsbCBoYXZlIGFuIGVmZmVjdCwgZm9yIGV4YW1wbGUuXG4gIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG0gPSB0aGlzLm07XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IoXG4gICAgICBtWzBdICogdi54ICsgbVsxXSAqIHYueSArIG1bMl0gKiB2LnogKyBtWzNdLFxuICAgICAgbVs0XSAqIHYueCArIG1bNV0gKiB2LnkgKyBtWzZdICogdi56ICsgbVs3XSxcbiAgICAgIG1bOF0gKiB2LnggKyBtWzldICogdi55ICsgbVsxMF0gKiB2LnogKyBtWzExXVxuICAgICkuZGl2aWRlKG1bMTJdICogdi54ICsgbVsxM10gKiB2LnkgKyBtWzE0XSAqIHYueiArIG1bMTVdKTtcbiAgfSxcblxuICAvLyAjIyMgLnRyYW5zZm9ybVBvaW50KHZlY3RvcilcbiAgLy9cbiAgLy8gVHJhbnNmb3JtcyB0aGUgdmVjdG9yIGFzIGEgdmVjdG9yIHdpdGggYSB3IGNvb3JkaW5hdGUgb2YgMC4gVGhpc1xuICAvLyBtZWFucyB0cmFuc2xhdGlvbnMgd2lsbCBoYXZlIG5vIGVmZmVjdCwgZm9yIGV4YW1wbGUuXG4gIHRyYW5zZm9ybVZlY3RvcjogZnVuY3Rpb24odikge1xuICAgIHZhciBtID0gdGhpcy5tO1xuICAgIHJldHVybiBuZXcgVmVjdG9yKFxuICAgICAgbVswXSAqIHYueCArIG1bMV0gKiB2LnkgKyBtWzJdICogdi56LFxuICAgICAgbVs0XSAqIHYueCArIG1bNV0gKiB2LnkgKyBtWzZdICogdi56LFxuICAgICAgbVs4XSAqIHYueCArIG1bOV0gKiB2LnkgKyBtWzEwXSAqIHYuelxuICAgICk7XG4gIH1cbn07XG5cbi8vICMjIyBHTC5NYXRyaXguaW52ZXJzZShtYXRyaXhbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgdGhlIG1hdHJpeCB0aGF0IHdoZW4gbXVsdGlwbGllZCB3aXRoIGBtYXRyaXhgIHJlc3VsdHMgaW4gdGhlXG4vLyBpZGVudGl0eSBtYXRyaXguIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YFxuLy8gdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgZnJvbSB0aGUgTWVzYVxuLy8gT3BlbkdMIGZ1bmN0aW9uIGBfX2dsdUludmVydE1hdHJpeGQoKWAgZm91bmQgaW4gYHByb2plY3QuY2AuXG5NYXRyaXguaW52ZXJzZSA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBtID0gbWF0cml4Lm0sIHIgPSByZXN1bHQubTtcblxuICByWzBdID0gbVs1XSptWzEwXSptWzE1XSAtIG1bNV0qbVsxNF0qbVsxMV0gLSBtWzZdKm1bOV0qbVsxNV0gKyBtWzZdKm1bMTNdKm1bMTFdICsgbVs3XSptWzldKm1bMTRdIC0gbVs3XSptWzEzXSptWzEwXTtcbiAgclsxXSA9IC1tWzFdKm1bMTBdKm1bMTVdICsgbVsxXSptWzE0XSptWzExXSArIG1bMl0qbVs5XSptWzE1XSAtIG1bMl0qbVsxM10qbVsxMV0gLSBtWzNdKm1bOV0qbVsxNF0gKyBtWzNdKm1bMTNdKm1bMTBdO1xuICByWzJdID0gbVsxXSptWzZdKm1bMTVdIC0gbVsxXSptWzE0XSptWzddIC0gbVsyXSptWzVdKm1bMTVdICsgbVsyXSptWzEzXSptWzddICsgbVszXSptWzVdKm1bMTRdIC0gbVszXSptWzEzXSptWzZdO1xuICByWzNdID0gLW1bMV0qbVs2XSptWzExXSArIG1bMV0qbVsxMF0qbVs3XSArIG1bMl0qbVs1XSptWzExXSAtIG1bMl0qbVs5XSptWzddIC0gbVszXSptWzVdKm1bMTBdICsgbVszXSptWzldKm1bNl07XG5cbiAgcls0XSA9IC1tWzRdKm1bMTBdKm1bMTVdICsgbVs0XSptWzE0XSptWzExXSArIG1bNl0qbVs4XSptWzE1XSAtIG1bNl0qbVsxMl0qbVsxMV0gLSBtWzddKm1bOF0qbVsxNF0gKyBtWzddKm1bMTJdKm1bMTBdO1xuICByWzVdID0gbVswXSptWzEwXSptWzE1XSAtIG1bMF0qbVsxNF0qbVsxMV0gLSBtWzJdKm1bOF0qbVsxNV0gKyBtWzJdKm1bMTJdKm1bMTFdICsgbVszXSptWzhdKm1bMTRdIC0gbVszXSptWzEyXSptWzEwXTtcbiAgcls2XSA9IC1tWzBdKm1bNl0qbVsxNV0gKyBtWzBdKm1bMTRdKm1bN10gKyBtWzJdKm1bNF0qbVsxNV0gLSBtWzJdKm1bMTJdKm1bN10gLSBtWzNdKm1bNF0qbVsxNF0gKyBtWzNdKm1bMTJdKm1bNl07XG4gIHJbN10gPSBtWzBdKm1bNl0qbVsxMV0gLSBtWzBdKm1bMTBdKm1bN10gLSBtWzJdKm1bNF0qbVsxMV0gKyBtWzJdKm1bOF0qbVs3XSArIG1bM10qbVs0XSptWzEwXSAtIG1bM10qbVs4XSptWzZdO1xuXG4gIHJbOF0gPSBtWzRdKm1bOV0qbVsxNV0gLSBtWzRdKm1bMTNdKm1bMTFdIC0gbVs1XSptWzhdKm1bMTVdICsgbVs1XSptWzEyXSptWzExXSArIG1bN10qbVs4XSptWzEzXSAtIG1bN10qbVsxMl0qbVs5XTtcbiAgcls5XSA9IC1tWzBdKm1bOV0qbVsxNV0gKyBtWzBdKm1bMTNdKm1bMTFdICsgbVsxXSptWzhdKm1bMTVdIC0gbVsxXSptWzEyXSptWzExXSAtIG1bM10qbVs4XSptWzEzXSArIG1bM10qbVsxMl0qbVs5XTtcbiAgclsxMF0gPSBtWzBdKm1bNV0qbVsxNV0gLSBtWzBdKm1bMTNdKm1bN10gLSBtWzFdKm1bNF0qbVsxNV0gKyBtWzFdKm1bMTJdKm1bN10gKyBtWzNdKm1bNF0qbVsxM10gLSBtWzNdKm1bMTJdKm1bNV07XG4gIHJbMTFdID0gLW1bMF0qbVs1XSptWzExXSArIG1bMF0qbVs5XSptWzddICsgbVsxXSptWzRdKm1bMTFdIC0gbVsxXSptWzhdKm1bN10gLSBtWzNdKm1bNF0qbVs5XSArIG1bM10qbVs4XSptWzVdO1xuXG4gIHJbMTJdID0gLW1bNF0qbVs5XSptWzE0XSArIG1bNF0qbVsxM10qbVsxMF0gKyBtWzVdKm1bOF0qbVsxNF0gLSBtWzVdKm1bMTJdKm1bMTBdIC0gbVs2XSptWzhdKm1bMTNdICsgbVs2XSptWzEyXSptWzldO1xuICByWzEzXSA9IG1bMF0qbVs5XSptWzE0XSAtIG1bMF0qbVsxM10qbVsxMF0gLSBtWzFdKm1bOF0qbVsxNF0gKyBtWzFdKm1bMTJdKm1bMTBdICsgbVsyXSptWzhdKm1bMTNdIC0gbVsyXSptWzEyXSptWzldO1xuICByWzE0XSA9IC1tWzBdKm1bNV0qbVsxNF0gKyBtWzBdKm1bMTNdKm1bNl0gKyBtWzFdKm1bNF0qbVsxNF0gLSBtWzFdKm1bMTJdKm1bNl0gLSBtWzJdKm1bNF0qbVsxM10gKyBtWzJdKm1bMTJdKm1bNV07XG4gIHJbMTVdID0gbVswXSptWzVdKm1bMTBdIC0gbVswXSptWzldKm1bNl0gLSBtWzFdKm1bNF0qbVsxMF0gKyBtWzFdKm1bOF0qbVs2XSArIG1bMl0qbVs0XSptWzldIC0gbVsyXSptWzhdKm1bNV07XG5cbiAgdmFyIGRldCA9IG1bMF0qclswXSArIG1bMV0qcls0XSArIG1bMl0qcls4XSArIG1bM10qclsxMl07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgcltpXSAvPSBkZXQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LnRyYW5zcG9zZShtYXRyaXhbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYG1hdHJpeGAsIGV4Y2hhbmdpbmcgY29sdW1ucyBmb3Igcm93cy4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW5cbi8vIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC5cbk1hdHJpeC50cmFuc3Bvc2UgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IG1hdHJpeC5tLCByID0gcmVzdWx0Lm07XG4gIHJbMF0gPSBtWzBdOyByWzFdID0gbVs0XTsgclsyXSA9IG1bOF07IHJbM10gPSBtWzEyXTtcbiAgcls0XSA9IG1bMV07IHJbNV0gPSBtWzVdOyByWzZdID0gbVs5XTsgcls3XSA9IG1bMTNdO1xuICByWzhdID0gbVsyXTsgcls5XSA9IG1bNl07IHJbMTBdID0gbVsxMF07IHJbMTFdID0gbVsxNF07XG4gIHJbMTJdID0gbVszXTsgclsxM10gPSBtWzddOyByWzE0XSA9IG1bMTFdOyByWzE1XSA9IG1bMTVdO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5tdWx0aXBseShsZWZ0LCByaWdodFssIHJlc3VsdF0pXG4vL1xuLy8gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdHJhbnNmb3JtcyBmb3IgYGxlZnRgIGFuZCBgcmlnaHRgLiBZb3UgY2FuXG4vLyBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBuZXdcbi8vIG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbE11bHRNYXRyaXgoKWAuXG5NYXRyaXgubXVsdGlwbHkgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBhID0gbGVmdC5tLCBiID0gcmlnaHQubSwgciA9IHJlc3VsdC5tO1xuXG4gIHJbMF0gPSBhWzBdICogYlswXSArIGFbMV0gKiBiWzRdICsgYVsyXSAqIGJbOF0gKyBhWzNdICogYlsxMl07XG4gIHJbMV0gPSBhWzBdICogYlsxXSArIGFbMV0gKiBiWzVdICsgYVsyXSAqIGJbOV0gKyBhWzNdICogYlsxM107XG4gIHJbMl0gPSBhWzBdICogYlsyXSArIGFbMV0gKiBiWzZdICsgYVsyXSAqIGJbMTBdICsgYVszXSAqIGJbMTRdO1xuICByWzNdID0gYVswXSAqIGJbM10gKyBhWzFdICogYls3XSArIGFbMl0gKiBiWzExXSArIGFbM10gKiBiWzE1XTtcblxuICByWzRdID0gYVs0XSAqIGJbMF0gKyBhWzVdICogYls0XSArIGFbNl0gKiBiWzhdICsgYVs3XSAqIGJbMTJdO1xuICByWzVdID0gYVs0XSAqIGJbMV0gKyBhWzVdICogYls1XSArIGFbNl0gKiBiWzldICsgYVs3XSAqIGJbMTNdO1xuICByWzZdID0gYVs0XSAqIGJbMl0gKyBhWzVdICogYls2XSArIGFbNl0gKiBiWzEwXSArIGFbN10gKiBiWzE0XTtcbiAgcls3XSA9IGFbNF0gKiBiWzNdICsgYVs1XSAqIGJbN10gKyBhWzZdICogYlsxMV0gKyBhWzddICogYlsxNV07XG5cbiAgcls4XSA9IGFbOF0gKiBiWzBdICsgYVs5XSAqIGJbNF0gKyBhWzEwXSAqIGJbOF0gKyBhWzExXSAqIGJbMTJdO1xuICByWzldID0gYVs4XSAqIGJbMV0gKyBhWzldICogYls1XSArIGFbMTBdICogYls5XSArIGFbMTFdICogYlsxM107XG4gIHJbMTBdID0gYVs4XSAqIGJbMl0gKyBhWzldICogYls2XSArIGFbMTBdICogYlsxMF0gKyBhWzExXSAqIGJbMTRdO1xuICByWzExXSA9IGFbOF0gKiBiWzNdICsgYVs5XSAqIGJbN10gKyBhWzEwXSAqIGJbMTFdICsgYVsxMV0gKiBiWzE1XTtcblxuICByWzEyXSA9IGFbMTJdICogYlswXSArIGFbMTNdICogYls0XSArIGFbMTRdICogYls4XSArIGFbMTVdICogYlsxMl07XG4gIHJbMTNdID0gYVsxMl0gKiBiWzFdICsgYVsxM10gKiBiWzVdICsgYVsxNF0gKiBiWzldICsgYVsxNV0gKiBiWzEzXTtcbiAgclsxNF0gPSBhWzEyXSAqIGJbMl0gKyBhWzEzXSAqIGJbNl0gKyBhWzE0XSAqIGJbMTBdICsgYVsxNV0gKiBiWzE0XTtcbiAgclsxNV0gPSBhWzEyXSAqIGJbM10gKyBhWzEzXSAqIGJbN10gKyBhWzE0XSAqIGJbMTFdICsgYVsxNV0gKiBiWzE1XTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5pZGVudGl0eShbcmVzdWx0XSlcbi8vXG4vLyBSZXR1cm5zIGFuIGlkZW50aXR5IG1hdHJpeC4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluXG4vLyBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uXG4vLyBgZ2xMb2FkSWRlbnRpdHkoKWAuXG5NYXRyaXguaWRlbnRpdHkgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcbiAgbVswXSA9IG1bNV0gPSBtWzEwXSA9IG1bMTVdID0gMTtcbiAgbVsxXSA9IG1bMl0gPSBtWzNdID0gbVs0XSA9IG1bNl0gPSBtWzddID0gbVs4XSA9IG1bOV0gPSBtWzExXSA9IG1bMTJdID0gbVsxM10gPSBtWzE0XSA9IDA7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LnBlcnNwZWN0aXZlKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXJbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYSBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm0gbWF0cml4LCB3aGljaCBtYWtlcyBmYXIgYXdheSBvYmplY3RzIGFwcGVhclxuLy8gc21hbGxlciB0aGFuIG5lYXJieSBvYmplY3RzLiBUaGUgYGFzcGVjdGAgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSB3aWR0aFxuLy8gZGl2aWRlZCBieSB0aGUgaGVpZ2h0IG9mIHlvdXIgdmlld3BvcnQgYW5kIGBmb3ZgIGlzIHRoZSB0b3AtdG8tYm90dG9tIGFuZ2xlXG4vLyBvZiB0aGUgZmllbGQgb2YgdmlldyBpbiBkZWdyZWVzLiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhbiBleGlzdGluZyBtYXRyaXhcbi8vIGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBuZXcgbWF0cml4LiBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0xcbi8vIGZ1bmN0aW9uIGBnbHVQZXJzcGVjdGl2ZSgpYC5cbk1hdHJpeC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIsIHJlc3VsdCkge1xuICB2YXIgeSA9IE1hdGgudGFuKGZvdiAqIE1hdGguUEkgLyAzNjApICogbmVhcjtcbiAgdmFyIHggPSB5ICogYXNwZWN0O1xuICByZXR1cm4gTWF0cml4LmZydXN0dW0oLXgsIHgsIC15LCB5LCBuZWFyLCBmYXIsIHJlc3VsdCk7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LmZydXN0dW0obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXJbLCByZXN1bHRdKVxuLy9cbi8vIFNldHMgdXAgYSB2aWV3aW5nIGZydXN0dW0sIHdoaWNoIGlzIHNoYXBlZCBsaWtlIGEgdHJ1bmNhdGVkIHB5cmFtaWQgd2l0aCB0aGVcbi8vIGNhbWVyYSB3aGVyZSB0aGUgcG9pbnQgb2YgdGhlIHB5cmFtaWQgd291bGQgYmUuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuXG4vLyBleGlzdGluZyBtYXRyaXggaW4gYHJlc3VsdGAgdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguIFRoaXMgZW11bGF0ZXNcbi8vIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsRnJ1c3R1bSgpYC5cbk1hdHJpeC5mcnVzdHVtID0gZnVuY3Rpb24obCwgciwgYiwgdCwgbiwgZiwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBtID0gcmVzdWx0Lm07XG5cbiAgbVswXSA9IDIgKiBuIC8gKHIgLSBsKTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAociArIGwpIC8gKHIgLSBsKTtcbiAgbVszXSA9IDA7XG5cbiAgbVs0XSA9IDA7XG4gIG1bNV0gPSAyICogbiAvICh0IC0gYik7XG4gIG1bNl0gPSAodCArIGIpIC8gKHQgLSBiKTtcbiAgbVs3XSA9IDA7XG5cbiAgbVs4XSA9IDA7XG4gIG1bOV0gPSAwO1xuICBtWzEwXSA9IC0oZiArIG4pIC8gKGYgLSBuKTtcbiAgbVsxMV0gPSAtMiAqIGYgKiBuIC8gKGYgLSBuKTtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAtMTtcbiAgbVsxNV0gPSAwO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4Lm9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyWywgcmVzdWx0XSlcbi8vXG4vLyBSZXR1cm5zIGFuIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLCBpbiB3aGljaCBvYmplY3RzIGFyZSB0aGUgc2FtZSBzaXplIG5vXG4vLyBtYXR0ZXIgaG93IGZhciBhd2F5IG9yIG5lYXJieSB0aGV5IGFyZS4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3Rpbmdcbi8vIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMXG4vLyBmdW5jdGlvbiBgZ2xPcnRobygpYC5cbk1hdHJpeC5vcnRobyA9IGZ1bmN0aW9uKGwsIHIsIGIsIHQsIG4sIGYsIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIG1bMF0gPSAyIC8gKHIgLSBsKTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0gLShyICsgbCkgLyAociAtIGwpO1xuXG4gIG1bNF0gPSAwO1xuICBtWzVdID0gMiAvICh0IC0gYik7XG4gIG1bNl0gPSAwO1xuICBtWzddID0gLSh0ICsgYikgLyAodCAtIGIpO1xuXG4gIG1bOF0gPSAwO1xuICBtWzldID0gMDtcbiAgbVsxMF0gPSAtMiAvIChmIC0gbik7XG4gIG1bMTFdID0gLShmICsgbikgLyAoZiAtIG4pO1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5zY2FsZSh4LCB5LCB6WywgcmVzdWx0XSlcbi8vXG4vLyBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsU2NhbGUoKWAuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuXG4vLyBleGlzdGluZyBtYXRyaXggaW4gYHJlc3VsdGAgdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguXG5NYXRyaXguc2NhbGUgPSBmdW5jdGlvbih4LCB5LCB6LCByZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcblxuICBtWzBdID0geDtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0gMDtcblxuICBtWzRdID0gMDtcbiAgbVs1XSA9IHk7XG4gIG1bNl0gPSAwO1xuICBtWzddID0gMDtcblxuICBtWzhdID0gMDtcbiAgbVs5XSA9IDA7XG4gIG1bMTBdID0gejtcbiAgbVsxMV0gPSAwO1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC50cmFuc2xhdGUoeCwgeSwgelssIHJlc3VsdF0pXG4vL1xuLy8gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbFRyYW5zbGF0ZSgpYC4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3Ncbi8vIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC5cbk1hdHJpeC50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5LCB6LCByZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcblxuICBtWzBdID0gMTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0geDtcblxuICBtWzRdID0gMDtcbiAgbVs1XSA9IDE7XG4gIG1bNl0gPSAwO1xuICBtWzddID0geTtcblxuICBtWzhdID0gMDtcbiAgbVs5XSA9IDA7XG4gIG1bMTBdID0gMTtcbiAgbVsxMV0gPSB6O1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5yb3RhdGUoYSwgeCwgeSwgelssIHJlc3VsdF0pXG4vL1xuLy8gUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgYnkgYGFgIGRlZ3JlZXMgYXJvdW5kIHRoZSB2ZWN0b3IgYHgsIHksIHpgLlxuLy8gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmdcbi8vIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbFJvdGF0ZSgpYC5cbk1hdHJpeC5yb3RhdGUgPSBmdW5jdGlvbihhLCB4LCB5LCB6LCByZXN1bHQpIHtcbiAgaWYgKCFhIHx8ICgheCAmJiAheSAmJiAheikpIHtcbiAgICByZXR1cm4gTWF0cml4LmlkZW50aXR5KHJlc3VsdCk7XG4gIH1cblxuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIHZhciBkID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG4gIGEgKj0gTWF0aC5QSSAvIDE4MDsgeCAvPSBkOyB5IC89IGQ7IHogLz0gZDtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhKSwgcyA9IE1hdGguc2luKGEpLCB0ID0gMSAtIGM7XG5cbiAgbVswXSA9IHggKiB4ICogdCArIGM7XG4gIG1bMV0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgbVsyXSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBtWzNdID0gMDtcblxuICBtWzRdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG1bNV0gPSB5ICogeSAqIHQgKyBjO1xuICBtWzZdID0geSAqIHogKiB0IC0geCAqIHM7XG4gIG1bN10gPSAwO1xuXG4gIG1bOF0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgbVs5XSA9IHogKiB5ICogdCArIHggKiBzO1xuICBtWzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG1bMTFdID0gMDtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAwO1xuICBtWzE1XSA9IDE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vICMjIyBHTC5NYXRyaXgubG9va0F0KGV4LCBleSwgZXosIGN4LCBjeSwgY3osIHV4LCB1eSwgdXpbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYSBtYXRyaXggdGhhdCBwdXRzIHRoZSBjYW1lcmEgYXQgdGhlIGV5ZSBwb2ludCBgZXgsIGV5LCBlemAgbG9va2luZ1xuLy8gdG93YXJkIHRoZSBjZW50ZXIgcG9pbnQgYGN4LCBjeSwgY3pgIHdpdGggYW4gdXAgZGlyZWN0aW9uIG9mIGB1eCwgdXksIHV6YC5cbi8vIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nXG4vLyBhIG5ldyBtYXRyaXguIFRoaXMgZW11bGF0ZXMgdGhlIE9wZW5HTCBmdW5jdGlvbiBgZ2x1TG9va0F0KClgLlxuTWF0cml4Lmxvb2tBdCA9IGZ1bmN0aW9uKGV4LCBleSwgZXosIGN4LCBjeSwgY3osIHV4LCB1eSwgdXosIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIHZhciBlID0gbmV3IFZlY3RvcihleCwgZXksIGV6KTtcbiAgdmFyIGMgPSBuZXcgVmVjdG9yKGN4LCBjeSwgY3opO1xuICB2YXIgdSA9IG5ldyBWZWN0b3IodXgsIHV5LCB1eik7XG4gIHZhciBmID0gZS5zdWJ0cmFjdChjKS51bml0KCk7XG4gIHZhciBzID0gdS5jcm9zcyhmKS51bml0KCk7XG4gIHZhciB0ID0gZi5jcm9zcyhzKS51bml0KCk7XG5cbiAgbVswXSA9IHMueDtcbiAgbVsxXSA9IHMueTtcbiAgbVsyXSA9IHMuejtcbiAgbVszXSA9IC1zLmRvdChlKTtcblxuICBtWzRdID0gdC54O1xuICBtWzVdID0gdC55O1xuICBtWzZdID0gdC56O1xuICBtWzddID0gLXQuZG90KGUpO1xuXG4gIG1bOF0gPSBmLng7XG4gIG1bOV0gPSBmLnk7XG4gIG1bMTBdID0gZi56O1xuICBtWzExXSA9IC1mLmRvdChlKTtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAwO1xuICBtWzE1XSA9IDE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4XG4iLCJjb25zdCBlbWl0X2Zsb2F0ID0gZnVuY3Rpb24oIGEgKSB7XG5cdGlmIChhICUgMSA9PT0gMClcblx0XHRyZXR1cm4gYS50b0ZpeGVkKCAxIClcblx0ZWxzZVxuXHRcdHJldHVybiBhXG59XG5cbmNvbnN0IEZsb2F0UHJvdG90eXBlID0ge1xuICB0eXBlOiAnZmxvYXQnLFxuXHRlbWl0KCkgeyByZXR1cm4gZW1pdF9mbG9hdCggdGhpcy54ICkgfSxcblx0ZW1pdF9kZWNsKCkgeyByZXR1cm4gXCJcIiB9XG59XG5cblxuY29uc3QgRmxvYXQgPSBmdW5jdGlvbiggeD0wICkge1xuICBjb25zdCBmID0gT2JqZWN0LmNyZWF0ZSggRmxvYXRQcm90b3R5cGUgKVxuICBmLnggPSB4XG4gIHJldHVybiBmXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvYXRcbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gPSByZXF1aXJlKCAnLi92YXIuanMnIClcblxuY29uc3QgRm9nZ2VyID0gZnVuY3Rpb24oIFNjZW5lLCBTREYgKSB7XG5cbiAgY29uc3QgRm9nID0gZnVuY3Rpb24oIGFtb3VudD0wLjA1NSwgY29sb3IgKSB7XG4gICAgY29uc3QgZm9nID0gT2JqZWN0LmNyZWF0ZSggRm9nLnByb3RvdHlwZSApXG4gICAgY29uc3QgX19hbW91bnQgPSBwYXJhbV93cmFwKCBhbW91bnQsIGZsb2F0X3Zhcl9nZW4oIGFtb3VudCApICkgIFxuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggZm9nLCAnYW1vdW50Jywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gX19hbW91bnQgfSxcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgX19hbW91bnQuc2V0KCB2IClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgX19jb2xvciA9IHBhcmFtX3dyYXAoIGNvbG9yLCB2ZWMzX3Zhcl9nZW4oIC41LC42LC43ICkgKSAgXG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBmb2csICdjb2xvcicsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIF9fY29sb3IgfSxcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgX19jb2xvci52YXIuc2V0KCB2IClcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIC8vIHRoaXMgcmVmZXJzIHRvIHRoZSBjdXJyZW50IHNjZW5lIHZpYSBpbXBsaWNpdCBiaW5kaW5nIGluIHNjZW5lLmpzXG4gICAgdGhpcy5wb3N0cHJvY2Vzc2luZy5wdXNoKCBmb2cgKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEZvZy5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuIFxuICBPYmplY3QuYXNzaWduKCBGb2cucHJvdG90eXBlLCB7XG4gICAgZW1pdCgpIHtcbiAgICAgIHJldHVybiBgICBjb2xvciA9IGFwcGx5Rm9nKCBjb2xvciwgdC54LCAke3RoaXMuYW1vdW50LmVtaXQoKX0gKTtgXG4gICAgfSxcbiAgIFxuICAgIGVtaXRfZGVjbCgpIHtcbiAgICAgIGxldCBzdHIgPSB0aGlzLmFtb3VudC5lbWl0X2RlY2woKSArIHRoaXMuY29sb3IuZW1pdF9kZWNsKClcbiAgICAgIGNvbnN0IHByZWZhY2UgPSBgICB2ZWMzIGFwcGx5Rm9nKCBpbiB2ZWMzIHJnYiwgaW4gZmxvYXQgZGlzdGFuY2UsIGluIGZsb2F0IGFtb3VudCApIHtcbiAgICBmbG9hdCBmb2dBbW91bnQgPSAxLiAtIGV4cCggLWRpc3RhbmNlICogYW1vdW50ICk7XG4gICAgdmVjMyAgZm9nQ29sb3IgID0gJHt0aGlzLmNvbG9yLmVtaXQoKX07XG4gICAgcmV0dXJuIG1peCggcmdiLCBmb2dDb2xvciwgZm9nQW1vdW50ICk7XG4gIH1cbiAgYFxuICAgICAgaWYoIFNERi5tZW1vLmZvZyA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBzdHIgPSBzdHIgKyBwcmVmYWNlXG4gICAgICAgIFNERi5tZW1vLmZvZyA9IHRydWVcbiAgICAgIH1lbHNle1xuICAgICAgICBzdHIgPSAnJ1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIHVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSB7XG4gICAgICB0aGlzLmFtb3VudC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgIHRoaXMuY29sb3IudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCApIHtcbiAgICAgIHRoaXMuYW1vdW50LnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICB0aGlzLmNvbG9yLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBGb2dcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGb2dnZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBNYXJjaGluZyA9IHJlcXVpcmUoICcuL21haW4uanMnIClcblxuTWFyY2hpbmcuX19leHBvcnQgPSBNYXJjaGluZy5leHBvcnRcbk1hcmNoaW5nLmV4cG9ydCA9IG9iaiA9PiB7XG4gIG9iai5tYXJjaCA9IE1hcmNoaW5nLmNyZWF0ZVNjZW5lLmJpbmQoIE1hcmNoaW5nIClcbiAgTWFyY2hpbmcuX19leHBvcnQoIG9iaiApXG59XG5cbndpbmRvdy5NYXJjaGluZyA9IE1hcmNoaW5nXG5cbm1vZHVsZS5leHBvcnRzID0gTWFyY2hpbmdcbiIsImNvbnN0IGVtaXRfaW50ID0gZnVuY3Rpb24oIGEgKSB7XG5cdGlmKCBhICUgMSAhPT0gMCApXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIGEgKVxuXHRlbHNlXG5cdFx0cmV0dXJuIGFcbn1cblxuY29uc3QgSW50UHJvdG90eXBlID0ge1xuICB0eXBlOiAnaW50Jyxcblx0ZW1pdCgpIHsgcmV0dXJuIGVtaXRfaW50KCB0aGlzLnggKSB9LFxuXHRlbWl0X2RlY2woKSB7IHJldHVybiBcIlwiIH1cbn1cblxuXG5jb25zdCBJbnQgPSBmdW5jdGlvbiggeD0wICkge1xuICBjb25zdCBmID0gT2JqZWN0LmNyZWF0ZSggSW50UHJvdG90eXBlIClcbiAgZi54ID0geFxuICByZXR1cm4gZlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludFxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApLFxuICAgICAgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKSxcbiAgICAgIHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuIH0gPSByZXF1aXJlKCAnLi92YXIuanMnICksXG4gICAgICB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuXG5jb25zdCBnbHNsID0gcmVxdWlyZSggJ2dsc2xpZnknIClcblxuY29uc3QgTGlnaHRzID0gZnVuY3Rpb24oIFNERiApIHtcblxuICBjb25zdCBMaWdodCA9IHtcbiAgICBsaWdodHM6W10sXG4gICAgbWF0ZXJpYWxzOltdLFxuXG4gICAgZGVmYXVsdExpZ2h0czpgXG4gICAgICBMaWdodCBsaWdodHNbMl0gPSBMaWdodFsyXShcbiAgICAgICAgTGlnaHQoIHZlYzMoIDIuLDIuLDMuICksICB2ZWMzKDAuMjUsMC4yNSwuMjUpLCAxLiApLFxuICAgICAgICBMaWdodCggdmVjMyggLTIuLDIuLDMuICksIHZlYzMoLjI1LDAuMjUsMC4yNSksIDEuIClcbiAgICAgICk7XG4gICAgYCxcblxuICAgIGRlZmF1bHRNYXRlcmlhbHM6YFxuICAgICAgTWF0ZXJpYWwgbWF0ZXJpYWxzWzJdID0gTWF0ZXJpYWxbMl0oXG4gICAgICAgIE1hdGVyaWFsKCAwLCB2ZWMzKCAxLiApLCB2ZWMzKDAuLDAuLDAuKSwgdmVjMygxLiksIDguLCBGcmVzbmVsKCAwLiwgMS4sIDIuKSwgMCApLFxuICAgICAgICBNYXRlcmlhbCggMCwgdmVjMyggMS4gKSwgdmVjMygxLiwwLiwwLiksIHZlYzMoMS4pLCA4LiwgRnJlc25lbCggMC4sIDEuLCAyLiksIDAgKVxuICAgICAgKTtcbiAgICBgLFxuXG4gICAgbGlnaHQoIF9fcG9zPVZlYzMoMiwyLDMpLCBfX2NvbG9yPVZlYzMoMCwwLDEpLCBhdHRlbnVhdGlvbj0xICkge1xuICAgICAgY29uc3QgbGlnaHQgPSB7IFxuICAgICAgICBfX2F0dGVudWF0aW9uOiBwYXJhbV93cmFwKCBhdHRlbnVhdGlvbiwgZmxvYXRfdmFyX2dlbiggMSApICksXG4gICAgICB9XG5cbiAgICAgIHBvcyA9IHR5cGVvZiBfX3BvcyA9PT0gJ251bWJlcicgPyBWZWMzKCBfX3BvcyApIDogX19wb3NcblxuICAgICAgY29uc3QgX192YXJwb3MgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgcG9zLCBcbiAgICAgICAgdmVjM192YXJfZ2VuKCBbMiwyLDNdIClcbiAgICAgIClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBsaWdodCwgJ3BvcycsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXJwb3MgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgX192YXJwb3Muc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIF9fdmFycG9zLnZhbHVlLnggPSB2XG4gICAgICAgICAgICBfX3ZhcnBvcy52YWx1ZS55ID0gdlxuICAgICAgICAgICAgX192YXJwb3MudmFsdWUueiA9IHZcbiAgICAgICAgICAgIF9fdmFycG9zLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgIFxuXG4gICAgICBjb2xvciA9IHR5cGVvZiBfX2NvbG9yID09PSAnbnVtYmVyJyA/IFZlYzMoIF9fY29sb3IgKSA6IF9fY29sb3JcblxuICAgICAgY29uc3QgX192YXJjb2wgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgY29sb3IsIFxuICAgICAgICB2ZWMzX3Zhcl9nZW4oIFswLDAsMV0gKVxuICAgICAgKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGxpZ2h0LCAnY29sb3InLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyY29sIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIF9fdmFyY29sLnNldCggdiApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBfX3ZhcmNvbC52YWx1ZS54ID0gdlxuICAgICAgICAgICAgX192YXJjb2wudmFsdWUueSA9IHZcbiAgICAgICAgICAgIF9fdmFyY29sLnZhbHVlLnogPSB2XG4gICAgICAgICAgICBfX3ZhcmNvbC5kaXJ0eSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pICBcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBsaWdodCwgJ2F0dGVudWF0aW9uJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBsaWdodC5fX2F0dGVudWF0aW9uLnZhbHVlIH0sXG4gICAgICAgIHNldCh2KXtcbiAgICAgICAgICBsaWdodC5fX2F0dGVudWF0aW9uLnZhbHVlID0gdlxuICAgICAgICAgIGxpZ2h0Ll9fYXR0ZW51YXRpb24uZGlydHkgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBsaWdodFxuICAgIH0sXG5cbiAgICBlbWl0X2xpZ2h0cygpIHtcbiAgICAgIGlmKCB0aGlzLmxpZ2h0cy5sZW5ndGggPT09IDAgKSByZXR1cm4gdGhpcy5kZWZhdWx0TGlnaHRzXG5cbiAgICAgIGxldCBzdHIgPSBgTGlnaHQgbGlnaHRzWyR7dGhpcy5saWdodHMubGVuZ3RofV0gPSBMaWdodFske3RoaXMubGlnaHRzLmxlbmd0aH1dKGBcblxuICAgICAgZm9yKCBsZXQgbGlnaHQgb2YgdGhpcy5saWdodHMgKSB7XG4gICAgICAgIHN0ciArPSBgXFxuICAgICAgICBMaWdodCggJHtsaWdodC5wb3MuZW1pdCgpfSwgJHtsaWdodC5jb2xvci5lbWl0KCl9LCAke2xpZ2h0Ll9fYXR0ZW51YXRpb24uZW1pdCgpfSksYCBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsLTEpIC8vIHJlbW92ZSB0cmFpbGluZyBjb21tYVxuXG4gICAgICBzdHIgKz0gJ1xcbiAgICAgICk7J1xuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIG1vZGU6J2dsb2JhbCcsXG5cbiAgICBnZW4oIHNoYWRvd3M9OCwgZ2VvbWV0cmllcyApIHtcbiAgICAgIC8vY29uc3Qgc3RyID0gdGhpcy5tb2Rlc1sgdGhpcy5tb2RlIF0oIHRoaXMubGlnaHRzLmxlbmd0aCB8fCAyLCB0aGlzLmVtaXRfbGlnaHRzKCksIFNERi5tYXRlcmlhbHMuZW1pdF9tYXRlcmlhbHMoKSwgc2hhZG93cyApXG4gICBcbiAgICAgIGNvbnN0IG1vZGVDb25zdGFudHMgPSBTREYubWF0ZXJpYWxzLm1vZGVDb25zdGFudHNcbiAgICAgIHRoaXMubW9kZXNFbXBsb3llZC5sZW5ndGggPSAwXG5cbiAgICAgIGxldCBsaWdodGluZ0Z1bmN0aW9ucyA9IFtdXG5cbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgbWF0ZXJpYWxzIHVzZWQgYW5kIGFkZCBjb3JyZXNwb25kaW5nIGxpZ2h0aW5nIGZ1bmN0aW9ucyBhcyBuZWVkZWRcbiAgICAgIGZvciggbGV0IG1hdCBvZiBTREYubWF0ZXJpYWxzLm1hdGVyaWFscyApIHtcbiAgICAgICAgaWYoIHRoaXMubW9kZXNFbXBsb3llZC5pbmRleE9mKCBtYXQubW9kZSApID09PSAtMSApIHtcbiAgICAgICAgICBsaWdodGluZ0Z1bmN0aW9ucy5wdXNoKCB0aGlzLm1vZGVzWyBtYXQubW9kZSBdKCkgKSAgXG5cbiAgICAgICAgICB0aGlzLm1vZGVzRW1wbG95ZWQucHVzaCggbWF0Lm1vZGUgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGFsbCBtb2RlcyB0byBzZWUgaWYgdGhleSdyZSBsaWdodGluZyBmdW5jdGlvbiBoYXMgYmVlbiBhZGRlZCB0byB0aGUgc2hhZGVyLFxuICAgICAgLy8gaWYgbm90LCBhZGQgdGhlaXIgZnVuY3Rpb24gc3R1YlxuICAgICAgZm9yKCBsZXQgbW9kZSBvZiBtb2RlQ29uc3RhbnRzICkge1xuICAgICAgICAvLyBrZXkgaXMgaXRlcmF0ZWQgYXMgc3RyaW5nLCBtdXN0IHVzZSBwYXJzZUludFxuICAgICAgICBpZiggdGhpcy5tb2Rlc0VtcGxveWVkLmluZGV4T2YoIG1vZGUgKSA9PT0gLTEgKSB7XG4gICAgICAgICAgbGlnaHRpbmdGdW5jdGlvbnMucHVzaCggdGhpcy5kZWZhdWx0RnVuY3Rpb25EZWNsYXJhdGlvbnNbIG1vZGVDb25zdGFudHMuaW5kZXhPZiggbW9kZSApIF0gKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHR1cmVzID0gTWFyY2hpbmcudGV4dHVyZXMuX19lbWl0RnVuY3Rpb24oKVxuICAgICAgY29uc3QgbGlnaHRpbmcgPSB0aGlzLnNoZWxsKCBcbiAgICAgICAgdGhpcy5saWdodHMubGVuZ3RoIHx8IDIsIFxuICAgICAgICB0aGlzLmVtaXRfbGlnaHRzKCksIFxuICAgICAgICBTREYubWF0ZXJpYWxzLmVtaXRfbWF0ZXJpYWxzKCksIFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBnZW9tZXRyaWVzLCBcbiAgICAgICAgdGV4dHVyZXMuZ2xzbGRlZnMsXG4gICAgICAgIHRleHR1cmVzLm1haW5mdW5jXG4gICAgICApXG5cbiAgICAgIGxldCBsaWdodGluZ0Z1bmNTdHIgPSBsaWdodGluZ0Z1bmN0aW9ucy5qb2luKCdcXG4nKVxuICAgICAgbGlnaHRpbmdGdW5jU3RyID0gbGlnaHRpbmdGdW5jU3RyLnJlcGxhY2UoIC8oTUFYXFxfTElHSFRTKS9nLCB0aGlzLmxpZ2h0cy5sZW5ndGggfHwgMiApXG4gICAgICByZXR1cm4gbGlnaHRpbmdbMF0gKyBsaWdodGluZ0Z1bmNTdHIgKyBsaWdodGluZ1sxXVxuICAgIH0sXG5cbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBsZXQgc3RyID0gJydcbiAgICAgIGZvciggbGV0IGxpZ2h0IG9mIHRoaXMubGlnaHRzICkge1xuICAgICAgICBzdHIgKz0gbGlnaHQucG9zLmVtaXRfZGVjbCgpXG4gICAgICAgIHN0ciArPSBsaWdodC5jb2xvci5lbWl0X2RlY2woKVxuICAgICAgICBzdHIgKz0gbGlnaHQuX19hdHRlbnVhdGlvbi5lbWl0X2RlY2woKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIHVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSB7XG4gICAgICBmb3IoIGxldCBsaWdodCBvZiB0aGlzLmxpZ2h0cyApIHtcbiAgICAgICAgaWYoIGxpZ2h0LnBvcy5kaXJ0eSA9PT0gdHJ1ZSApICBsaWdodC5wb3MudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBsaWdodC5jb2xvci5kaXJ0eSA9PT0gdHJ1ZSApICBsaWdodC5jb2xvci51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIGxpZ2h0Ll9fYXR0ZW51YXRpb24uZGlydHkgPT09IHRydWUgKSBsaWdodC5fX2F0dGVudWF0aW9uLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbT0nJyApIHtcbiAgICAgIGZvciggbGV0IGxpZ2h0IG9mIHRoaXMubGlnaHRzICkge1xuICAgICAgICBpZiggbGlnaHQucG9zLmRpcnR5ID09PSB0cnVlICkgICBsaWdodC5wb3MudXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIGxpZ2h0LmNvbG9yLmRpcnR5ID09PSB0cnVlICkgIGxpZ2h0LmNvbG9yLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBsaWdodC5fX2F0dGVudWF0aW9uLmRpcnR5ID09PSB0cnVlICkgIGxpZ2h0Ll9fYXR0ZW51YXRpb24udXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW9kZXNFbXBsb3llZDpbXSxcblxuICAgIC8vIHRoZXNlIHN0dWJzIGFyZSBwbGFjZWQgaW4gdGhlIHNoYWRlciBieSBkZWZhdWx0IGFzIHBsYWNlaG9sZGVycyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgaW4gXG4gICAgLy8gYSBzd2l0Y2ggc3RhdGVtZW50IHNlbGVjdGluZyBsaWdodGluZy4gVGhleSBhcmUgb3ZlcnJpZGRlbiBieSBhY3R1YWwgbGlnaHRpbmcgZnVuY3Rpb25zIGlmIGFueVxuICAgIC8vIG1hdGVyaWFsIGluIHRoZSBzY2VuZSB1c2VzIGEgY29ycmVzcG9uZGluZyBmdW5jdGlvbi5cbiAgICBkZWZhdWx0RnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtcbiAgICAgICcgICAgdmVjMyBnbG9iYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgbm9ybWFsKCB2ZWMzIHN1cmZhY2VQb3NpdGlvbiwgdmVjMyBub3JtYWwsIHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbiwgTWF0ZXJpYWwgbWF0LCBMaWdodCBsaWdodHNbTUFYX0xJR0hUU10gKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgb3Jlbm4oIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSApIHsgcmV0dXJuIHZlYzMoMC4pOyB9JyxcbiAgICBdLFxuXG4gICAgc2hlbGwoIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMsIHNoYWRvdz0wLCBzZGZzLCB0ZXh0dXJlUHJlZmFjZSwgdGV4dHVyZUJvZHkgKSB7XG4gICAgICBjb25zdCBfX3NoYWRvdyA9IHNoYWRvdyA+IDBcbiAgICAgICAgPyBgZGlmZnVzZUNvZWZmaWNpZW50ICo9IHNvZnRzaGFkb3coIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApLCAwLjAyLCAyLjUsICR7c2hhZG93LnRvRml4ZWQoMSl9ICk7YCBcbiAgICAgICAgOiAnJ1xuXG5cbiAgICAgIGxldCBwcmVmYWNlID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgaW50IE1BWF9MSUdIVFMgPSBcIixcIjtcXG4gICAgZmxvYXQgYW8oIGluIHZlYzMgcG9zLCBpbiB2ZWMzIG5vciApe1xcbiAgICAgIGZsb2F0IG9jYyA9IDAuMDtcXG4gICAgICBmbG9hdCBzY2EgPSAxLjA7XFxuICAgICAgZm9yKCBpbnQgaT0wOyBpPDU7IGkrKyApXFxuICAgICAge1xcbiAgICAgICAgICBmbG9hdCBociA9IDAuMDEgKyAwLjEyICogZmxvYXQoIGkgKSAvIDQuMDtcXG4gICAgICAgICAgdmVjMyBhb3BvcyA9ICBub3IgKiBociArIHBvcztcXG4gICAgICAgICAgZmxvYXQgZGQgPSBzY2VuZSAoIGFvcG9zICkueDtcXG4gICAgICAgICAgb2NjICs9IC0oZGQtaHIpKnNjYTtcXG4gICAgICAgICAgc2NhICo9IDAuOTU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjbGFtcCggMS4wIC0gMy4wKm9jYywgMC4wLCAxLjAgKTsgICAgXFxuICAgIH1cXG5cXG4gICAgXFxuICAgIFwiLFwiXFxuICAgIFwiLFwiXFxuICAgIFwiLFwiXCJdLG51bWxpZ2h0cyx0ZXh0dXJlUHJlZmFjZSx0ZXh0dXJlQm9keSlcbiAgICAgIGxldCBmdW5jID0gYFxuXG4gICAgdmVjMyBsaWdodGluZyggdmVjMyBzdXJmYWNlUG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIGZsb2F0IHNkZklELCBib29sIHVzZVRleHR1cmVUcmFuc2Zvcm0gKSB7XG4gICAgICAke3NkZnN9XG4gICAgICBTREYgc2RmID0gc2Rmc1sgaW50KCBzZGZJRCApIF07XG5cbiAgICAgICR7bWF0ZXJpYWxzfVxuICAgICAgTWF0ZXJpYWwgbWF0ID0gbWF0ZXJpYWxzWyBzZGYubWF0ZXJpYWxJRCBdO1xuXG4gICAgICBpbnQgTUFYX0xJR0hUUyA9ICR7bnVtbGlnaHRzfTsgICAgIFxuXG4gICAgICAke2xpZ2h0c31cbiBcbiAgICAgIHZlYzMgdGV4ID0gZ2V0VGV4dHVyZSggaW50KHNkZi50ZXh0dXJlSUQpLCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgc2RmLCB1c2VUZXh0dXJlVHJhbnNmb3JtICk7XG5cbiAgICAgIHZlYzMgY2xyO1xuICAgICAgc3dpdGNoKCBtYXQubW9kZSApIHtcbiAgICAgICAgY2FzZSAwOiBjbHIgPSBnbG9iYWwoIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsLCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbWF0LCBsaWdodHMsIHRleCApOyBicmVhaztcbiAgICAgICAgY2FzZSAxOiBjbHIgPSBub3JtYWw7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGNsciA9IGRpcmVjdGlvbmFsKCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIG1hdCwgbGlnaHRzLCB0ZXggKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogY2xyID0gb3Jlbm4oIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsLCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbWF0LCBsaWdodHMgKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xyID0gbm9ybWFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xyOyBcbiAgICB9XG5gXG4gICAgICByZXR1cm4gWyBwcmVmYWNlLCBmdW5jIF1cbiAgICB9LCBcblxuICAgIG1vZGVzOntcbiAgICAgIGdsb2JhbCgpIHtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gU0RGLl9fc2NlbmUuX19zaGFkb3dcblxuICAgICAgICBjb25zdCBzdHIgPSBnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuXFxuICAgICAgICB2ZWMzIGdsb2JhbCggdmVjMyBwb3MsIHZlYzMgbm9yLCB2ZWMzIHJvLCB2ZWMzIHJkLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7XFxuICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyAwIF07XFxuICAgICAgICAgIHZlYzMgIHJlZiA9IHJlZmxlY3QoIHJkLCBub3IgKTsgLy8gcmVmbGVjdGlvbiBhbmdsZVxcbiAgICAgICAgICBmbG9hdCBvY2MgPSBhbyggcG9zLCBub3IgKTtcXG4gICAgICAgICAgdmVjMyAgbGlnID0gbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApOyAvLyBsaWdodCBwb3NpdGlvblxcbiAgICAgICAgICBmbG9hdCBhbWIgPSBjbGFtcCggMC41ICsgMC41ICogbm9yLnksIDAuMCwgMS4wICk7XFxuICAgICAgICAgIGZsb2F0IGRpZiA9IGNsYW1wKCBkb3QoIG5vciwgbGlnICksIDAuMCwgMS4wICk7XFxuXFxuICAgICAgICAgIC8vIHNpbXVsYXRlZCBiYWNrbGlnaHRcXG4gICAgICAgICAgZmxvYXQgYmFjID0gY2xhbXAoIGRvdCggbm9yLCBub3JtYWxpemUoIHZlYzMoIC1saWcueCwgMC4wICwgLWxpZy56ICkpKSwgMC4wLCAxLjAgKSAqIGNsYW1wKCAxLjAtcG9zLnksIDAuMCAsMS4wICk7XFxuXFxuICAgICAgICAgIC8vIHNpbXVsYXRlZCBza3lkb21lIGxpZ2h0XFxuICAgICAgICAgIGZsb2F0IGRvbSA9IHNtb290aHN0ZXAoIC0wLjEsIDAuMSwgcmVmLnkgKTtcXG4gICAgICAgICAgZmxvYXQgZnJlID0gcG93KCBjbGFtcCggMS4wICsgZG90KCBub3IscmQgKSwwLjAsMS4wICksIDMuMCk7XFxuICAgICAgICAgIGZsb2F0IHNwZSA9IHBvdyggY2xhbXAoIGRvdCggcmVmLCBsaWcgKSwgMC4wLCAxLjAgKSwgOC4wICk7XFxuXFxuICAgICAgICAgIGRpZiAqPSBzb2Z0c2hhZG93KCBwb3MsIGxpZywgMC4wMiwgMi41LCBcIixcIiApO1xcbiAgICAgICAgICBkb20gKj0gc29mdHNoYWRvdyggcG9zLCByZWYsIDAuMDIsIDIuNSwgXCIsXCIgKTtcXG5cXG4gICAgICAgICAgdmVjMyBicmRmID0gdGV4dHVyZUNvbG9yOy8vdmVjMyggMC4wICk7XFxuICAgICAgICAgIGJyZGYgKz0gMS4yMCAqIGRpZiAqIHZlYzMoIDEuMDAsMC45MCwwLjYwICkgKiBtYXQuZGlmZnVzZSAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICBicmRmICs9IDIuMjAgKiBzcGUgKiB2ZWMzKCAxLjAwLDAuOTAsMC42MCApICogZGlmICogbWF0LnNwZWN1bGFyICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgIGJyZGYgKz0gMC4zMCAqIGFtYiAqIHZlYzMoIDAuNTAsMC43MCwxLjAwICkgKiBvY2MgKiBtYXQuYW1iaWVudCAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICBicmRmICs9IDAuNDAgKiBkb20gKiB2ZWMzKCAwLjUwLDAuNzAsMS4wMCApO1xcbiAgICAgICAgICBicmRmICs9IDAuNzAgKiBiYWMgKiB2ZWMzKCAwLjI1ICk7XFxuICAgICAgICAgIGJyZGYgKz0gMC40MCAqIChmcmUgKiBsaWdodC5jb2xvcik7XFxuXFxuICAgICAgICAgIHJldHVybiBicmRmO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCIsXCJcIl0sc2hhZG93LnRvRml4ZWQoMSksc2hhZG93LnRvRml4ZWQoMSkpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSxcblxuICAgICAgcGhvbmcoIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMgKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IFNERi5fX3NjZW5lLl9fc2hhZG93XG5cbiAgICAgICAgY29uc3QgX19zaGFkb3cgPSBzaGFkb3cgPiAwXG4gICAgICAgICAgPyBgZGlmZnVzZUNvZWZmaWNpZW50ICo9IHNvZnRzaGFkb3coIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApLCAwLjAyLCAyLjUsICR7c2hhZG93LnRvRml4ZWQoMSl9ICk7YCBcbiAgICAgICAgICA6ICcnXG5cbiAgICAgICAgY29uc3Qgc3RyID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgXFxuICAgICAgICBcXG4gICAgICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7XFxuICAgICAgICAgIHZlYzMgIG91dHB1dENvbG9yICAgPSB0ZXh0dXJlQ29sb3I7Ly92ZWMzKCAwLiApO1xcbiAgIFxcbiAgICAgICAgICAvLyBhcHBsaWVzIHRvIGFsbCBsaWdodHNcXG4gICAgICAgICAgZmxvYXQgb2NjbHVzaW9uID0gYW8oIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsICk7XFxuXFxuICAgICAgICAgIGZvciggaW50IGkgPSAwOyBpIDwgMjAwMDA7IGkrKyApIHtcXG4gICAgICAgICAgICBpZiggaSA+PSBNQVhfTElHSFRTICkgYnJlYWs7XFxuXFxuICAgICAgICAgICAgTGlnaHQgbGlnaHQgPSBsaWdodHNbIGkgXTtcXG5cXG4gICAgICAgICAgICB2ZWMzIHN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiAtIHN1cmZhY2VQb3NpdGlvbiApO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIGdldCBzaW1pbGFyaXR5IGJldHdlZW4gbm9ybWFsIGFuZCBkaXJlY3Rpb24gdG8gbGlnaHRcXG4gICAgICAgICAgICBmbG9hdCBkaWZmdXNlQ29lZmZpY2llbnQgPSBkb3QoIG5vcm1hbCwgc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24gKTsgXFxuXFxuICAgICAgICAgICAgLy8gZ2V0IHJlZmxlY3Rpb24gYW5nbGUgZm9yIGxpZ2h0IHN0cmlraW5nIHN1cmZhY2VcXG4gICAgICAgICAgICB2ZWMzIGFuZ2xlT2ZSZWZsZWN0aW9uID0gcmVmbGVjdCggLXN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uLCBub3JtYWwgKTtcXG5cXG4gICAgICAgICAgICAvLyBzZWUgaWYgcmVmbGVjdGVkIGxpZ2h0IHRyYXZlbHMgdG8gY2FtZXJhIGFuZCBnZW5lcmF0ZSBjb2VmZmljaWVudCBhY2NvcmRpbmdseVxcbiAgICAgICAgICAgIGZsb2F0IHNwZWN1bGFyQW5nbGUgPSBjbGFtcCggZG90KCBhbmdsZU9mUmVmbGVjdGlvbiwgLXJheURpcmVjdGlvbiApLCAwLiwgMS4gKTtcXG4gICAgICAgICAgICBmbG9hdCBzcGVjdWxhckNvZWZmaWNpZW50ID0gcG93KCBzcGVjdWxhckFuZ2xlLCBtYXQuc2hpbmluZXNzICk7XFxuXFxuICAgICAgICAgICAgLy8gbGlnaHRzIHNob3VsZCBoYXZlIGFuIGF0dGVudWF0aW9uIGZhY3RvclxcbiAgICAgICAgICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4gLyAoIGxpZ2h0LmF0dGVudWF0aW9uICogcG93KCBsZW5ndGgoIGxpZ2h0LnBvc2l0aW9uIC0gc3VyZmFjZVBvc2l0aW9uICksIDIuICkgKTsgXFxuXFxuICAgICAgICAgICAgLy8gYmlhcywgc2NhbGUsIHBvd2VyXFxuICAgICAgICAgICAgZmxvYXQgZnJlc25lbCA9IG1hdC5mcmVzbmVsLnggKyBtYXQuZnJlc25lbC55ICogcG93KCAxLjAgKyBkb3QoIHJheURpcmVjdGlvbiwgbm9ybWFsICksIG1hdC5mcmVzbmVsLnogKTsgXFxuXFxuICAgICAgICAgICAgXCIsXCJcXG5cXG4gICAgICAgICAgICB2ZWMzIGNvbG9yID0gdmVjMyggMC4gKTtcXG4gICAgICAgICAgICBjb2xvciArPSAxLjIgKiBkaWZmdXNlQ29lZmZpY2llbnQgKiBtYXQuZGlmZnVzZSAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDIuMiAqIHNwZWN1bGFyQ29lZmZpY2llbnQgKiBtYXQuc3BlY3VsYXIgKiBsaWdodC5jb2xvcjtcXG4gICAgICAgICAgICBjb2xvciArPSAwLjMgKiAobWF0LmFtYmllbnQgKiBsaWdodC5jb2xvcikgKiBvY2NsdXNpb247XFxuICAgICAgICAgICAgY29sb3IgKz0gKGZyZXNuZWwgKiBsaWdodC5jb2xvcik7XFxuXFxuICAgICAgICAgICAgLy8gdGV4dHVyZVxcbiAgICAgICAgICAgIC8vY29sb3IgKj0gdGV4dHVyZUNvbG9yLnh5ejtcXG5cXG4gICAgICAgICAgICAvLyBnYW1tYSBjb3JyZWN0aW9uIG11c3Qgb2NjdXIgYmVmb3JlIGxpZ2h0IGF0dGVudWF0aW9uXFxuICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgbXVzdCBiZSBhcHBsaWVkIG9uIGEgcGVyLWxpZ2h0IGJhc2lzIHVuZm9ydHVuYXRlbHlcXG4gICAgICAgICAgICB2ZWMzIGdhbW1hQ29ycmVjdGVkQ29sb3IgPSBwb3coIGNvbG9yLCB2ZWMzKCAxLi8yLjIgKSApO1xcbiAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRlZENvbG9yID0gMi4gKiBnYW1tYUNvcnJlY3RlZENvbG9yICogYXR0ZW51YXRpb247IFxcblxcbiAgICAgICAgICAgIG91dHB1dENvbG9yICs9IGF0dGVudWF0ZWRDb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gb3V0cHV0Q29sb3I7XFxuICAgICAgICB9XFxuICAgICAgICBcIixcIlwiXSxfX3NoYWRvdylcblxuICAgICAgICByZXR1cm4gc3RyXG4gICAgICB9LCBcbiAgICAgIHBob25nVCggbnVtbGlnaHRzLCBsaWdodHMsIG1hdGVyaWFscyApIHtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gU0RGLl9fc2NlbmUuX19zaGFkb3dcblxuICAgICAgICBjb25zdCBfX3NoYWRvdyA9IHNoYWRvdyA+IDBcbiAgICAgICAgICA/IGBkaWZmdXNlQ29lZmZpY2llbnQgKj0gc29mdHNoYWRvdyggc3VyZmFjZVBvc2l0aW9uLCBub3JtYWxpemUoIGxpZ2h0LnBvc2l0aW9uICksIDAuMDIsIDIuNSwgJHtzaGFkb3cudG9GaXhlZCgxKX0gKTtgIFxuICAgICAgICAgIDogJydcblxuICAgICAgICBjb25zdCBzdHIgPSBnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICBcXG5cXG4gICAgICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSApIHtcXG4gICAgICAgICAgdmVjMyAgb3V0cHV0Q29sb3IgICA9IHZlYzMoIDAuICk7XFxuICAgXFxuICAgICAgICAgIC8vIGFwcGxpZXMgdG8gYWxsIGxpZ2h0c1xcbiAgICAgICAgICBmbG9hdCBvY2NsdXNpb24gPSBhbyggc3VyZmFjZVBvc2l0aW9uLCBub3JtYWwgKTtcXG5cXG4gICAgICAgICAgdmVjNCB0ZXh0dXJlQ29sb3I7XFxuICAgICAgICAgIGlmKCBtYXQudGV4dHVyZUlEID4gLTEgKSB7XFxuICAgICAgICAgICAgLy90ZXh0dXJlQ29sb3IgPSB0ZXhjdWJlKCB0ZXh0dXJlc1sgbWF0LnRleHR1cmVJRCBdLCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgMS4gKTsvL3RleHR1cmUoIHRleHR1cmVzWyBtYXQudGV4dHVyZUlEIF0sIHN1cmZhY2VQb3NpdGlvbi54eSAtIG5vcm1hbC54eSApOyBcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gZ2V0VVZDdWJpYyggc3VyZmFjZVBvc2l0aW9uLCB2ZWMzKDAuKSApOy8vc3VyZmFjZVBvc2l0aW9uLnh6KnZlYzIoMC4wMywwLjA3KTtcXG4gICAgICAgICAgICB0ZXh0dXJlQ29sb3IgPSB0ZXh0dXJlKCB0ZXh0dXJlc1sgbWF0LnRleHR1cmVJRCBdLCB1diApO1xcbiAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICB0ZXh0dXJlQ29sb3IgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvdXRwdXRDb2xvciA9IDA7Ly90ZXh0dXJlQ29sb3IueHl6O1xcblxcbiAgICAgICAgICBmb3IoIGludCBpID0gMDsgaSA8IDIwMDAwOyBpKysgKSB7XFxuICAgICAgICAgICAgaWYoIGkgPj0gTUFYX0xJR0hUUyApIGJyZWFrO1xcblxcbiAgICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XFxuXFxuICAgICAgICAgICAgdmVjMyBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAvLyBnZXQgc2ltaWxhcml0eSBiZXR3ZWVuIG5vcm1hbCBhbmQgZGlyZWN0aW9uIHRvIGxpZ2h0XFxuICAgICAgICAgICAgZmxvYXQgZGlmZnVzZUNvZWZmaWNpZW50ID0gZG90KCBub3JtYWwsIHN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uICk7IFxcblxcbiAgICAgICAgICAgIC8vIGdldCByZWZsZWN0aW9uIGFuZ2xlIGZvciBsaWdodCBzdHJpa2luZyBzdXJmYWNlXFxuICAgICAgICAgICAgdmVjMyBhbmdsZU9mUmVmbGVjdGlvbiA9IHJlZmxlY3QoIC1zdXJmYWNlVG9MaWdodERpcmVjdGlvbiwgbm9ybWFsICk7XFxuXFxuICAgICAgICAgICAgLy8gc2VlIGlmIHJlZmxlY3RlZCBsaWdodCB0cmF2ZWxzIHRvIGNhbWVyYSBhbmQgZ2VuZXJhdGUgY29lZmZpY2llbnQgYWNjb3JkaW5nbHlcXG4gICAgICAgICAgICBmbG9hdCBzcGVjdWxhckFuZ2xlID0gY2xhbXAoIGRvdCggYW5nbGVPZlJlZmxlY3Rpb24sIC1yYXlEaXJlY3Rpb24gKSwgMC4sIDEuICk7XFxuICAgICAgICAgICAgZmxvYXQgc3BlY3VsYXJDb2VmZmljaWVudCA9IHBvdyggc3BlY3VsYXJBbmdsZSwgbWF0LnNoaW5pbmVzcyApO1xcblxcbiAgICAgICAgICAgIC8vIGxpZ2h0cyBzaG91bGQgaGF2ZSBhbiBhdHRlbnVhdGlvbiBmYWN0b3JcXG4gICAgICAgICAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuIC8gKCBsaWdodC5hdHRlbnVhdGlvbiAqIHBvdyggbGVuZ3RoKCBsaWdodC5wb3NpdGlvbiAtIHN1cmZhY2VQb3NpdGlvbiApLCAyLiApICk7IFxcblxcbiAgICAgICAgICAgIC8vIGJpYXMsIHNjYWxlLCBwb3dlclxcbiAgICAgICAgICAgIGZsb2F0IGZyZXNuZWwgPSBtYXQuZnJlc25lbC54ICsgbWF0LmZyZXNuZWwueSAqIHBvdyggMS4wICsgZG90KCByYXlEaXJlY3Rpb24sIG5vcm1hbCApLCBtYXQuZnJlc25lbC56ICk7IFxcblxcbiAgICAgICAgICAgIFwiLFwiXFxuXFxuICAgICAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoIDAuICk7XFxuICAgICAgICAgICAgY29sb3IgKz0gMS4yICogZGlmZnVzZUNvZWZmaWNpZW50ICogdGV4dHVyZUNvbG9yLnh5eiAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDIuMiAqIHNwZWN1bGFyQ29lZmZpY2llbnQgKiB0ZXh0dXJlQ29sb3IueHl6ICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgICAgY29sb3IgKz0gMC4zICogKG1hdC5hbWJpZW50ICogbGlnaHQuY29sb3IpICogb2NjbHVzaW9uO1xcbiAgICAgICAgICAgIGNvbG9yICs9IChmcmVzbmVsICogbGlnaHQuY29sb3IpO1xcblxcbiAgICAgICAgICAgIC8vIHRleHR1cmVcXG4gICAgICAgICAgICAvL2NvbG9yICo9IHRleHR1cmVDb2xvci54eXo7XFxuXFxuICAgICAgICAgICAgLy8gZ2FtbWEgY29ycmVjdGlvbiBtdXN0IG9jY3VyIGJlZm9yZSBsaWdodCBhdHRlbnVhdGlvblxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IG11c3QgYmUgYXBwbGllZCBvbiBhIHBlci1saWdodCBiYXNpcyB1bmZvcnR1bmF0ZWx5XFxuICAgICAgICAgICAgdmVjMyBnYW1tYUNvcnJlY3RlZENvbG9yID0gcG93KCBjb2xvciwgdmVjMyggMS4vMi4yICkgKTtcXG4gICAgICAgICAgICB2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IDIuICogZ2FtbWFDb3JyZWN0ZWRDb2xvciAqIGF0dGVudWF0aW9uOyBcXG5cXG4gICAgICAgICAgICBvdXRwdXRDb2xvciArPSBhdHRlbnVhdGVkQ29sb3I7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG91dHB1dENvbG9yO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCIsXCJcIl0sX19zaGFkb3cpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSwgXG5cblxuICAgICAgb3Jlbm4oIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMgKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IFNERi5fX3NjZW5lLl9fc2hhZG93XG4gICAgICAgIGNvbnN0IF9fc2hhZG93ID0gc2hhZG93ID4gMFxuICAgICAgICAgID8gYGRpZmZ1c2VDb2VmZmljaWVudCAqPSBzb2Z0c2hhZG93KCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gKSwgMC4wMiwgMi41LCAke3NoYWRvdy50b0ZpeGVkKDEpfSApO2AgXG4gICAgICAgICAgOiAnJ1xuXG4gICAgICAgIGNvbnN0IHN0ciA9IGdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gIFxcbiAgICAgICAgZmxvYXQgb3Jlbk5heWFyRGlmZnVzZShcXG4gIHZlYzMgbGlnaHREaXJlY3Rpb24sXFxuICB2ZWMzIHZpZXdEaXJlY3Rpb24sXFxuICB2ZWMzIHN1cmZhY2VOb3JtYWwsXFxuICBmbG9hdCByb3VnaG5lc3MsXFxuICBmbG9hdCBhbGJlZG8pIHtcXG4gIFxcbiAgZmxvYXQgTGRvdFYgPSBkb3QobGlnaHREaXJlY3Rpb24sIHZpZXdEaXJlY3Rpb24pO1xcbiAgZmxvYXQgTmRvdEwgPSBkb3QobGlnaHREaXJlY3Rpb24sIHN1cmZhY2VOb3JtYWwpO1xcbiAgZmxvYXQgTmRvdFYgPSBkb3Qoc3VyZmFjZU5vcm1hbCwgdmlld0RpcmVjdGlvbik7XFxuXFxuICBmbG9hdCBzID0gTGRvdFYgLSBOZG90TCAqIE5kb3RWO1xcbiAgZmxvYXQgdCA9IG1peCgxLjAsIG1heChOZG90TCwgTmRvdFYpLCBzdGVwKDAuMCwgcykpO1xcblxcbiAgZmxvYXQgc2lnbWEyID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xcbiAgZmxvYXQgQSA9IDEuMCArIHNpZ21hMiAqIChhbGJlZG8gLyAoc2lnbWEyICsgMC4xMykgKyAwLjUgLyAoc2lnbWEyICsgMC4zMykpO1xcbiAgZmxvYXQgQiA9IDAuNDUgKiBzaWdtYTIgLyAoc2lnbWEyICsgMC4wOSk7XFxuXFxuICByZXR1cm4gYWxiZWRvICogbWF4KDAuMCwgTmRvdEwpICogKEEgKyBCICogcyAvIHQpIC8gMy4xNDE1OTI2NTtcXG59XFxuXFxuICAgICAgICBmbG9hdCBnYXVzc2lhblNwZWN1bGFyKFxcbiAgdmVjMyBsaWdodERpcmVjdGlvbixcXG4gIHZlYzMgdmlld0RpcmVjdGlvbixcXG4gIHZlYzMgc3VyZmFjZU5vcm1hbCxcXG4gIGZsb2F0IHNoaW5pbmVzcykge1xcbiAgdmVjMyBIID0gbm9ybWFsaXplKGxpZ2h0RGlyZWN0aW9uICsgdmlld0RpcmVjdGlvbik7XFxuICBmbG9hdCB0aGV0YSA9IGFjb3MoZG90KEgsIHN1cmZhY2VOb3JtYWwpKTtcXG4gIGZsb2F0IHcgPSB0aGV0YSAvIHNoaW5pbmVzcztcXG4gIHJldHVybiBleHAoLXcqdyk7XFxufVxcblxcbiAgICAgICAgdmVjMyBvcmVubiggdmVjMyBzdXJmYWNlUG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIE1hdGVyaWFsIG1hdCwgTGlnaHQgbGlnaHRzW01BWF9MSUdIVFNdICkge1xcbiAgICAgICAgICB2ZWMzICBvdXRwdXRDb2xvciAgID0gdmVjMyggMC4gKTtcXG4gICBcXG4gICAgICAgICAgLy8gYXBwbGllcyB0byBhbGwgbGlnaHRzXFxuICAgICAgICAgIGZsb2F0IG9jY2x1c2lvbiA9IGFvKCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCApO1xcblxcbiAgICAgICAgICBmb3IoIGludCBpID0gMDsgaSA8IDIwMDAwOyBpKysgKSB7XFxuICAgICAgICAgICAgaWYoIGkgPj0gTUFYX0xJR0hUUyApIGJyZWFrO1xcblxcbiAgICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XFxuXFxuICAgICAgICAgICAgdmVjMyBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAvLyBnZXQgc2ltaWxhcml0eSBiZXR3ZWVuIG5vcm1hbCBhbmQgZGlyZWN0aW9uIHRvIGxpZ2h0XFxuICAgICAgICAgICAgZmxvYXQgZGlmZnVzZUNvZWZmaWNpZW50ID0gb3Jlbk5heWFyRGlmZnVzZSggc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24sIC1yYXlEaXJlY3Rpb24sIG5vcm1hbCwgMC4xNSwgNC4wKTtcXG5cXG4gICAgICAgICAgICAvLyBnZXQgcmVmbGVjdGlvbiBhbmdsZSBmb3IgbGlnaHQgc3RyaWtpbmcgc3VyZmFjZVxcbiAgICAgICAgICAgIHZlYzMgYW5nbGVPZlJlZmxlY3Rpb24gPSByZWZsZWN0KCAtc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24sIG5vcm1hbCApO1xcblxcbiAgICAgICAgICAgIC8vIHNlZSBpZiByZWZsZWN0ZWQgbGlnaHQgdHJhdmVscyB0byBjYW1lcmEgYW5kIGdlbmVyYXRlIGNvZWZmaWNpZW50IGFjY29yZGluZ2x5XFxuICAgICAgICAgICAgZmxvYXQgc3BlY3VsYXJBbmdsZSA9IGNsYW1wKCBkb3QoIGFuZ2xlT2ZSZWZsZWN0aW9uLCAtcmF5RGlyZWN0aW9uICksIDAuLCAxLiApO1xcbiAgICAgICAgICAgIGZsb2F0IHNwZWN1bGFyQ29lZmZpY2llbnQgPSBnYXVzc2lhblNwZWN1bGFyKCBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiwgLXJheURpcmVjdGlvbiwgbm9ybWFsLCAuNSApOyBcXG5cXG4gICAgICAgICAgICAvLyBsaWdodHMgc2hvdWxkIGhhdmUgYW4gYXR0ZW51YXRpb24gZmFjdG9yXFxuICAgICAgICAgICAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLiAvICggbGlnaHQuYXR0ZW51YXRpb24gKiBwb3coIGxlbmd0aCggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKSwgMi4gKSApOyBcXG5cXG4gICAgICAgICAgICBmbG9hdCBmcmVzbmVsID0gbWF0LmZyZXNuZWwueCArIG1hdC5mcmVzbmVsLnkgKiBwb3coIDEuMCArIGRvdCggcmF5RGlyZWN0aW9uLCBub3JtYWwgKSwgbWF0LmZyZXNuZWwueiApOyBcXG5cXG4gICAgICAgICAgICBcIixcIlxcblxcbiAgICAgICAgICAgIHZlYzMgY29sb3IgPSB2ZWMzKCAwLiApO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDEuMiAqIGRpZmZ1c2VDb2VmZmljaWVudCAqIG1hdC5kaWZmdXNlICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgICAgY29sb3IgKz0gMi4yICogc3BlY3VsYXJDb2VmZmljaWVudCAqIG1hdC5zcGVjdWxhciAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDAuMyAqIChtYXQuYW1iaWVudCAqIGxpZ2h0LmNvbG9yKSAqIG9jY2x1c2lvbjtcXG4gICAgICAgICAgICBjb2xvciArPSAoZnJlc25lbCAqIGxpZ2h0LmNvbG9yKTtcXG5cXG4gICAgICAgICAgICAvLyBnYW1tYSBjb3JyZWN0aW9uIG11c3Qgb2NjdXIgYmVmb3JlIGxpZ2h0IGF0dGVudWF0aW9uXFxuICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgbXVzdCBiZSBhcHBsaWVkIG9uIGEgcGVyLWxpZ2h0IGJhc2lzIHVuZm9ydHVuYXRlbHlcXG4gICAgICAgICAgICB2ZWMzIGdhbW1hQ29ycmVjdGVkQ29sb3IgPSBwb3coIGNvbG9yLCB2ZWMzKCAxLi8yLjIgKSApO1xcbiAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRlZENvbG9yID0gMi4gKiBnYW1tYUNvcnJlY3RlZENvbG9yICogYXR0ZW51YXRpb247IFxcblxcbiAgICAgICAgICAgIG91dHB1dENvbG9yICs9IGF0dGVudWF0ZWRDb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gb3V0cHV0Q29sb3I7XFxuICAgICAgICB9XCIsXCJcIl0sX19zaGFkb3cpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSwgXG5cblxuICAgICAgZ2xvYmFsX3NhdmUoIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMsIHNoYWRvdz0nJyApIHtcbiAgICAgICAgY29uc3Qgc3RyID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcblxcbiAgICAgICAgZmxvYXQgYW8oIGluIHZlYzMgcG9zLCBpbiB2ZWMzIG5vciApXFxue1xcblxcdGZsb2F0IG9jYyA9IDAuMDtcXG4gICAgZmxvYXQgc2NhID0gMS4wO1xcbiAgICBmb3IoIGludCBpPTA7IGk8NTsgaSsrIClcXG4gICAge1xcbiAgICAgICAgZmxvYXQgaHIgPSAwLjAxICsgMC4xMiAqIGZsb2F0KCBpICkgLyA0LjA7XFxuICAgICAgICB2ZWMzIGFvcG9zID0gIG5vciAqIGhyICsgcG9zO1xcbiAgICAgICAgZmxvYXQgZGQgPSBzY2VuZSAoIGFvcG9zICkueDtcXG4gICAgICAgIG9jYyArPSAtKGRkLWhyKSpzY2E7XFxuICAgICAgICBzY2EgKj0gMC45NTtcXG4gICAgfVxcbiAgICByZXR1cm4gY2xhbXAoIDEuMCAtIDMuMCpvY2MsIDAuMCwgMS4wICk7ICAgIFxcbn1cXG5cXG4gICAgICAgIFwiLFwiXFxuXFxuICAgICAgICBcIixcIlxcblxcbiAgICAgICAgdmVjMyBsaWdodGluZyggdmVjMyBwb3MsIHZlYzMgbm9yLCB2ZWMzIHJvLCB2ZWMzIHJkLCBmbG9hdCBtYXRlcmlhbElEICkge1xcbiAgICAgICAgICBMaWdodCBsaWdodCA9IGxpZ2h0c1sgMCBdO1xcbiAgICAgICAgICB2ZWMzICByZWYgPSByZWZsZWN0KCByZCwgbm9yICk7IC8vIHJlZmxlY3Rpb24gYW5nbGVcXG4gICAgICAgICAgZmxvYXQgb2NjID0gYW8oIHBvcywgbm9yICk7XFxuICAgICAgICAgIHZlYzMgIGxpZyA9IG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gKTsgLy8gbGlnaHQgcG9zaXRpb25cXG4gICAgICAgICAgZmxvYXQgYW1iID0gY2xhbXAoIDAuNSArIDAuNSAqIG5vci55LCAwLjAsIDEuMCApO1xcbiAgICAgICAgICBmbG9hdCBkaWYgPSBjbGFtcCggZG90KCBub3IsIGxpZyApLCAwLjAsIDEuMCApO1xcblxcbiAgICAgICAgICAvLyBzaW11bGF0ZWQgYmFja2xpZ2h0XFxuICAgICAgICAgIGZsb2F0IGJhYyA9IGNsYW1wKCBkb3QoIG5vciwgbm9ybWFsaXplKCB2ZWMzKCAtbGlnLngsIDAuMCAsIC1saWcueiApKSksIDAuMCwgMS4wICkgKiBjbGFtcCggMS4wLXBvcy55LCAwLjAgLDEuMCApO1xcblxcbiAgICAgICAgICAvLyBzaW11bGF0ZWQgc2t5ZG9tZSBsaWdodFxcbiAgICAgICAgICBmbG9hdCBkb20gPSBzbW9vdGhzdGVwKCAtMC4xLCAwLjEsIHJlZi55ICk7XFxuICAgICAgICAgIGZsb2F0IGZyZSA9IHBvdyggY2xhbXAoIDEuMCArIGRvdCggbm9yLHJkICksMC4wLDEuMCApLCAyLjAgKTtcXG4gICAgICAgICAgZmxvYXQgc3BlID0gcG93KCBjbGFtcCggZG90KCByZWYsIGxpZyApLCAwLjAsIDEuMCApLCA4LjAgKTtcXG5cXG4gICAgICAgICAgZGlmICo9IHNvZnRzaGFkb3coIHBvcywgbGlnLCAwLjAyLCAyLjUsIDguICk7XFxuICAgICAgICAgIGRvbSAqPSBzb2Z0c2hhZG93KCBwb3MsIHJlZiwgMC4wMiwgMi41LCA4LiApO1xcblxcbiAgICAgICAgICBNYXRlcmlhbCBtYXQgPSBtYXRlcmlhbHNbIGludChtYXRlcmlhbElEKSBdO1xcblxcbiAgICAgICAgICB2ZWMzIGJyZGYgPSB2ZWMzKCAwLjAgKTtcXG4gICAgICAgICAgYnJkZiArPSAxLjIwICogZGlmICogdmVjMyggMS4wMCwwLjkwLDAuNjAgKSAqIG1hdC5kaWZmdXNlICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgIGJyZGYgKz0gMi4yMCAqIHNwZSAqIHZlYzMoIDEuMDAsMC45MCwwLjYwICkgKiBkaWYgKiBtYXQuc3BlY3VsYXIgKiBsaWdodC5jb2xvcjtcXG4gICAgICAgICAgYnJkZiArPSAwLjMwICogYW1iICogdmVjMyggMC41MCwwLjcwLDEuMDAgKSAqIG9jYyAqIG1hdC5hbWJpZW50ICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgIGJyZGYgKz0gMC40MCAqIGRvbSAqIHZlYzMoIDAuNTAsMC43MCwxLjAwICkgKiBvY2M7XFxuICAgICAgICAgIGJyZGYgKz0gMC43MCAqIGJhYyAqIHZlYzMoIDAuMjUgKSAqIG9jYztcXG4gICAgICAgICAgYnJkZiArPSAwLjQwICogKGZyZSAqIGxpZ2h0LmNvbG9yKSAqIG9jYztcXG5cXG4gICAgICAgICAgcmV0dXJuIGJyZGY7XFxuICAgICAgICB9XCIsXCJcIl0sbWF0ZXJpYWxzLGxpZ2h0cylcblxuICAgICAgICByZXR1cm4gc3RyXG5cbiAgICAgIH0sXG5cbiAgICAgIG5vcm1hbCgpIHsgcmV0dXJuICcnIH0sXG4gICAgICBub2lzZSgpIHsgcmV0dXJuICcnIH1cbiAgICB9LFxuICB9XG5cbiAgcmV0dXJuIExpZ2h0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGlnaHRzXG5cbi8vIG9sZCBsaWdodGluZ1xuLypcbiovXG4iLCJjb25zdCBTREYgPSB7XHJcbiAgY2FtZXJhOiAgICAgICAgICAgcmVxdWlyZSggJy4vY2FtZXJhLmpzJyApLFxyXG4gIF9fcHJpbWl0aXZlczogICAgIHJlcXVpcmUoICcuL3ByaW1pdGl2ZXMuanMnICksXHJcbiAgdmVjdG9yczogICAgICAgICAgcmVxdWlyZSggJy4vdmVjLmpzJyApLFxyXG4gIGRpc3RhbmNlT3BzOiAgICAgIHJlcXVpcmUoICcuL2Rpc3RhbmNlT3BlcmF0aW9ucy5qcycgKSxcclxuICBhbHRlcmF0aW9uczogICAgICByZXF1aXJlKCAnLi9hbHRlcmF0aW9ucy5qcycgKSxcclxuICBkaXN0YW5jZURlZm9ybXM6ICByZXF1aXJlKCAnLi9kaXN0YW5jZURlZm9ybWF0aW9ucy5qcycgKSxcclxuICBfX2RvbWFpbk9wczogICAgICByZXF1aXJlKCAnLi9kb21haW5PcGVyYXRpb25zLmpzJyApLFxyXG4gIF9fbm9pc2U6ICAgICAgICAgIHJlcXVpcmUoICcuL25vaXNlLmpzJyApLFxyXG4gIF9fc2NlbmU6ICAgICAgICAgIHJlcXVpcmUoICcuL3NjZW5lLmpzJyApLFxyXG4gIF9fbGlnaHRpbmc6ICAgICAgIHJlcXVpcmUoICcuL2xpZ2h0aW5nLmpzJyApLFxyXG4gIF9fbWF0ZXJpYWxzOiAgICAgIHJlcXVpcmUoICcuL21hdGVyaWFsLmpzJyApLFxyXG4gIF9fdGV4dHVyZXM6ICAgICAgIHJlcXVpcmUoICcuL3RleHR1cmUuanMnICksXHJcbiAgVmFyOiAgICAgICAgICAgICAgcmVxdWlyZSggJy4vdmFyLmpzJyApLlZhcixcclxuICAvL0NvbG9yOiAgICAgICAgICAgIHJlcXVpcmUoICcuL2NvbG9yLmpzJyApLFxyXG4gIEZGVDogICAgICAgICAgICAgIHJlcXVpcmUoICcuL2F1ZGlvLmpzJyApLFxyXG5cclxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIHRoZSBmcmFnbWVudCBzaGFkZXJcclxuICByZW5kZXJGcmFnbWVudFNoYWRlcjogcmVxdWlyZSggJy4vcmVuZGVyRnJhZ21lbnRTaGFkZXIuanMnICksXHJcblxyXG4gIC8vIGFkZGl0aW9uYWwgY2FsbGJhY2tzIHRoYXQgYXJlIHJ1biBvbmNlIHBlciBmcmFtZVxyXG4gIGNhbGxiYWNrczogW10sXHJcbiAgZ2VvbWV0cmllczogW10sXHJcblxyXG4gIC8vIHRoZSBtYWluIGRyYXdpbmcgY2FsbGJhY2tcclxuICByZW5kZXI6IG51bGwsXHJcblxyXG4gIC8vIHRoZSBzY2VuZSBpcyBhIGNoYWluIG9mIFVuaW9ucyBjb21iaW5pbmcgYWxsIGVsZW1lbnRzIHRvZ2V0aGVyXHJcbiAgc2NlbmU6ICBudWxsLFxyXG5cclxuICAvLyBhIHNwZWVkIG9mIDEgY29ycmVzcG9uZHMgdG8gNjAgZnBzLlxyXG4gIGRlbGF5OiAwLFxyXG4gIF9faXNQYXVzZWQ6ZmFsc2UsXHJcblxyXG4gIGRlZmF1bHRWZXJ0ZXhTb3VyY2U6YCAgICAjdmVyc2lvbiAzMDAgZXNcclxuICAgIGluIHZlYzMgYV9wb3M7XHJcblx0XHRpbiB2ZWMyIGFfdXY7XHJcblx0XHRvdXQgdmVjMiB2X3V2O1xyXG5cclxuXHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0dl91diA9IGFfdXY7XHJcblx0XHRcdGdsX1Bvc2l0aW9uID0gdmVjNChhX3BvcywgMS4wKTtcclxuICAgIH1gXHJcbiAgLFxyXG5cclxuICBleHBvcnQoIG9iaiApIHtcclxuICAgIE9iamVjdC5hc3NpZ24oIFxyXG4gICAgICBvYmosIFxyXG4gICAgICB0aGlzLnByaW1pdGl2ZXMsXHJcbiAgICAgIHRoaXMudmVjdG9ycyxcclxuICAgICAgdGhpcy5kaXN0YW5jZU9wcyxcclxuICAgICAgdGhpcy5kb21haW5PcHMsXHJcbiAgICAgIHRoaXMuZGlzdGFuY2VEZWZvcm1zLFxyXG4gICAgICB0aGlzLmFsdGVyYXRpb25zXHJcbiAgICApXHJcblxyXG4gICAgb2JqLkxpZ2h0ID0gdGhpcy5MaWdodFxyXG4gICAgb2JqLk1hdGVyaWFsID0gdGhpcy5NYXRlcmlhbFxyXG4gICAgb2JqLlRleHR1cmUgID0gdGhpcy5UZXh0dXJlXHJcbiAgICBvYmouY2FtZXJhID0gdGhpcy5jYW1lcmFcclxuICAgIG9iai5jYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcyAvLyBYWFggcmVtb3ZlIG9uY2UgQVBJIHN0b3BzIHVzaW5nIGNhbGxiYWNrc1xyXG4gICAgb2JqLkZGVCA9IHRoaXMuRkZUXHJcbiAgfSxcclxuXHJcbiAgaW5pdCggY2FudmFzLCBzaG91bGRJbml0ID0gZmFsc2UgKSB7XHJcbiAgICB0aGlzLnByaW1pdGl2ZXMgPSB0aGlzLl9fcHJpbWl0aXZlcyggdGhpcyApXHJcbiAgICB0aGlzLlNjZW5lICAgICAgPSB0aGlzLl9fc2NlbmUoIHRoaXMgKVxyXG4gICAgdGhpcy5kb21haW5PcHMgID0gdGhpcy5fX2RvbWFpbk9wcyggdGhpcyApXHJcbiAgICB0aGlzLm5vaXNlICAgICA9IHRoaXMuX19ub2lzZSggdGhpcyApXHJcbiAgICB0aGlzLmV4cG9ydCggdGhpcyApXHJcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcyBcclxuXHJcbiAgICB0aGlzLmxpZ2h0aW5nICAgPSB0aGlzLl9fbGlnaHRpbmcoIHRoaXMgKVxyXG4gICAgdGhpcy5MaWdodCA9IHRoaXMubGlnaHRpbmcubGlnaHRcclxuICAgIHRoaXMubWF0ZXJpYWxzICA9IHRoaXMuX19tYXRlcmlhbHMoIHRoaXMgKVxyXG4gICAgdGhpcy5NYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWxzLm1hdGVyaWFsXHJcbiAgICB0aGlzLnRleHR1cmVzID0gdGhpcy5fX3RleHR1cmVzKCB0aGlzIClcclxuICAgIHRoaXMuVGV4dHVyZSA9IHRoaXMudGV4dHVyZXMudGV4dHVyZVxyXG5cclxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGggXHJcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcclxuICAgIHRoaXMuZ2wgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wyJywgeyBhbnRpYWxpYXM6dHJ1ZSwgYWxwaGE6dHJ1ZSB9KVxyXG5cclxuICB9LFxyXG5cclxuICBpbml0QnVmZmVycygpIHtcclxuICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG4gICAgZ2wuY2xlYXJDb2xvciggMC4wLCAwLjAsIDAuMCwgMC4wIClcclxuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXHJcblxyXG4gICAgY29uc3QgdmJvID0gZ2wuY3JlYXRlQnVmZmVyKClcclxuXHJcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAtMS4wLCAtMS4wLCAwLjAsIDAuMCwgMC4wLFxyXG4gICAgICAxLjAsIC0xLjAsIDAuMCwgMS4wLCAwLjAsXHJcbiAgICAgIC0xLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCxcclxuICAgICAgMS4wLCAxLjAsIDAuMCwgMS4wLCAxLjBcclxuICAgIF0pXHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlciAoZ2wuQVJSQVlfQlVGRkVSLCB2Ym8gKVxyXG4gICAgZ2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKVxyXG5cclxuICAgIGNvbnN0IGlibyA9IGdsLmNyZWF0ZUJ1ZmZlcigpXHJcblxyXG4gICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWzAsIDEsIDIsIDIsIDEsIDNdIClcclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaWJvIClcclxuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyApXHJcbiAgfSxcclxuXHJcbiAgLy8gZ2VuZXJhdGUgc2hhZGVycywgaW5pdGlhbGl6ZSBjYW1lcmEsIHN0YXJ0IHJlbmRlcmluZyBsb29wIFxyXG4gIGNyZWF0ZVNjZW5lKCAuLi5hcmdzICkge1xyXG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLlNjZW5lKCBhcmdzLCB0aGlzLmNhbnZhcyApXHJcblxyXG4gICAgdGhpcy5yZXF1aXJlZEdlb21ldHJpZXMgPSBbXVxyXG4gICAgdGhpcy5yZXF1aXJlZE9wcyA9IFtdXHJcbiAgICB0aGlzLm1lbW8gPSB7fVxyXG5cclxuICAgIHJldHVybiBzY2VuZVxyXG4gIH0sXHJcblxyXG4gIHN0YXJ0KCBmcywgd2lkdGgsIGhlaWdodCwgc2hvdWxkQW5pbWF0ZSApIHtcclxuICAgIGlmKCB0aGlzLnJlbmRlciAhPT0gbnVsbCApIHRoaXMucmVuZGVyLnJ1bm5pbmcgPSBmYWxzZVxyXG5cclxuICAgIHRoaXMuZnMgPSBmc1xyXG4gICAgdGhpcy5jYWxsYmFja3MubGVuZ3RoID0gMFxyXG5cclxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5pbml0V2ViR0woIHRoaXMuZGVmYXVsdFZlcnRleFNvdXJjZSwgZnMsIHdpZHRoLCBoZWlnaHQsIHNob3VsZEFuaW1hdGUgKVxyXG4gICAgdGhpcy5yZW5kZXIucnVubmluZyA9IHRydWVcclxuXHJcbiAgICB0aGlzLmNhbWVyYS5pbml0KCB0aGlzLmdsLCB0aGlzLnByb2dyYW0sIGNiID0+IHsgXHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goIGNiIClcclxuICAgIH0pXHJcblxyXG4gICAgc2V0VGltZW91dCggKCk9PiB0aGlzLnJlbmRlciggMC4wICksIDAgKVxyXG4gIH0sXHJcblxyXG4gIGdlbmVyYXRlU0RGKCBfX3NjZW5lICkge1xyXG4gICAgbGV0IHNjZW5lID0geyBwcmVmYWNlOicnIH1cclxuXHJcbiAgICAvKiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG9iamVjdCBpbiBvdXIgc2NlbmUsIGNoYWluIHBhaXJzIG9mIG9iamVjdHNcclxuICAgICAgIGluIFVuaW9ucy4gU28sIGdpdmVuIG9iamVjdHMgYSxiLGMsIGFuZCBkIGNyZWF0ZTpcclxuXHJcbiAgICAgICBVbmlvbiggYSwgVW5pb24oIGIsIFVuaW9uKCBjLGQgKSApIClcclxuXHJcbiAgICAgICAuLi4gb3Igc29tZXRoaW5nIGxpa2UgdGhhdC4gSWYgdGhlcmUgaXMgb25seSBhIHNpbmdsZSBvYmplY3QsXHJcbiAgICAgICB1c2UgdGhhdCBvYmplY3QgYXMgdGhlIGVudGlyZSBzY2VuZS5cclxuICAgICAqL1xyXG5cclxuICAgIGxldCBvYmpzID0gX19zY2VuZS5vYmpzXHJcbiAgICBpZiggb2Jqcy5sZW5ndGggPiAxICkge1xyXG4gICAgICAvLyByZWR1Y2Ugb2JqZWN0cyB0byBuZXN0ZWQgVW5pb25zXHJcbiAgICAgIHNjZW5lLm91dHB1dCA9IG9ianMucmVkdWNlKCAoIGN1cnJlbnQsIG5leHQgKSA9PiB0aGlzLlVuaW9uKCBjdXJyZW50LCBuZXh0ICkgKVxyXG4gICAgfWVsc2V7XHJcbiAgICAgIHNjZW5lLm91dHB1dCA9IG9ianNbMF1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjcmVhdGUgYW4gZmFuY3kgZW1pdCgpIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIHNjZW5lXHJcbiAgICAvLyB3aXRoIGFuIGlkICMuXHJcblxyXG4gICAgc2NlbmUub3V0cHV0Ll9fZW1pdCA9IHNjZW5lLm91dHB1dC5lbWl0LmJpbmQoIHNjZW5lLm91dHB1dCApXHJcbiAgICBzY2VuZS5vdXRwdXQuZW1pdCA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xyXG4gICAgICBjb25zdCBlbWl0dGVkID0gc2NlbmUub3V0cHV0Ll9fZW1pdCguLi5hcmdzKVxyXG4gICAgICBjb25zdCBvdXRwdXQgPSB7XHJcbiAgICAgICAgb3V0OiAgICAgZW1pdHRlZC5vdXQsXHJcbiAgICAgICAgcHJlZmFjZTogZW1pdHRlZC5wcmVmYWNlIHx8ICcnIFxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gb3V0cHV0IFxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZS5vdXRwdXRcclxuXHJcbiAgICBsZXQgdmFyaWFibGVzRGVjbGFyYXRpb24gPSBzY2VuZS5vdXRwdXQuZW1pdF9kZWNsKClcclxuICAgIGNvbnN0IHNjZW5lUmVuZGVyaW5nID0gc2NlbmUub3V0cHV0LmVtaXQoKVxyXG5cclxuICAgIC8vIGZvZyBldGMuIG1heWJlIG1zYWE/XHJcbiAgICBsZXQgcHAgPSAnJ1xyXG4gICAgZm9yKCBsZXQgcHJvY2Vzc29yIG9mIF9fc2NlbmUucG9zdHByb2Nlc3NpbmcgKSB7XHJcbiAgICAgIHBwICs9IHByb2Nlc3Nvci5lbWl0KClcclxuICAgICAgdmFyaWFibGVzRGVjbGFyYXRpb24gKz0gcHJvY2Vzc29yLmVtaXRfZGVjbCgpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMucG9zdHByb2Nlc3NpbmcgPSBfX3NjZW5lLnBvc3Rwcm9jZXNzaW5nXHJcblxyXG4gICAgcmV0dXJuIFsgdmFyaWFibGVzRGVjbGFyYXRpb24sIHNjZW5lUmVuZGVyaW5nLCBwcCBdXHJcbiAgfSxcclxuXHJcblx0Y29tcGlsZSggdHlwZSwgc291cmNlICkge1xyXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsXHJcblxyXG5cdFx0Y29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIHR5cGUgKTtcclxuXHRcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzb3VyY2UgKVxyXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyIClcclxuXHJcblx0XHRpZiggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSAhPT0gdHJ1ZSApIHtcclxuXHRcdFx0bGV0IGxvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApXHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlciggc2hhZGVyIClcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCBzb3VyY2UgKVxyXG5cdFx0XHRjb25zb2xlLmxvZyggbG9nIClcclxuXHJcblx0XHRcdHJldHVybiBudWxsXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNoYWRlclxyXG5cdH0sXHJcblxyXG4gIGNyZWF0ZVByb2dyYW0oIHZzX3NvdXJjZSwgZnNfc291cmNlICkge1xyXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsXHJcblx0XHRjb25zdCB2cyA9IHRoaXMuY29tcGlsZSggZ2wuVkVSVEVYX1NIQURFUiwgdnNfc291cmNlIClcclxuXHRcdGNvbnN0IGZzID0gdGhpcy5jb21waWxlKCBnbC5GUkFHTUVOVF9TSEFERVIsIGZzX3NvdXJjZSApXHJcblxyXG5cdFx0aWYoIG51bGwgPT09IHZzIHx8IG51bGwgPT09IGZzICkgcmV0dXJuIG51bGxcclxuXHJcblx0XHRjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpXHJcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZzIClcclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnMgKVxyXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKVxyXG5cclxuXHRcdGlmKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApICE9PSB0cnVlICl7XHJcblx0XHRcdGNvbnN0IGxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtIClcclxuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKHZzKVxyXG5cdFx0XHRnbC5kZWxldGVTaGFkZXIoZnMpXHJcblx0XHRcdGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSlcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIGxvZyApXHJcblx0XHRcdHJldHVybiBudWxsXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW1cclxuICB9LFxyXG5cclxuICBjbGVhcigpIHtcclxuICAgIGlmKCB0aGlzLmNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkICkgdGhpcy5jYWxsYmFja3MubGVuZ3RoID0gMFxyXG4gICAgaWYoIHRoaXMucmVuZGVyICE9PSBudWxsICkgdGhpcy5yZW5kZXIucnVubmluZyA9IGZhbHNlXHJcbiAgICB0aGlzLmdlb21ldHJpZXMubGVuZ3RoID0gMFxyXG5cclxuICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG4gICAgZ2wuY2xlYXIoIGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUIClcclxuICB9LFxyXG5cclxuICBwYXVzZSgpIHtcclxuICAgIHRoaXMuX19pc1BhdXNlZCA9ICF0aGlzLl9faXNQYXVzZWRcclxuICB9LFxyXG5cclxuICBpbml0V2ViR0woIHZzX3NvdXJjZSwgZnNfc291cmNlLCB3aWR0aCwgaGVpZ2h0LHNob3VsZEFuaW1hdGU9ZmFsc2UgKSB7XHJcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xcclxuICAgIC8vaWYoIHNob3VsZEluaXQgPT09IHRydWUgKSB0aGlzLmluaXRCdWZmZXJzKClcclxuICAgIHRoaXMuaW5pdEJ1ZmZlcnMoKVxyXG5cclxuXHJcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtID0gdGhpcy5jcmVhdGVQcm9ncmFtKCB2c19zb3VyY2UsIGZzX3NvdXJjZSApXHJcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xyXG5cclxuICAgIGNvbnN0IGxvY19hX3BvcyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9wb3NcIik7XHJcbiAgICBjb25zdCBsb2NfYV91diA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV91dlwiKTtcclxuXHJcbiAgICBjb25zdCBsb2NfdV90aW1lID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidGltZVwiKTtcclxuICAgIGNvbnN0IGxvY191X3Jlc29sdXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJyZXNvbHV0aW9uXCIgKVxyXG5cclxuICAgIHRoaXMucG9zdHByb2Nlc3NpbmcuZm9yRWFjaCggcHAgPT4gcHAudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApIClcclxuXHJcbiAgICB0aGlzLnNjZW5lLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxyXG4gICAgdGhpcy50ZXh0dXJlcy51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcclxuICAgIHRoaXMubWF0ZXJpYWxzLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxyXG4gICAgdGhpcy5saWdodGluZy51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcclxuXHJcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NfYV9wb3MpXHJcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NfYV91dilcclxuXHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY19hX3BvcywgMywgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMClcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jX2FfdXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDEyKVxyXG5cclxuICAgIGdsLnZpZXdwb3J0KCAwLDAsd2lkdGgsaGVpZ2h0IClcclxuICAgIGdsLnVuaWZvcm0yZiggbG9jX3VfcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCApXHJcblxyXG4gICAgbGV0IHRvdGFsX3RpbWUgPSAwLjA7XHJcblxyXG4gICAgZnVuY3Rpb24gY2xhbXAyNTUodikge1xyXG4gICAgICByZXR1cm4gTWF0aC5taW4oIE1hdGgubWF4KCAwLCB2ICogMjU1ICksIDI1NSApXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZyYW1lQ291bnQgPSAwXHJcbiAgICBjb25zdCByZW5kZXIgPSBmdW5jdGlvbiggdGltZXN0YW1wICl7XHJcbiAgICAgIGlmKCByZW5kZXIucnVubmluZyA9PT0gdHJ1ZSAmJiBzaG91bGRBbmltYXRlID09PSB0cnVlICkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJlbmRlciApXHJcbiAgICAgIH1lbHNlIGlmKCByZW5kZXIucnVubmluZyA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgZ2wuY2xlYXIoIGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUIClcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICBpZiggdGhpcy5fX2lzUGF1c2VkID09PSBmYWxzZSApIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZXN0YW1wXHJcblxyXG4gICAgICAgIGlmKCB0aGlzLmRlbGF5ICE9PSAwICYmIHRoaXMuZGVsYXkgPj0gZnJhbWVDb3VudCApIHtcclxuICAgICAgICAgIGZyYW1lQ291bnQrK1xyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfWVsc2UgaWYoIHRoaXMuZGVsYXkgIT09IDAgKSB7XHJcbiAgICAgICAgICBmcmFtZUNvdW50ID0gMFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdG90YWxfdGltZSA9IHRpbWVzdGFtcCAvIDEwMDAuMFxyXG4gICAgICAgIGdsLnVuaWZvcm0xZiggbG9jX3VfdGltZSwgdG90YWxfdGltZSApXHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goIGNiID0+IGNiKCB0b3RhbF90aW1lLCB0aGlzLmN1cnJlbnRUaW1lICkgKVxyXG5cclxuICAgICAgICBpZiggdHlwZW9mIHdpbmRvdy5vbmZyYW1lID09PSAnZnVuY3Rpb24nICkge1xyXG4gICAgICAgICAgd2luZG93Lm9uZnJhbWUoIHRvdGFsX3RpbWUgKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5tYXRlcmlhbHMudXBsb2FkX2RhdGEoIGdsIClcclxuICAgICAgdGhpcy50ZXh0dXJlcy51cGxvYWRfZGF0YSggZ2wgKVxyXG4gICAgICB0aGlzLnNjZW5lLnVwbG9hZF9kYXRhKCBnbCApXHJcbiAgICAgIHRoaXMubGlnaHRpbmcudXBsb2FkX2RhdGEoIGdsIClcclxuICAgICAgdGhpcy5wb3N0cHJvY2Vzc2luZy5mb3JFYWNoKCBwcCA9PiBwcC51cGxvYWRfZGF0YSggZ2wgKSApXHJcblxyXG4gICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKVxyXG5cclxuICAgIH0uYmluZCggU0RGIClcclxuXHJcbiAgICByZW5kZXIucnVubmluZyA9IHRydWVcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyICAgIFxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTREZcclxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApLFxuICAgICAgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKSxcbiAgICAgIHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuIH0gPSByZXF1aXJlKCAnLi92YXIuanMnICksXG4gICAgICB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuXG5cbmNvbnN0IGdsc2wgPSByZXF1aXJlKCAnZ2xzbGlmeScgKVxuXG5jb25zdCBfX01hdGVyaWFscyA9IGZ1bmN0aW9uKCBTREYgKSB7XG5cbiAgY29uc3QgTWF0ZXJpYWxzID0ge1xuICAgIG1hdGVyaWFsczpbXSxcbiAgICBfX21hdGVyaWFsczpbXSxcbiAgICBtb2RlQ29uc3RhbnRzIDogW1xuICAgICAgJ2dsb2JhbCcsXG4gICAgICAnbm9ybWFsJyxcbiAgICAgICdwaG9uZycsXG4gICAgICAnb3Jlbm4nLFxuICAgICAgJ25vaXNlJ1xuICAgIF0sXG5cbiAgICBkZWZhdWx0OiAnZ2xvYmFsJyxcblxuICAgIC8vZGVmYXVsdE1hdGVyaWFsczpgXG4gICAgLy8gIE1hdGVyaWFsIG1hdGVyaWFsc1syXSA9IE1hdGVyaWFsWzJdKFxuICAgIC8vICAgIE1hdGVyaWFsKCAwLCB2ZWMzKCAxLiApLCB2ZWMzKDAuLDAuLDAuKSwgdmVjMygxLiksIDguLCBGcmVzbmVsKCAwLiwgMS4sIDIuKSApLFxuICAgIC8vICAgIE1hdGVyaWFsKCAwLCB2ZWMzKCAxLiApLCB2ZWMzKDEuLDAuLDAuKSwgdmVjMygxLiksIDguLCBGcmVzbmVsKCAwLiwgMS4sIDIuKSApXG4gICAgLy8gICk7XG4gICAgLy9gLFxuXG4gICAgYWRkTWF0ZXJpYWwoIG1hdCApIHtcbiAgICAgIGlmKCBtYXQgPT09IHVuZGVmaW5lZCApIG1hdCA9IE1hdGVyaWFscy5tYXRlcmlhbC5kZWZhdWx0XG5cbiAgICAgIGlmKCBNYXRlcmlhbHMubWF0ZXJpYWxzLmluZGV4T2YoIG1hdCApID09PSAtMSApIHtcbiAgICAgICAgbWF0LmlkID0gTWF0ZXJpYWxJRC5hbGxvYygpXG5cbiAgICAgICAgLy8gd2UgaGF2ZSB0byBkaXJ0eSB0aGUgbWF0ZXJpYWwgc28gdGhhdCBpdHMgZGF0YVxuICAgICAgICAvLyB3aWxsIGJlIHVwbG9hZGVkIHRvIG5ldyBzaGFkZXJzLCBvdGhlcndpc2UgdGhlXG4gICAgICAgIC8vIG1hdGVyaWFsIHdpbGwgb25seSB3b3JrIHRoZSBmaXJzdCB0aW1lIGl0J3MgdXNlZCwgd2hlblxuICAgICAgICAvLyBpdCdzIGRpcnR5IG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAgICBNYXRlcmlhbHMuZGlydHkoIG1hdCApXG5cbiAgICAgICAgTWF0ZXJpYWxzLm1hdGVyaWFscy5wdXNoKCBtYXQgKVxuICAgICAgfSBcblxuICAgICAgcmV0dXJuIG1hdFxuICAgIH0sXG5cbiAgICBtYXRlcmlhbCggbW9kZT0nZ2xvYmFsJywgX19hbWJpZW50LCBfX2RpZmZ1c2UsIF9fc3BlY3VsYXIsIF9fc2hpbmluZXNzLCBfX2ZyZXNuZWwsIF9fdGV4dHVyZT1udWxsICl7XG4gICAgICBsZXQgbW9kZUlkeCA9IE1hdGVyaWFscy5tb2RlQ29uc3RhbnRzLmluZGV4T2YoIG1vZGUgKVxuICAgICAgaWYoIG1vZGVJZHggPT09IC0xICkge1xuICAgICAgICBjb25zb2xlLndhcm4oIGBUaGVyZSBpcyBubyBtYXRlcmlhbCB0eXBlIG5hbWVkICR7bW9kZX0uIFVzaW5nIHRoZSBkZWZhdWx0IG1hdGVyaWFsLCAke01hdGVyaWFscy5kZWZhdWx0fSwgaW5zdGVhZC5gIClcbiAgICAgICAgbW9kZSA9IE1hdGVyaWFscy5kZWZhdWx0XG4gICAgICAgIG1vZGVJZHggPSBNYXRlcmlhbHMubW9kZUNvbnN0YW50cy5pbmRleE9mKCBtb2RlIClcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGVvZiBfX2FtYmllbnQgPT09ICdudW1iZXInICkgX19hbWJpZW50ID0gVmVjMyggX19hbWJpZW50IClcbiAgICAgIGNvbnN0IGFtYmllbnQgPSBwYXJhbV93cmFwKCBfX2FtYmllbnQsIHZlYzNfdmFyX2dlbiguMSwuMSwuMSkgKVxuICAgICAgaWYoIHR5cGVvZiBfX2RpZmZ1c2U9PT0gJ251bWJlcicgKSBfX2RpZmZ1c2U9IFZlYzMoIF9fZGlmZnVzZSApXG4gICAgICBjb25zdCBkaWZmdXNlID0gcGFyYW1fd3JhcCggX19kaWZmdXNlLCB2ZWMzX3Zhcl9nZW4oMCwwLDEpIClcbiAgICAgIGlmKCB0eXBlb2YgX19zcGVjdWxhciA9PT0gJ251bWJlcicgKSBfX3NwZWN1bGFyID0gVmVjMyggX19zcGVjdWxhciApXG4gICAgICBjb25zdCBzcGVjdWxhciA9IHBhcmFtX3dyYXAoIF9fc3BlY3VsYXIsIHZlYzNfdmFyX2dlbigxLDEsMSkgKVxuICAgICAgY29uc3Qgc2hpbmluZXNzID0gcGFyYW1fd3JhcCggX19zaGluaW5lc3MsIGZsb2F0X3Zhcl9nZW4oOCkgKVxuICAgICAgaWYoIHR5cGVvZiBfX2ZyZXNuZWwgPT09ICdudW1iZXInICkgX19mcmVzbmVsID0gVmVjMyggX19mcmVzbmVsIClcbiAgICAgIGNvbnN0IGZyZXNuZWwgPSBwYXJhbV93cmFwKCBfX2ZyZXNuZWwsIHZlYzNfdmFyX2dlbigwLDEsMikgKVxuXG4gICAgICBjb25zdCBtYXQgPSB7IHNoaW5pbmVzcywgbW9kZSwgdGV4dHVyZTpfX3RleHR1cmUsIHR5cGU6J21hdGVyaWFsJyB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggbWF0LCAnYW1iaWVudCcsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gYW1iaWVudCB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICBhbWJpZW50LnNldCggdiApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBhbWJpZW50LnZhbHVlLnggPSB2XG4gICAgICAgICAgICBhbWJpZW50LnZhbHVlLnkgPSB2XG4gICAgICAgICAgICBhbWJpZW50LnZhbHVlLnogPSB2XG4gICAgICAgICAgICBhbWJpZW50LmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgIFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtYXQsICdkaWZmdXNlJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBkaWZmdXNlIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIGRpZmZ1c2Uuc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGRpZmZ1c2UudmFsdWUueCA9IHZcbiAgICAgICAgICAgIGRpZmZ1c2UudmFsdWUueSA9IHZcbiAgICAgICAgICAgIGRpZmZ1c2UudmFsdWUueiA9IHZcbiAgICAgICAgICAgIGRpZmZ1c2UuZGlydHkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSAgXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG1hdCwgJ3NwZWN1bGFyJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBzcGVjdWxhciB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICBzcGVjdWxhci5zZXQoIHYgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc3BlY3VsYXIudmFsdWUueCA9IHZcbiAgICAgICAgICAgIHNwZWN1bGFyLnZhbHVlLnkgPSB2XG4gICAgICAgICAgICBzcGVjdWxhci52YWx1ZS56ID0gdlxuICAgICAgICAgICAgc3BlY3VsYXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSAgXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG1hdCwgJ2ZyZXNuZWwnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIGZyZXNuZWwgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgZnJlc25lbC5zZXQoIHYgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgZnJlc25lbC52YWx1ZS54ID0gdlxuICAgICAgICAgICAgZnJlc25lbC52YWx1ZS55ID0gdlxuICAgICAgICAgICAgZnJlc25lbC52YWx1ZS56ID0gdlxuICAgICAgICAgICAgZnJlc25lbC5kaXJ0eSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pICBcbiAgICAgIC8vT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtYXQsICdzaGluaW5lc3MnLCB7XG4gICAgICAvLyAgZ2V0KCkgeyByZXR1cm4gbWF0LnNoaW5pbmVzcy52YWx1ZSB9LFxuICAgICAgLy8gIHNldCh2KXtcbiAgICAgIC8vICAgIG1hdC5zaGluaW5lc3MudmFsdWUgPSB2XG4gICAgICAvLyAgICBtYXQuc2hpbmluZXNzLmRpcnR5ID0gdHJ1ZVxuICAgICAgLy8gIH1cbiAgICAgIC8vfSkgICAgIC8vXG4gICAgICBcbiAgICAgIHJldHVybiBtYXQgXG4gICAgfSxcblxuICAgIGRpcnR5KCBtYXQgKSB7XG4gICAgICBtYXQuYW1iaWVudC5kaXJ0eSA9IHRydWVcbiAgICAgIG1hdC5kaWZmdXNlLmRpcnR5ID0gdHJ1ZVxuICAgICAgbWF0LnNwZWN1bGFyLmRpcnR5ID0gdHJ1ZVxuICAgICAgbWF0LnNoaW5pbmVzcy5kaXJ0eSA9IHRydWVcbiAgICAgIG1hdC5mcmVzbmVsLmRpcnR5ID0gdHJ1ZVxuICAgICAgaWYoIG1hdC50ZXh0dXJlICE9PSBudWxsICkgbWF0LnRleHR1cmUuZGlydHkgPSB0cnVlXG4gICAgfSxcbiAgIFxuICAgIGVtaXRfbWF0ZXJpYWxzKCkge1xuICAgICAgaWYoIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgY29uc29sZS5sb2coICdyZXR1cm5pbmcgdW5kZWZpbmVkPycsIHRoaXMuZGVmYXVsdE1hdGVyaWFscyApXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRNYXRlcmlhbHMvL3RoaXMuYWRkTWF0ZXJpYWwoKSBcbiAgICAgIH1cblxuICAgICAgbGV0IHN0ciA9IGBNYXRlcmlhbCBtYXRlcmlhbHNbJHt0aGlzLm1hdGVyaWFscy5sZW5ndGh9XSA9IE1hdGVyaWFsWyR7dGhpcy5tYXRlcmlhbHMubGVuZ3RofV0oYFxuXG4gICAgICB0aGlzLm1hdGVyaWFscy5zb3J0KCAoYSxiKSA9PiBhLmlkID4gYi5pZCA/IDEgOiAtMSApIFxuXG4gICAgICBmb3IoIGxldCBtYXQgb2YgdGhpcy5tYXRlcmlhbHMgKSB7XG4gICAgICAgIGNvbnN0IGZyZXNuZWwgPSBgRnJlc25lbCggJHtmKG1hdC5mcmVzbmVsLngpfSwgJHtmKG1hdC5mcmVzbmVsLnkpfSwgJHtmKG1hdC5mcmVzbmVsLnopfSApYFxuXG4gICAgICAgIGNvbnN0IHRleGlkID0gMC8vU0RGLnRleHR1cmVzLnRleHR1cmVzLmluZGV4T2YoIG1hdC50ZXh0dXJlIClcbiAgICAgICAgc3RyICs9IG1hdC50ZXh0dXJlID09PSBudWxsIFxuICAgICAgICAgID8gYFxcbiAgICAgICAgTWF0ZXJpYWwoICR7dGhpcy5tb2RlQ29uc3RhbnRzLmluZGV4T2YoIG1hdC5tb2RlICl9LCAke21hdC5hbWJpZW50LmVtaXQoKX0sICR7bWF0LmRpZmZ1c2UuZW1pdCgpfSwgJHttYXQuc3BlY3VsYXIuZW1pdCgpfSwgJHttYXQuc2hpbmluZXNzLmVtaXQoKX0sICR7bWF0LmZyZXNuZWwuZW1pdCgpfSwgJHsgdGV4aWQgfSApLGAgXG4gICAgICAgICAgOiBgXFxuICAgICAgICBNYXRlcmlhbCggJHt0aGlzLm1vZGVDb25zdGFudHMuaW5kZXhPZiggbWF0Lm1vZGUgKX0sICR7bWF0LmFtYmllbnQuZW1pdCgpfSwgJHttYXQuZGlmZnVzZS5lbWl0KCl9LCAke21hdC5zcGVjdWxhci5lbWl0KCl9LCAke21hdC5zaGluaW5lc3MuZW1pdCgpfSwgJHttYXQuZnJlc25lbC5lbWl0KCl9LCAkeyB0ZXhpZCB9ICksYCBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsLTEpIC8vIHJlbW92ZSB0cmFpbGluZyBjb21tYVxuXG4gICAgICBzdHIgKz0gJ1xcbiAgICAgICk7J1xuXG4gICAgICB0aGlzLl9fbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHMuc2xpY2UoIDAgKVxuICAgICAgdGhpcy5tYXRlcmlhbHMubGVuZ3RoID0gMFxuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIGVtaXRfZGVjbCgpIHtcbiAgICAgIGxldCBzdHIgPSAnJ1xuICAgICAgZm9yKCBsZXQgbWF0IG9mIHRoaXMuX19tYXRlcmlhbHMgKSB7XG4gICAgICAgIHN0ciArPSBtYXQuYW1iaWVudC5lbWl0X2RlY2woKVxuICAgICAgICBzdHIgKz0gbWF0LmRpZmZ1c2UuZW1pdF9kZWNsKClcbiAgICAgICAgc3RyICs9IG1hdC5zcGVjdWxhci5lbWl0X2RlY2woKVxuICAgICAgICBzdHIgKz0gbWF0LnNoaW5pbmVzcy5lbWl0X2RlY2woKVxuICAgICAgICBzdHIgKz0gbWF0LmZyZXNuZWwuZW1pdF9kZWNsKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0clxuICAgIH0sXG5cbiAgICB1cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgZm9yKCBsZXQgbWF0IG9mIHRoaXMuX19tYXRlcmlhbHMgKSB7XG4gICAgICAgIGlmKCBtYXQuYW1iaWVudC5kaXJ0eSA9PT0gdHJ1ZSApICAgbWF0LmFtYmllbnQudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuZGlmZnVzZS5kaXJ0eSA9PT0gdHJ1ZSApICAgbWF0LmRpZmZ1c2UudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuc3BlY3VsYXIuZGlydHkgPT09IHRydWUgKSAgbWF0LnNwZWN1bGFyLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LnNoaW5pbmVzcy5kaXJ0eSA9PT0gdHJ1ZSApIG1hdC5zaGluaW5lc3MudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuZnJlc25lbC5kaXJ0eSA9PT0gdHJ1ZSApICAgbWF0LmZyZXNuZWwudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbT0nJyApIHtcbiAgICAgIGZvciggbGV0IG1hdCBvZiB0aGlzLl9fbWF0ZXJpYWxzICkge1xuICAgICAgICBpZiggbWF0LmFtYmllbnQuZGlydHkgPT09IHRydWUgKSAgIG1hdC5hbWJpZW50LnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuZGlmZnVzZS5kaXJ0eSA9PT0gdHJ1ZSApICAgbWF0LmRpZmZ1c2UudXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIG1hdC5zcGVjdWxhci5kaXJ0eSA9PT0gdHJ1ZSApICBtYXQuc3BlY3VsYXIudXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIG1hdC5zaGluaW5lc3MuZGlydHkgPT09IHRydWUgKSBtYXQuc2hpbmluZXNzLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuZnJlc25lbC5kaXJ0eSA9PT0gdHJ1ZSApICAgbWF0LmZyZXNuZWwudXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IGYgPSB2YWx1ZSA9PiB2YWx1ZSAlIDEgPT09IDAgPyB2YWx1ZS50b0ZpeGVkKDEpIDogdmFsdWUgXG5cbiAgT2JqZWN0LmFzc2lnbiggTWF0ZXJpYWxzLm1hdGVyaWFsLCB7XG4gICAgZGVmYXVsdCA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoIC4xNSApLCBWZWMzKDApLCBWZWMzKDEpLCA4LCBWZWMzKCAwLCAxLCAuNSApICksICBcbiAgICByZWQgICAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnZ2xvYmFsJywgVmVjMyguMjUsMCwwKSwgVmVjMygxLDAsMCksIFZlYzMoMCksIDIsIFZlYzMoMCkgKSxcbiAgICBncmVlbiAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnZ2xvYmFsJywgVmVjMygwLC4yNSwwKSwgVmVjMygwLDEsMCksIFZlYzMoMCksIDIsIFZlYzMoMCkgKSxcbiAgICBibHVlICAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnZ2xvYmFsJywgVmVjMygwLDAsLjI1KSwgVmVjMygwLDAsMSksIFZlYzMoMCksIDIsIFZlYzMoMCkgKSxcbiAgICBjeWFuICAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnZ2xvYmFsJywgVmVjMygwLC4yNSwuMjUpLCBWZWMzKDAsMSwxKSwgVmVjMygwKSwgMiwgVmVjMygwKSApLFxuICAgIG1hZ2VudGEgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKC4yNSwwLC4yNSksIFZlYzMoMSwwLDEpLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgeWVsbG93ICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoLjI1LC4yNSwuMCksIFZlYzMoMSwxLDApLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgYmxhY2sgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoMCwgMCwgMCksIFZlYzMoMCwwLDApLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgd2hpdGUgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoLjI1KSwgVmVjMygxKSwgVmVjMygxKSwgMiwgVmVjMygwKSApLFxuICAgIGdyZXkgICAgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKC4yNSksIFZlYzMoLjMzKSwgVmVjMygxKSwgMiwgVmVjMygwKSApLFxuXG4gICAgJ3doaXRlIGdsb3cnIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAncGhvbmcnLCAgVmVjMyguMDE1KSwgVmVjMygxKSwgVmVjMygxKSwgMTYsIFZlYzMoMCwyMDAsNSkgKSxcbiAgICBnbHVlICAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAncGhvbmcnLCAgVmVjMyguMDE1KSwgVmVjMygxKSwgVmVjMygxKSwgMTYsIFZlYzMoMCwxNSwtLjEpICksXG4gICAgaW52ZXJzZSA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ3Bob25nJywgMSwgLjUsIDEsIDE2LCBWZWMzKDEsLjUsLTIpICksXG5cbiAgICBub3JtYWwgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnbm9ybWFsJyApLFxuICAgIG5vaXNlICAgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdub2lzZScsICBWZWMzKCAuMTUgKSwgVmVjMygxLDAsMCksIFZlYzMoMSksIDgsIFZlYzMoIDAsIDEsIC41ICkpXG4gIH0pXG5cbiAgcmV0dXJuIE1hdGVyaWFsc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fTWF0ZXJpYWxzXG4iLCJjb25zdCBnbHNsID0gcmVxdWlyZSggJ2dsc2xpZnknIClcbmNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKVxuY29uc3QgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxuY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4gfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuXG5jb25zdCBnZXROb2lzZSA9IGZ1bmN0aW9uKCBTREYgKSB7XG5Ob2lzZSA9IGZ1bmN0aW9uKCBzdHJlbmd0aD0uMjUsIGJpYXM9MSwgdGltZU1vZD0xICkge1xuICBjb25zdCBvcCA9IE9iamVjdC5jcmVhdGUoIE5vaXNlLnByb3RvdHlwZSApXG4gIG9wLnR5cGUgPSAnc3RyaW5nJ1xuICBvcC5pc0dlbiA9IHRydWVcblxuICBjb25zdCBkZWZhdWx0VmFsdWVzID0gWy41LC41LC41XVxuXG4gIG9wLm1hdElkID0gTWF0ZXJpYWxJRC5hbGxvYygpXG5cbiAgY29uc3QgX19zdHJlbmd0aCA9IHBhcmFtX3dyYXAoIHN0cmVuZ3RoLCBmbG9hdF92YXJfZ2VuKCBzdHJlbmd0aCApIClcbiAgY29uc3QgX190aW1lTW9kICA9IHBhcmFtX3dyYXAoIHRpbWVNb2QsIGZsb2F0X3Zhcl9nZW4oIHRpbWVNb2QgKSApXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvcCwgJ3N0cmVuZ3RoJywge1xuICAgIGdldCgpIHsgcmV0dXJuIF9fc3RyZW5ndGggfSxcbiAgICBzZXQodikge1xuICAgICBfX3N0cmVuZ3RoLnZhci5zZXQoIHYgKVxuICAgIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvcCwgJ3RpbWVNb2QnLCB7XG4gICAgZ2V0KCkgeyByZXR1cm4gX190aW1lTW9kIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgX190aW1lTW9kLnZhci5zZXQoIHYgKVxuICAgIH1cbiAgfSlcbiAgY29uc3QgX19iaWFzICA9IHBhcmFtX3dyYXAoIGJpYXMsIGZsb2F0X3Zhcl9nZW4oIGJpYXMgKSApXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvcCwgJ2JpYXMnLCB7XG4gICAgZ2V0KCkgeyByZXR1cm4gX19iaWFzfSxcbiAgICBzZXQodikge1xuICAgICBfX2JpYXMudmFyLnNldCggdiApXG4gICAgfVxuICB9KVxuICByZXR1cm4gb3Bcbn0gXG5cbk5vaXNlLnByb3RvdHlwZSA9IFNjZW5lTm9kZSgpXG5cbk5vaXNlLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKCBfX25hbWUgKSB7XG4gIGxldCBuYW1lID0gX19uYW1lID09PSB1bmRlZmluZWQgPyAncCcgOiBfX25hbWVcblxuICBjb25zdCBvdXQgPSBgKCR7dGhpcy5iaWFzLmVtaXQoKX0gKyBzbm9pc2UoIHZlYzQoIHAueHl6LCB0aW1lICogJHt0aGlzLnRpbWVNb2QuZW1pdCgpfSApKSAqICR7dGhpcy5zdHJlbmd0aC5lbWl0KCl9KWAgIFxuXG4gIGNvbnN0IG91dHB1dCA9IHtcbiAgICBvdXQsXG4gICAgcHJlZmFjZTonJ1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuTm9pc2UucHJvdG90eXBlLmdsc2wgPSBnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIC8vXFxuLy8gRGVzY3JpcHRpb24gOiBBcnJheSBhbmQgdGV4dHVyZWxlc3MgR0xTTCAyRC8zRC80RCBzaW1wbGV4XFxuLy8gICAgICAgICAgICAgICBub2lzZSBmdW5jdGlvbnMuXFxuLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cXG4vLyAgTWFpbnRhaW5lciA6IGlqbVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzQgbW9kMjg5KHZlYzQgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDsgfVxcblxcbmZsb2F0IG1vZDI4OShmbG9hdCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wOyB9XFxuXFxudmVjNCBwZXJtdXRlKHZlYzQgeCkge1xcbiAgICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxuZmxvYXQgcGVybXV0ZShmbG9hdCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbmZsb2F0IHRheWxvckludlNxcnQoZmxvYXQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG52ZWM0IGdyYWQ0KGZsb2F0IGosIHZlYzQgaXApXFxuICB7XFxuICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIC0xLjApO1xcbiAgdmVjNCBwLHM7XFxuXFxuICBwLnh5eiA9IGZsb29yKCBmcmFjdCAodmVjMyhqKSAqIGlwLnh5eikgKiA3LjApICogaXAueiAtIDEuMDtcXG4gIHAudyA9IDEuNSAtIGRvdChhYnMocC54eXopLCBvbmVzLnh5eik7XFxuICBzID0gdmVjNChsZXNzVGhhbihwLCB2ZWM0KDAuMCkpKTtcXG4gIHAueHl6ID0gcC54eXogKyAocy54eXoqMi4wIC0gMS4wKSAqIHMud3d3O1xcblxcbiAgcmV0dXJuIHA7XFxuICB9XFxuXFxuLy8gKHNxcnQoNSkgLSAxKS80ID0gRjQsIHVzZWQgb25jZSBiZWxvd1xcbiNkZWZpbmUgRjQgMC4zMDkwMTY5OTQzNzQ5NDc0NTFcXG5cXG5mbG9hdCBzbm9pc2UodmVjNCB2KVxcbiAge1xcbiAgY29uc3QgdmVjNCAgQyA9IHZlYzQoIDAuMTM4MTk2NjAxMTI1MDExLCAgLy8gKDUgLSBzcXJ0KDUpKS8yMCAgRzRcXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjI3NjM5MzIwMjI1MDAyMSwgIC8vIDIgKiBHNFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNDE0NTg5ODAzMzc1MDMyLCAgLy8gMyAqIEc0XFxuICAgICAgICAgICAgICAgICAgICAgICAtMC40NDcyMTM1OTU0OTk5NTgpOyAvLyAtMSArIDQgKiBHNFxcblxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjNCBpICA9IGZsb29yKHYgKyBkb3QodiwgdmVjNChGNCkpICk7XFxuICB2ZWM0IHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4eHgpO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG5cXG4vLyBSYW5rIHNvcnRpbmcgb3JpZ2luYWxseSBjb250cmlidXRlZCBieSBCaWxsIExpY2VhLUthbmUsIEFNRCAoZm9ybWVybHkgQVRJKVxcbiAgdmVjNCBpMDtcXG4gIHZlYzMgaXNYID0gc3RlcCggeDAueXp3LCB4MC54eHggKTtcXG4gIHZlYzMgaXNZWiA9IHN0ZXAoIHgwLnp3dywgeDAueXl6ICk7XFxuLy8gIGkwLnggPSBkb3QoIGlzWCwgdmVjMyggMS4wICkgKTtcXG4gIGkwLnggPSBpc1gueCArIGlzWC55ICsgaXNYLno7XFxuICBpMC55encgPSAxLjAgLSBpc1g7XFxuLy8gIGkwLnkgKz0gZG90KCBpc1laLnh5LCB2ZWMyKCAxLjAgKSApO1xcbiAgaTAueSArPSBpc1laLnggKyBpc1laLnk7XFxuICBpMC56dyArPSAxLjAgLSBpc1laLnh5O1xcbiAgaTAueiArPSBpc1laLno7XFxuICBpMC53ICs9IDEuMCAtIGlzWVouejtcXG5cXG4gIC8vIGkwIG5vdyBjb250YWlucyB0aGUgdW5pcXVlIHZhbHVlcyAwLDEsMiwzIGluIGVhY2ggY2hhbm5lbFxcbiAgdmVjNCBpMyA9IGNsYW1wKCBpMCwgMC4wLCAxLjAgKTtcXG4gIHZlYzQgaTIgPSBjbGFtcCggaTAtMS4wLCAwLjAsIDEuMCApO1xcbiAgdmVjNCBpMSA9IGNsYW1wKCBpMC0yLjAsIDAuMCwgMS4wICk7XFxuXFxuICAvLyAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4eFxcbiAgLy8gIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eHhcXG4gIC8vICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHh4XFxuICAvLyAgeDMgPSB4MCAtIGkzICArIDMuMCAqIEMueHh4eFxcbiAgLy8gIHg0ID0geDAgLSAxLjAgKyA0LjAgKiBDLnh4eHhcXG4gIHZlYzQgeDEgPSB4MCAtIGkxICsgQy54eHh4O1xcbiAgdmVjNCB4MiA9IHgwIC0gaTIgKyBDLnl5eXk7XFxuICB2ZWM0IHgzID0geDAgLSBpMyArIEMuenp6ejtcXG4gIHZlYzQgeDQgPSB4MCArIEMud3d3dztcXG5cXG4vLyBQZXJtdXRhdGlvbnNcXG4gIGkgPSBtb2QyODkoaSk7XFxuICBmbG9hdCBqMCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoaS53KSArIGkueikgKyBpLnkpICsgaS54KTtcXG4gIHZlYzQgajEgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlIChcXG4gICAgICAgICAgICAgaS53ICsgdmVjNChpMS53LCBpMi53LCBpMy53LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS56ICsgdmVjNChpMS56LCBpMi56LCBpMy56LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS55ICsgdmVjNChpMS55LCBpMi55LCBpMy55LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS54ICsgdmVjNChpMS54LCBpMi54LCBpMy54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDd4NiBwb2ludHMgb3ZlciBhIGN1YmUsIG1hcHBlZCBvbnRvIGEgNC1jcm9zcyBwb2x5dG9wZVxcbi8vIDcqNyo2ID0gMjk0LCB3aGljaCBpcyBjbG9zZSB0byB0aGUgcmluZyBzaXplIDE3KjE3ID0gMjg5LlxcbiAgdmVjNCBpcCA9IHZlYzQoMS4wLzI5NC4wLCAxLjAvNDkuMCwgMS4wLzcuMCwgMC4wKSA7XFxuXFxuICB2ZWM0IHAwID0gZ3JhZDQoajAsICAgaXApO1xcbiAgdmVjNCBwMSA9IGdyYWQ0KGoxLngsIGlwKTtcXG4gIHZlYzQgcDIgPSBncmFkNChqMS55LCBpcCk7XFxuICB2ZWM0IHAzID0gZ3JhZDQoajEueiwgaXApO1xcbiAgdmVjNCBwNCA9IGdyYWQ0KGoxLncsIGlwKTtcXG5cXG4vLyBOb3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG4gIHA0ICo9IHRheWxvckludlNxcnQoZG90KHA0LHA0KSk7XFxuXFxuLy8gTWl4IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXFxuICB2ZWMzIG0wID0gbWF4KDAuNiAtIHZlYzMoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSksIDAuMCk7XFxuICB2ZWMyIG0xID0gbWF4KDAuNiAtIHZlYzIoZG90KHgzLHgzKSwgZG90KHg0LHg0KSAgICAgICAgICAgICksIDAuMCk7XFxuICBtMCA9IG0wICogbTA7XFxuICBtMSA9IG0xICogbTE7XFxuICByZXR1cm4gNDkuMCAqICggZG90KG0wKm0wLCB2ZWMzKCBkb3QoIHAwLCB4MCApLCBkb3QoIHAxLCB4MSApLCBkb3QoIHAyLCB4MiApKSlcXG4gICAgICAgICAgICAgICArIGRvdChtMSptMSwgdmVjMiggZG90KCBwMywgeDMgKSwgZG90KCBwNCwgeDQgKSApICkgKSA7XFxuXFxuICB9XFxuXFxuXCJdKVxuXG5Ob2lzZS5wcm90b3R5cGUuZW1pdF9kZWNsID0gZnVuY3Rpb24gKCkge1xuICBsZXQgc3RyID0gdGhpcy5zdHJlbmd0aC5lbWl0X2RlY2woKSArIHRoaXMudGltZU1vZC5lbWl0X2RlY2woKSArIHRoaXMuYmlhcy5lbWl0X2RlY2woKVxuXG4gIGlmKCBTREYubWVtby5ub2lzZSA9PT0gdW5kZWZpbmVkICkge1xuICAgIHN0ciA9IE5vaXNlLnByb3RvdHlwZS5nbHNsICsgc3RyXG4gICAgU0RGLm1lbW8ubm9pc2UgPSB0cnVlXG4gIH1cblxuICByZXR1cm4gc3RyXG59O1xuXG5Ob2lzZS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgdGhpcy5zdHJlbmd0aC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgdGhpcy50aW1lTW9kLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICB0aGlzLmJpYXMudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG59XG5cbk5vaXNlLnByb3RvdHlwZS51cGxvYWRfZGF0YSA9IGZ1bmN0aW9uKGdsKSB7XG4gIHRoaXMuc3RyZW5ndGgudXBsb2FkX2RhdGEoIGdsIClcbiAgdGhpcy50aW1lTW9kLnVwbG9hZF9kYXRhKCBnbCApXG4gIHRoaXMuYmlhcy51cGxvYWRfZGF0YSggZ2wgKVxufVxuXG5yZXR1cm4gTm9pc2VcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vaXNlIFxuIiwiY29uc3QgZ2xzbCA9IHJlcXVpcmUoICdnbHNsaWZ5JyApXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCb3g6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonc2l6ZScsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsxLDEsMV0gfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG5cdCAgICByZXR1cm4gYHNkQm94KCAke3BOYW1lfSwgJHt0aGlzLnNpemUuZW1pdCgpfSApYDtcbiAgICB9LFxuXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIGZsb2F0IHNkQm94KCB2ZWMzIHAsIHZlYzMgYiApXFxue1xcbiAgdmVjMyBkID0gYWJzKHApIC0gYjtcXG4gIHJldHVybiBtaW4obWF4KGQueCxtYXgoZC55LGQueikpLDAuMCkgK1xcbiAgICAgICAgIGxlbmd0aChtYXgoZCwwLjApKTtcXG59XFxuXFxuXCJdKVxuICB9LCBcblxuICAvLyBYWFggd2Ugc2hvdWxkIG5vcm1hbGl6ZSBkaW1lbnNpb25zIGluIHRoZSBzaGFkZXIuLi4gXG4gIENvbmU6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonZGltZW5zaW9ucycsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsuOCwuNiwuM10gfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYHNkQ29uZSggJHtwTmFtZX0sICR7dGhpcy5kaW1lbnNpb25zLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBmbG9hdCBzZENvbmUoIGluIHZlYzMgcCwgaW4gdmVjMyBjIClcXG57XFxuICAgIHZlYzIgcSA9IHZlYzIoIGxlbmd0aChwLnh6KSwgcC55ICk7XFxuICAgIGZsb2F0IGQxID0gLXAueS1jLno7XFxuICAgIGZsb2F0IGQyID0gbWF4KCBkb3QocSxjLnh5KSwgcC55KTtcXG4gICAgcmV0dXJuIGxlbmd0aChtYXgodmVjMihkMSxkMiksMC4wKSkgKyBtaW4obWF4KGQxLGQyKSwgMC4pO1xcbn1cXG5cXG5cIl0pXG4gIH0sIFxuXG5cdEN5bGluZGVyOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J2RpbWVuc2lvbnMnLCB0eXBlOid2ZWMyJywgZGVmYXVsdDpbLjgsLjZdIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZENhcHBlZEN5bGluZGVyKCAke3BOYW1lfSwgJHt0aGlzLmRpbWVuc2lvbnMuZW1pdCgpfSApYFxuICAgIH0sXG5cbiAgICBnbHNsaWZ5OmAgICAgZmxvYXQgc2RDYXBwZWRDeWxpbmRlciggdmVjMyBwLCB2ZWMyIGggKSB7XG4gICAgdmVjMiBkID0gYWJzKHZlYzIobGVuZ3RoKHAueHopLHAueSkpIC0gaDtcbiAgICByZXR1cm4gbWluKG1heChkLngsZC55KSwwLjApICsgbGVuZ3RoKG1heChkLDAuMCkpO1xuICB9YFxuICB9LCBcblxuICBDYXBzdWxlOiB7XHRcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonc3RhcnQnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMCwwLDBdIH0sXG4gICAgICB7IG5hbWU6J2VuZCcsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsuOCwxLDBdIH0sXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDouNSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RDYXBzdWxlKCAke3BOYW1lfSwgJHt0aGlzLnN0YXJ0LmVtaXQoKX0sICR7dGhpcy5lbmQuZW1pdCgpfSwgJHt0aGlzLnJhZGl1cy5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICBmbG9hdCBzZENhcHN1bGUoIHZlYzMgcCwgdmVjMyBhLCB2ZWMzIGIsIGZsb2F0IHIgKVxcbntcXG4gICAgdmVjMyBwYSA9IHAgLSBhLCBiYSA9IGIgLSBhO1xcbiAgICBmbG9hdCBoID0gY2xhbXAoIGRvdChwYSxiYSkvZG90KGJhLGJhKSwgMC4wLCAxLjAgKTtcXG4gICAgcmV0dXJuIGxlbmd0aCggcGEgLSBiYSpoICkgLSByO1xcbn1cXG5cXG5cIl0pXG5cbiAgfSxcblxuICAvLyBYWFggTm8gY3lsaW5kZXIgZGVzY3JpcHRpb25cbiAgLy9gICNwcmFnbWEgZ2xzbGlmeTogc2RDeWxpbmRlclx0PSByZXF1aXJlKCdnbHNsLXNkZi1wcmltaXRpdmVzL3NkQ3lsaW5kZXInKWBcbiBcdEhleFByaXNtOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J2RpbWVuc2lvbnMnLCB0eXBlOid2ZWMyJywgZGVmYXVsdDpbLjgsLjZdIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZEhleFByaXNtKCAke3BOYW1lfSwgJHt0aGlzLmRpbWVuc2lvbnMuZW1pdCgpfSApYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgZmxvYXQgc2RIZXhQcmlzbSggdmVjMyBwLCB2ZWMyIGggKVxcbntcXG4gICAgdmVjMyBxID0gYWJzKHApO1xcbiAgICByZXR1cm4gbWF4KHEuei1oLnksbWF4KChxLngqMC44NjYwMjUrcS55KjAuNSkscS55KS1oLngpO1xcbn1cXG5cXG5cIl0pXG4gIH0sXG5cbiAgSnVsaWE6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonZm9sZCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDowIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBqdWxpYSggJHtwTmFtZX0sICR7dGhpcy5mb2xkLmVtaXQoKX0gKWBcbiAgICB9LFxuXG4gICAgLy8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L01zZkdSclxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgdmVjNCBxc3FyKCBpbiB2ZWM0IGEgKSB7XFxuICAgIHJldHVybiB2ZWM0KCBhLngqYS54IC0gYS55KmEueSAtIGEueiphLnogLSBhLncqYS53LFxcbiAgICAgICAgICAgICAgICAgMi4wKmEueCphLnksXFxuICAgICAgICAgICAgICAgICAyLjAqYS54KmEueixcXG4gICAgICAgICAgICAgICAgIDIuMCphLngqYS53ICk7XFxuICB9XFxuXFxuICBmbG9hdCBqdWxpYSggaW4gdmVjMyBwLCBmbG9hdCBhdGltZSApe1xcbiAgICB2ZWM0IGMgPSAwLjQ1KmNvcyggdmVjNCgwLjUsMy45LDEuNCwxLjEpICsgYXRpbWUgKiB2ZWM0KDEuMiwxLjcsMS4zLDIuNSkgKSAtIHZlYzQoMC4zLDAuMCwwLjAsMC4wKTtcXG4gICAgdmVjNCB6ID0gdmVjNChwLDAuKTtcXG4gICAgZmxvYXQgbWQyID0gMS4wO1xcbiAgICBmbG9hdCBtejIgPSBkb3Qoeix6KTtcXG5cXG4gICAgZm9yKCBpbnQgaT0wOyBpPDExOyBpKysgKXtcXG4gICAgICBtZDIgKj0gNC4wKm16MjsgICBcXG4gICAgICAvLyBkeiAtPiAywrd6wrdkeiwgbWVhbmluZyB8ZHp8IC0+IDLCt3x6fMK3fGR6fCAoY2FuIHRha2UgdGhlIDQgb3V0IG9mIHRoZSBsb29wIGFuZCBkbyBhbiBleHAyKCkgYWZ0ZXJ3YXJkcylcXG4gICAgICB6ID0gcXNxcih6KSArIGM7ICAvLyB6ICAtPiB6XjIgKyBjXFxuXFxuICAgICAgbXoyID0gZG90KHoseik7XFxuICAgICAgaWYobXoyPjQuMCkgYnJlYWs7XFxuICAgIH1cXG4gICAgXFxuICAgIHJldHVybiAwLjI1KnNxcnQobXoyL21kMikqbG9nKG16Mik7ICAvLyBkID0gMC41wrd8enzCt2xvZ3x6fCAvIHxkenxcXG4gIH1cIixcIlwiXSksXG4gIH0sXG4gIEtJRlM6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonY291bnQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6OCB9LFxuICAgICAgeyBuYW1lOidmb2xkJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjAgfSxcbiAgICAgIHsgbmFtZToncmFkaXVzJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0Oi4wMSB9LFxuICAgICAgeyBuYW1lOid0aHJlc2hvbGQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6LjAwNCB9LFxuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoyIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBraWZzKCAke3BOYW1lfSwgJHt0aGlzLmNvdW50LmVtaXQoKX0sICR7dGhpcy5mb2xkLmVtaXQoKX0sICR7dGhpcy5yYWRpdXMuZW1pdCgpfSwgJHt0aGlzLnRocmVzaG9sZC5lbWl0KCl9LCAke3RoaXMuc2NhbGUuZW1pdCgpfSApYFxuICAgIH0sXG5cbiAgICAvLyBhZGFwdGVkIGZyb20gaHR0cDovL3JveS5yZWQvZm9sZGluZy10aGUta29jaC1zbm93Zmxha2UtLmh0bWxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICBmbG9hdCBib3goIHZlYzMgcCwgdmVjMyBiICl7XFxuICAgICAgdmVjMyBkID0gYWJzKHApIC0gYjtcXG4gICAgICByZXR1cm4gbWluKG1heChkLngsbWF4KGQueSxkLnopKSwwLjApICtcXG4gICAgICAgICAgICAgbGVuZ3RoKG1heChkLDAuMCkpO1xcbiAgICB9XFxuICAgIHZlYzIgZm9sZCh2ZWMyIHAsIGZsb2F0IGFuZyl7ICAgIFxcbiAgICAgICAgdmVjMiBuPXZlYzIoY29zKC1hbmcpLHNpbigtYW5nKSk7XFxuICAgICAgICBwLT0yLiptaW4oMC4sZG90KHAsbikpKm47XFxuICAgICAgICByZXR1cm4gcDtcXG4gICAgfVxcbiAgICAjZGVmaW5lIEtQSSAzLjE0MTU5XFxuICAgIHZlYzMgdHJpX2ZvbGQodmVjMyBwdCwgZmxvYXQgZm9sZGFtdCkge1xcbiAgICAgICAgcHQueHkgPSBmb2xkKHB0Lnh5LEtQSS8zLiArIGZvbGRhbXQgKTtcXG4gICAgICAgIHB0Lnh5ID0gZm9sZChwdC54eSwtS1BJLzMuICsgZm9sZGFtdCApO1xcbiAgICAgICAgcHQueXogPSBmb2xkKHB0Lnl6LEtQSS82LisuNyArIGZvbGRhbXQgKTtcXG4gICAgICAgIHB0Lnl6ID0gZm9sZChwdC55eiwtS1BJLzYuICsgZm9sZGFtdCApO1xcbiAgICAgICAgcmV0dXJuIHB0O1xcbiAgICB9XFxuICAgIHZlYzMgdHJpX2N1cnZlKHZlYzMgcHQsIGZsb2F0IGl0ZXIsIGZsb2F0IGZvbGQsIGZsb2F0IHNjYWxlICkge1xcbiAgICAgICAgaW50IGNvdW50ID0gaW50KGl0ZXIpO1xcbiAgICAgICAgZm9yKGludCBpPTA7aTxjb3VudDtpKyspe1xcbiAgICAgICAgICAgIHB0Kj1zY2FsZTtcXG4gICAgICAgICAgICBwdC54LT0yLjY7XFxuICAgICAgICAgICAgcHQ9dHJpX2ZvbGQocHQsZm9sZCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcHQ7XFxuICAgIH1cXG4gICAgZmxvYXQga2lmcyhpbiB2ZWMzIHAsIGZsb2F0IGEsIGZsb2F0IGZvbGQsIGZsb2F0IHJhZGl1cywgZmxvYXQgdGhyZXNoLCBmbG9hdCBzY2FsZSApe1xcbiAgICAgICAgcC54Kz0xLjU7XFxuICAgICAgICBwPXRyaV9jdXJ2ZShwLGEsZm9sZCxzY2FsZSk7XFxuICAgICAgICAvLyB1bmNvbW1lbnQgYmVsb3cgbGluZSB0byB1c2Ugc3BoZXJlcyBpbnN0ZWFkIG9mIGJveGVzXFxuICAgICAgICByZXR1cm4gKGxlbmd0aCggcCp0aHJlc2ggKSAtIHJhZGl1cyApO1xcbiAgICAgICAgLy9yZXR1cm4gYm94KCBwKnRocmVzaCwgdmVjMyhyYWRpdXMpICk7XFxuICAgIH1cXG5cIixcIlwiXSksXG4gIH0sXG5cbiAgTWFuZGVsYnVsYjoge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidjMCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo4IH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBtYW5kZWxidWxiKCAke3BOYW1lfSwgJHt0aGlzLmMwLmVtaXQoKX0gKWBcbiAgICB9LFxuXG4gICAgLy8gYWRhcHRlZCBmcm9tOiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbHRmU1duXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgZmxvYXQgbWFuZGVsYnVsYiggaW4gdmVjMyBwLCBpbiBmbG9hdCBhYSApe1xcbiAgICAgICAgdmVjMyB3ID0gcDtcXG4gICAgICAgIGZsb2F0IG0gPSBkb3Qodyx3KTtcXG5cXG4gICAgICAgIHZlYzQgdHJhcCA9IHZlYzQoYWJzKHcpLG0pO1xcbiAgICAgICAgZmxvYXQgZHogPSAxLjA7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgZm9yKCBpbnQgaT0wOyBpPDQ7IGkrKyApIHtcXG4gICAgICAgICAgZHogPSBhYSpwb3coc3FydChtKSxhYSAtIDEuKSpkeiArIDEuMDtcXG5cXG4gICAgICAgICAgZmxvYXQgciA9IGxlbmd0aCh3KTtcXG4gICAgICAgICAgZmxvYXQgYiA9IGFhKmFjb3MoIHcueSAvcik7XFxuICAgICAgICAgIGZsb2F0IGEgPSBhYSphdGFuKCB3LngsIHcueiApO1xcbiAgICAgICAgICB3ID0gcCArIHBvdyhyLGFhKSAqIHZlYzMoIHNpbihiKSpzaW4oYSksIGNvcyhiKSwgc2luKGIpKmNvcyhhKSApO1xcblxcbiAgICAgICAgICB0cmFwID0gbWluKCB0cmFwLCB2ZWM0KGFicyh3KSxtKSApO1xcblxcbiAgICAgICAgICBtID0gZG90KHcsdyk7XFxuICAgICAgICAgIGlmKCBtID4gMjU2LjAgKSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiAwLjI1KmxvZyhtKSpzcXJ0KG0pL2R6O1xcbiAgICAgIH1cXG4gICAgXCIsXCJcIl0pLFxuICB9LFxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbGxHWERSXG4gIE1hbmRlbGJveDoge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidmb2xkJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0Oi4xIH0sXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjMufSxcbiAgICAgIHsgbmFtZTonaXRlcmF0aW9ucycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgXSxcblxuICAgIGdsc2xpZnk6YGZsb2F0IG1hbmRlbGJveCggZmxvYXQgTVIyLCBmbG9hdCBTQ0FMRSwgZmxvYXQgSVRFUiwgdmVjMyBwb3NpdGlvbiApe1xuICAgICAgdmVjNCBzY2FsZXZlYyA9IHZlYzQoU0NBTEUsIFNDQUxFLCBTQ0FMRSwgYWJzKFNDQUxFKSkgLyBNUjI7XG4gICAgICBmbG9hdCBDMSA9IGFicyhTQ0FMRS0xLjApLCBDMiA9IHBvdyhhYnMoU0NBTEUpLCAxLi1JVEVSKTsgLy8gMTAgaXMgSVRFUlNcbiAgICAgIHZlYzQgcCA9IHZlYzQocG9zaXRpb24ueHl6LCAxLjApLCBwMCA9IHZlYzQocG9zaXRpb24ueHl6LCAxLjApOyAgLy8gcC53IGlzIGtuaWdodHkncyBERWZhY3RvclxuICAgICAgZm9yIChpbnQgaT0wOyBpPGludChJVEVSKTsgaSsrKSB7XG4gICAgICAgIHAueHl6ID0gY2xhbXAocC54eXosIC0xLjAsIDEuMCkgKiAyLjAgLSBwLnh5ejsgIC8vIGJveCBmb2xkOiBtaW4zLCBtYXgzZ2csIG1hZDNcbiAgICAgICAgZmxvYXQgcjIgPSBkb3QocC54eXosIHAueHl6KTsgIC8vIGRwM1xuICAgICAgICBwLnh5encgKj0gY2xhbXAobWF4KE1SMi9yMiwgTVIyKSwgMC4wLCAxLjApOyAgLy8gc3BoZXJlIGZvbGQ6IGRpdjEsIG1heDEuc2F0LCBtdWw0XG4gICAgICAgIHAueHl6dyA9IHAqc2NhbGV2ZWMgKyBwMDsgIC8vIG1hZDRcbiAgICAgIH1cbiAgICAgIHJldHVybiAobGVuZ3RoKHAueHl6KSAtIEMxKSAvIHAudyAtIEMyO1xuICB9YCxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7XG4gICAgICByZXR1cm4gYG1hbmRlbGJveCggJHt0aGlzLmZvbGQuZW1pdCgpfSwgJHt0aGlzLnNjYWxlLmVtaXQoKX0sICR7dGhpcy5pdGVyYXRpb25zLmVtaXQoKX0sICR7cE5hbWV9IClgXG4gICAgfVxuICB9LFxuXG5cdE9jdGFoZWRyb246IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZToncmFkaXVzJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYHNkT2N0YWhlZHJvbiggJHtwTmFtZX0sICR7dGhpcy5yYWRpdXMuZW1pdCgpfSApYFxuICAgIH0sXG5cbiAgICBnbHNsaWZ5OmAgICAgZmxvYXQgc2RPY3RhaGVkcm9uKHZlYzMgcCwgZmxvYXQgaCkge1xuICAgIHAueSA9IHAueSArIGg7IC8vIGNlbnRlciB2ZXJ0aWNhbGx5Li4uIGlzIGl0IGNlbnRlcmVkIG9uIHRoZSB6LWF4aXM/XG4gICAgdmVjMiBkID0gLjUqKGFicyhwLnh6KStwLnkpIC0gbWluKGgscC55KTtcbiAgICByZXR1cm4gbGVuZ3RoKG1heChkLDAuKSkgKyBtaW4obWF4KGQueCxkLnkpLCAwLik7XG4gIH1gXG4gIH0sIFxuXG4gXHRQbGFuZToge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidub3JtYWwnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMCwxLDBdIH0sXG4gICAgICB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYHNkUGxhbmUoICR7cE5hbWV9LCB2ZWM0KCAke3RoaXMubm9ybWFsLmVtaXQoKX0sICR7dGhpcy5kaXN0YW5jZS5lbWl0KCl9ICkpYFxuICAgIH0sXG4gICAgXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuZmxvYXQgc2RQbGFuZSggdmVjMyBwLCB2ZWM0IG4gKVxcbntcXG4gIC8vIG4gbXVzdCBiZSBub3JtYWxpemVkXFxuICByZXR1cm4gZG90KHAsbi54eXopICsgbi53O1xcbn1cXG5cXG5cIl0pXG4gICAgXG4gIH0sICBcbiBcdFF1YWQ6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTondjEnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbLS41LC0uNSwwXSB9LFxuICAgICAgeyBuYW1lOid2MicsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsuNSwtLjUsMF0gfSxcbiAgICAgIHsgbmFtZTondjMnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbLjUsLjUsMF0gfSxcbiAgICAgIHsgbmFtZTondjQnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbLS41LC41LDBdIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGB1ZFF1YWQoICR7cE5hbWV9LCAke3RoaXMudjEuZW1pdCgpfSwgJHt0aGlzLnYyLmVtaXQoKX0sICR7dGhpcy52My5lbWl0KCl9LCAke3RoaXMudjQuZW1pdCgpfSApYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIGZsb2F0IGRvdDIoIGluIHZlYzMgdiApIHsgcmV0dXJuIGRvdCh2LHYpOyB9XFxuZmxvYXQgdWRRdWFkKCB2ZWMzIHAsIHZlYzMgYSwgdmVjMyBiLCB2ZWMzIGMsIHZlYzMgZCApXFxue1xcbiAgICB2ZWMzIGJhID0gYiAtIGE7IHZlYzMgcGEgPSBwIC0gYTtcXG4gICAgdmVjMyBjYiA9IGMgLSBiOyB2ZWMzIHBiID0gcCAtIGI7XFxuICAgIHZlYzMgZGMgPSBkIC0gYzsgdmVjMyBwYyA9IHAgLSBjO1xcbiAgICB2ZWMzIGFkID0gYSAtIGQ7IHZlYzMgcGQgPSBwIC0gZDtcXG4gICAgdmVjMyBub3IgPSBjcm9zcyggYmEsIGFkICk7XFxuXFxuICAgIHJldHVybiBzcXJ0KFxcbiAgICAoc2lnbihkb3QoY3Jvc3MoYmEsbm9yKSxwYSkpICtcXG4gICAgIHNpZ24oZG90KGNyb3NzKGNiLG5vcikscGIpKSArXFxuICAgICBzaWduKGRvdChjcm9zcyhkYyxub3IpLHBjKSkgK1xcbiAgICAgc2lnbihkb3QoY3Jvc3MoYWQsbm9yKSxwZCkpPDMuMClcXG4gICAgID9cXG4gICAgIG1pbiggbWluKCBtaW4oXFxuICAgICBkb3QyKGJhKmNsYW1wKGRvdChiYSxwYSkvZG90MihiYSksMC4wLDEuMCktcGEpLFxcbiAgICAgZG90MihjYipjbGFtcChkb3QoY2IscGIpL2RvdDIoY2IpLDAuMCwxLjApLXBiKSApLFxcbiAgICAgZG90MihkYypjbGFtcChkb3QoZGMscGMpL2RvdDIoZGMpLDAuMCwxLjApLXBjKSApLFxcbiAgICAgZG90MihhZCpjbGFtcChkb3QoYWQscGQpL2RvdDIoYWQpLDAuMCwxLjApLXBkKSApXFxuICAgICA6XFxuICAgICBkb3Qobm9yLHBhKSpkb3Qobm9yLHBhKS9kb3QyKG5vcikgKTtcXG59XFxuXFxuXCJdKVxuICB9LCBcblxuICBSb3VuZEJveDoge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidzaXplJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzEsMSwxXSB9LFxuICAgICAgeyBuYW1lOidyYWRpdXMnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgdWRSb3VuZEJveCggJHtwTmFtZX0sICR7dGhpcy5zaXplLmVtaXQoKX0sICAke3RoaXMucmFkaXVzLmVtaXQoKX0gKWBcbiAgICB9LCBcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgdWRSb3VuZEJveCggdmVjMyBwLCB2ZWMzIGIsIGZsb2F0IHIgKVxcbntcXG4gIHJldHVybiBsZW5ndGgobWF4KGFicyhwKS1iLDAuMCkpLXI7XFxufVxcblxcblwiXSlcbiAgfSwgXG4gIFNwaGVyZTp7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGAobGVuZ3RoKCR7cE5hbWV9KSAtICR7dGhpcy5yYWRpdXMuZW1pdCgpfSlgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgc2RTcGhlcmUoIHZlYzMgcCwgZmxvYXQgcyApXFxue1xcbiAgcmV0dXJuIGxlbmd0aCggcCApIC0gcztcXG59XFxuXFxuXCJdKVxuICB9LFxuICAvLyBwaGksIG0sIG4xLCBuMiwgbjMsIGEsIGJcbiAgU3VwZXJGb3JtdWxhOntcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonbV8xJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonbjFfMScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J24yXzEnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LFxuICAgICAgeyBuYW1lOiduM18xJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonYV8xJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonYl8xJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonbV8yJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonbjFfMicsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J24yXzInLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LFxuICAgICAgeyBuYW1lOiduM18yJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonYV8yJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonYl8yJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYHN1cGVyZm9ybXVsYSggJHtwTmFtZX0sICR7dGhpcy5tXzEuZW1pdCgpfSwgJHt0aGlzLm4xXzEuZW1pdCgpfSwke3RoaXMubjJfMS5lbWl0KCl9LCR7dGhpcy5uM18xLmVtaXQoKX0sJHt0aGlzLmFfMS5lbWl0KCl9LCR7dGhpcy5iXzEuZW1pdCgpfSwgJHt0aGlzLm1fMi5lbWl0KCl9LCAke3RoaXMubjFfMi5lbWl0KCl9LCR7dGhpcy5uMl8yLmVtaXQoKX0sJHt0aGlzLm4zXzIuZW1pdCgpfSwke3RoaXMuYV8yLmVtaXQoKX0sJHt0aGlzLmJfMi5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgU3VwZXJGb3JtdWxhKCBmbG9hdCBwaGksIGZsb2F0IG0sIGZsb2F0IG4xLCBmbG9hdCBuMiwgZmxvYXQgbjMsIGZsb2F0IGEsIGZsb2F0IGIgKXtcXG5cXHRcXG5cXHRmbG9hdCB0MSA9IGFicygoMS4wIC8gYSkgKiBjb3MobSAqIHBoaSAvIDQuMCkpO1xcblxcdHQxID0gcG93KHQxLCBuMik7XFxuXFxuXFx0ZmxvYXQgdDIgPSBhYnMoKGEgLyBiKSAqIHNpbihtICogcGhpIC8gNC4wKSk7XFxuXFx0dDIgPSBwb3codDIsIG4zKTtcXG5cXG5cXHRmbG9hdCB0MyA9IHQxICsgdDI7XFxuXFxuXFx0ZmxvYXQgciA9IHBvdyh0MywgLTEuMCAvIG4xKTtcXG5cXG5cXHRyZXR1cm4gcjtcXG59XFxuXFxuIGZsb2F0IHN1cGVyZm9ybXVsYSggdmVjMyBwLCBmbG9hdCBtXzEsIGZsb2F0IG4xXzEsIGZsb2F0IG4yXzEsIGZsb2F0IG4zXzEsIGZsb2F0IGFfMSwgZmxvYXQgYl8xLCBmbG9hdCBtXzIsIGZsb2F0IG4xXzIsIGZsb2F0IG4yXzIsIGZsb2F0IG4zXzIsIGZsb2F0IGFfMiwgZmxvYXQgYl8yICkge1xcbiAgICBmbG9hdCBkID0gbGVuZ3RoKCBwICk7XFxuICAgIGZsb2F0IHRoZXRhID0gYXRhbihwLnkgLyBwLngpO1xcbiAgICBmbG9hdCBwaGkgPSBhc2luKHAueiAvIGQpO1xcbiAgICBmbG9hdCByMSA9IFN1cGVyRm9ybXVsYSggdGhldGEsIG1fMSwgbjFfMSwgbjJfMSwgbjNfMSwgYV8xLCBiXzEgKTtcXG4gICAgZmxvYXQgcjIgPSBTdXBlckZvcm11bGEoIHBoaSwgbV8yLCBuMV8yLCBuMl8yLCBuM18yLCBhXzIsIGJfMiApO1xcbiAgICB2ZWMzIHEgPSByMiAqIHZlYzMocjEgKiBjb3ModGhldGEpICogY29zKHBoaSksIHIxICogc2luKHRoZXRhKSAqIGNvcyhwaGkpLCBzaW4ocGhpKSk7XFxuICAgIGQgPSBkIC0gbGVuZ3RoKHEpO1xcblxcbiAgICByZXR1cm4gZDtcXG4gIH0gICAgXFxuXCIsXCJcIl0pIH0sXG5cbiAgVG9ydXM6e1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidyYWRpaScsICB0eXBlOid2ZWMyJywgZGVmYXVsdDpbLjUsLjFdIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZFRvcnVzKCAke3BOYW1lfSwgJHt0aGlzLnJhZGlpLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBmbG9hdCBzZFRvcnVzKCB2ZWMzIHAsIHZlYzIgdCApXFxue1xcbiAgdmVjMiBxID0gdmVjMihsZW5ndGgocC54eiktdC54LHAueSk7XFxuICByZXR1cm4gbGVuZ3RoKHEpLXQueTtcXG59XFxuXFxuXCJdKVxuXG4gIH0sICBcbiAgVG9ydXM4ODp7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3JhZGlpJywgIHR5cGU6J3ZlYzInLCBkZWZhdWx0OlsuNSwuMV0gfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYHNkVG9ydXM4OCggJHtwTmFtZX0sICR7dGhpcy5yYWRpaS5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5OmBmbG9hdCBzZFRvcnVzODgoIHZlYzMgcCwgdmVjMiB0ICkge1xuICAgICAgICB2ZWMyIHEgPSB2ZWMyKCBsZW5ndGg4KCBwLnh6ICkgLSB0LngsIHAueSApO1xuICAgICAgICByZXR1cm4gbGVuZ3RoOCggcSApIC0gdC55O1xuICAgICAgfVxcbmAsXG4gIH0sXG4gIFRvcnVzODI6e1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidyYWRpaScsICB0eXBlOid2ZWMyJywgZGVmYXVsdDpbLjUsLjFdIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZFRvcnVzODIoICR7cE5hbWV9LCAke3RoaXMucmFkaWkuZW1pdCgpfSApYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpgZmxvYXQgc2RUb3J1czgyKCB2ZWMzIHAsIHZlYzIgdCApIHtcbiAgICAgICAgdmVjMiBxID0gdmVjMiggbGVuZ3RoKCBwLnh6ICkgLSB0LngsIHAueSApO1xuICAgICAgICByZXR1cm4gbGVuZ3RoOCggcSApIC0gdC55O1xuICAgICAgfVxcbmBcbiAgfSxcbiBcdFRyaWFuZ2xlOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3YxJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzAsLS41LDBdIH0sXG4gICAgICB7IG5hbWU6J3YyJywgdHlwZTondmVjMycsIGRlZmF1bHQ6Wy0uNSwuMCwwXSB9LFxuICAgICAgeyBuYW1lOid2MycsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsuNSwuMCwwXSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgdWRUcmlhbmdsZSggJHtwTmFtZX0sICR7dGhpcy52MS5lbWl0KCl9LCAke3RoaXMudjIuZW1pdCgpfSwgJHt0aGlzLnYzLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBmbG9hdCBkb3QyKCBpbiB2ZWMzIHYgKSB7IHJldHVybiBkb3Qodix2KTsgfVxcbmZsb2F0IHVkVHJpYW5nbGUoIHZlYzMgcCwgdmVjMyBhLCB2ZWMzIGIsIHZlYzMgYyApXFxue1xcbiAgICB2ZWMzIGJhID0gYiAtIGE7IHZlYzMgcGEgPSBwIC0gYTtcXG4gICAgdmVjMyBjYiA9IGMgLSBiOyB2ZWMzIHBiID0gcCAtIGI7XFxuICAgIHZlYzMgYWMgPSBhIC0gYzsgdmVjMyBwYyA9IHAgLSBjO1xcbiAgICB2ZWMzIG5vciA9IGNyb3NzKCBiYSwgYWMgKTtcXG5cXG4gICAgcmV0dXJuIHNxcnQoXFxuICAgIChzaWduKGRvdChjcm9zcyhiYSxub3IpLHBhKSkgK1xcbiAgICAgc2lnbihkb3QoY3Jvc3MoY2Isbm9yKSxwYikpICtcXG4gICAgIHNpZ24oZG90KGNyb3NzKGFjLG5vcikscGMpKTwyLjApXFxuICAgICA/XFxuICAgICBtaW4oIG1pbihcXG4gICAgIGRvdDIoYmEqY2xhbXAoZG90KGJhLHBhKS9kb3QyKGJhKSwwLjAsMS4wKS1wYSksXFxuICAgICBkb3QyKGNiKmNsYW1wKGRvdChjYixwYikvZG90MihjYiksMC4wLDEuMCktcGIpICksXFxuICAgICBkb3QyKGFjKmNsYW1wKGRvdChhYyxwYykvZG90MihhYyksMC4wLDEuMCktcGMpIClcXG4gICAgIDpcXG4gICAgIGRvdChub3IscGEpKmRvdChub3IscGEpL2RvdDIobm9yKSApO1xcbn1cXG5cXG5cIl0pXG4gIH0sIFxuXG4gIFRyaVByaXNtOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J2RpbWVuc2lvbnMnLCB0eXBlOid2ZWMyJywgZGVmYXVsdDpbLjUsLjVdIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZFRyaVByaXNtKCAke3BOYW1lfSwgJHt0aGlzLmRpbWVuc2lvbnMuZW1pdCgpfSlgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICBmbG9hdCBzZFRyaVByaXNtKCB2ZWMzIHAsIHZlYzIgaCApXFxue1xcbiAgICB2ZWMzIHEgPSBhYnMocCk7XFxuICAgIHJldHVybiBtYXgocS56LWgueSxtYXgocS54KjAuODY2MDI1K3AueSowLjUsLXAueSktaC54KjAuNSk7XFxufVxcblxcblwiXSlcblxuICB9LCBcbiAgLypWb3hlbFNwaGVyZTp7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J3Jlc29sdXRpb24nLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MjAgfSxcbiAgICAgIHsgbmFtZTonY2VudGVyJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzAsMCwwXSB9LFxuICAgICAgeyBuYW1lOidtYXRlcmlhbCcsIHR5cGU6J21hdCcsIGRlZmF1bHQ6bnVsbCB9XG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBWb3hlbFNwaGVyZSggJHtwTmFtZX0sICR7dGhpcy5yYWRpdXMuZW1pdCgpfSwgJHt0aGlzLnJlc29sdXRpb24uZW1pdCgpfSApYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpnbHNsYGZsb2F0IHNkQm94KCB2ZWMzIHAsIHZlYzMgYiApe1xuICAgICAgICB2ZWMzIGQgPSBhYnMocCkgLSBiO1xuICAgICAgICByZXR1cm4gbWluKG1heChkLngsbWF4KGQueSxkLnopKSwwLjApICtcbiAgICAgICAgICAgICAgIGxlbmd0aChtYXgoZCwwLjApKTtcbiAgICAgIH1cbiAgICAgIGZsb2F0IFZveGVsU3BoZXJlKCB2ZWMzIHAsIGZsb2F0IHJhZGl1cywgZmxvYXQgcmVzb2x1dGlvbiApIHtcbiAgICAgICAgLy92ZWMzIHJlZiA9IHAgKiByZXNvbHV0aW9uO1xuICAgICAgICAvL3JlZiA9IHJvdW5kKCByZWYgKTtcbiAgICAgICAgLy9yZXR1cm4gKCBsZW5ndGgoIHJlZiApIC0gcmVzb2x1dGlvbiAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbjtcblxuICAgICAgICBmbG9hdCBkaXN0ID0gcm91bmQoIGxlbmd0aCggcCApIC0gcmFkaXVzICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgICAgICAvL2lmKCBkaXN0IDwgcmVzb2x1dGlvbiApIHtcbiAgICAgICAgLy8gIGRpc3QgPSBzZEJveCggdmVjMygwLiksIHZlYzMocmVzb2x1dGlvbikgKTtcbiAgICAgICAgLy99XG5cbiAgICAgICAgcmV0dXJuIGRpc3Q7IFxuICAgIH1gXG4gIH0sKi9cblxufVxuIiwiY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9ICA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSggJy4vdHJhbnNmb3JtLmpzJyApXG5cbmNvbnN0IGNyZWF0ZVByaW1pdGl2ZXMgPSBmdW5jdGlvbiggU0RGICkge1xuXG4gIGNvbnN0IGdlbnMgPSB7IFxuICAgIGludDogICBpbnRfdmFyX2dlbixcbiAgICBmbG9hdDogZmxvYXRfdmFyX2dlbixcbiAgICB2ZWMyOiB2ZWMyX3Zhcl9nZW4sXG4gICAgdmVjMzogdmVjM192YXJfZ2VuLFxuICAgIHZlYzQ6IHZlYzRfdmFyX2dlbixcbiAgfVxuXG4gIGNvbnN0IHZhcnMgPSB7IFxuICAgIHZlYzI6IFZlYzIsXG4gICAgdmVjMzogVmVjMyxcbiAgICB2ZWM0OiBWZWM0XG4gIH1cblxuICAvLyBsb2FkIGRlc2NyaXB0aW9ucyBvZiBhbGwgcHJpbXRpdmVzXG4gIGNvbnN0IGRlc2NyaXB0aW9ucyA9IHJlcXVpcmUoICcuL3ByaW1pdGl2ZURlc2NyaXB0aW9ucy5qcycgKVxuXG4gIGNvbnN0IFByaW1pdGl2ZXMgPSB7IFxuICAgIGRlc2NyaXB0aW9ucyxcblxuICAgIHRleHR1cmVNZW1vOiBbXSxcblxuICAgIGVtaXRfZ2VvbWV0cmllcygpIHtcbiAgICAgIGNvbnN0IGhlYWQgPSBBcnJheS5pc0FycmF5KCBTREYuX19zY2VuZS5fX3ByZXJlbmRlciApID8gU0RGLl9fc2NlbmUuX19wcmVyZW5kZXJbMF0gOiBTREYuX19zY2VuZS5fX3ByZXJlbmRlclxuICAgICAgY29uc3QgZ2VvcyA9IFByaW1pdGl2ZXMuY3Jhd2xOb2RlKCBoZWFkLCBbXSApXG5cbiAgICAgIGdlb3MuZm9yRWFjaCggKGdlbyxpKSA9PiB7XG4gICAgICAgIGdlby5fX3NkZklEID0gaSBcbiAgICAgICAgaWYoIGdlby5fX3RleHR1cmVPYmogIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBTREYudGV4dHVyZXMuYWRkVGV4dHVyZSggZ2VvLl9fdGV4dHVyZU9iaiApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGxlbmd0aCA9IGdlb3MubGVuZ3RoXG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSBTREYubWF0ZXJpYWxzLm1hdGVyaWFsc1xuXG4gICAgICBsZXQgZGVjbCA9IGBTREYgc2Rmc1ske2xlbmd0aH1dID0gU0RGWyR7bGVuZ3RofV0oXFxuYFxuICAgICAgZ2Vvcy5mb3JFYWNoKCAoZ2VvLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVJRCA9IGdlby5fX3RleHR1cmVPYmogPT09IHVuZGVmaW5lZCA/IDUwMDAwIDogZ2VvLl9fdGV4dHVyZU9iai5pZFxuICAgICAgICBjb25zdCBoYXNSZXBlYXQgPSBnZW8ucmVwZWF0ICE9PSBudWxsICYmIGdlby5yZXBlYXQgIT09IHVuZGVmaW5lZFxuICAgICAgICBkZWNsICs9IGAgICAgICAgIFNERiggJHttYXRlcmlhbHMuaW5kZXhPZiggZ2VvLl9fbWF0ZXJpYWwgKX0sICR7Z2VvLnRyYW5zZm9ybS52YXJOYW1lfSwgJHt0ZXh0dXJlSUR9LCAke2hhc1JlcGVhdCA/IGdlby5yZXBlYXQuZGlzdGFuY2UuZW1pdCgpIDogJ3ZlYzMoMC4pJ30sICR7aGFzUmVwZWF0ID8gZ2VvLnJlcGVhdC50cmFuc2Zvcm0uZW1pdCgpIDogYG1hdDQoMS4pYH0gKWBcbiAgICAgICAgaWYoIGkgPCBnZW9zLmxlbmd0aCAtIDEgKSBkZWNsICs9ICcsJ1xuICAgICAgICBkZWNsICs9ICdcXG4nXG4gICAgICB9KVxuXG4gICAgICBkZWNsICs9IGAgICAgICApO1xcbmBcblxuICAgICAgdGhpcy5nZW9tZXRyaWVzID0gZ2Vvc1xuXG4gICAgICByZXR1cm4gZGVjbFxuICAgIH0sXG5cbiAgICBjcmF3bE5vZGUoIG5vZGUsIGFyciApIHtcbiAgICAgIGlmKCBub2RlLnR5cGUgPT09ICdnZW9tZXRyeScgKSB7XG4gICAgICAgIGFyci5wdXNoKCBub2RlIClcbiAgICAgIH1lbHNle1xuICAgICAgICBpZiggbm9kZS5hICE9PSB1bmRlZmluZWQgKSBQcmltaXRpdmVzLmNyYXdsTm9kZSggbm9kZS5hLCBhcnIgKVxuICAgICAgICBpZiggbm9kZS5iICE9PSB1bmRlZmluZWQgKSBQcmltaXRpdmVzLmNyYXdsTm9kZSggbm9kZS5iLCBhcnIgKVxuICAgICAgICBpZiggbm9kZS5zZGYgIT09IHVuZGVmaW5lZCApIFByaW1pdGl2ZXMuY3Jhd2xOb2RlKCBub2RlLnNkZiwgYXJyIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZVByaW1pdGl2ZSA9IGZ1bmN0aW9uKCBuYW1lLCBkZXNjICkge1xuXG4gICAgY29uc3QgcGFyYW1zID0gZGVzYy5wYXJhbWV0ZXJzXG4gICAgLy8gY3JlYXRlIGNvbnN0cnVjdG9yXG4gICAgUHJpbWl0aXZlc1sgbmFtZSBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICBjb25zdCBwID0gT2JqZWN0LmNyZWF0ZSggUHJpbWl0aXZlc1sgbmFtZSBdLnByb3RvdHlwZSApXG4gICAgICBwLnBhcmFtcyA9IHBhcmFtc1xuICAgICAgcC50cmFuc2Zvcm0gPSBUcmFuc2Zvcm0oKVxuICAgICAgcC50cmFuc2Zvcm0uc2hvdWxkSW52ZXJ0ID0gdHJ1ZVxuICAgICAgcC50eXBlID0gJ2dlb21ldHJ5J1xuICAgICAgcC5uYW1lID0gbmFtZVxuICAgICAgcC5yZXBlYXQgPSBudWxsLy9WYXIoIHZhcnMudmVjMyggMCApLCBudWxsLCAndmVjMycgKVxuXG4gICAgICBwLl9fbWF0ZXJpYWwgPSBudWxsXG4gICAgICBwLl9fdGV4dHVyZUlEICA9IDUwMDAwMFxuICAgICAgXG4gICAgICBsZXQgY291bnQgPSAwXG5cbiAgICAgIC8vIHdyYXAgZWFjaCBwYXJhbSBpbiBhIFZhciBvYmplY3QgZm9yIGNvZGVnZW5cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHBhcmFtcyApIHtcbiAgICAgICAgaWYoIHBhcmFtLm5hbWUgPT09ICdjb2xvcicgKSB7XG4gICAgICAgICAgcC5jb2xvciA9IGFyZ3NbIGNvdW50IF0gPT09IHVuZGVmaW5lZCA/IHBhcmFtLmRlZmF1bHQgOiBhcmdzWyBjb3VudCsrIF1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmKCBwYXJhbS50eXBlID09PSAnb2JqJyApIHtcbiAgICAgICAgICBsZXQgX192YWx1ZSA9IGFyZ3NbIGNvdW50KysgXVxuICAgICAgICAgIHBbIHBhcmFtLm5hbWUgXSA9IHtcbiAgICAgICAgICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIF9fdmFsdWUgfSxcbiAgICAgICAgICAgIHNldCB2YWx1ZSh2KXsgX192YWx1ZSA9IHYgfSxcbiAgICAgICAgICAgIGVtaXQoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9ICBwWyBwYXJhbS5uYW1lIF0udmFsdWUuZW1pdCgpXG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbWl0X2RlY2woKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwWyBwYXJhbS5uYW1lIF0udmFsdWUuYS5lbWl0X2RlY2woKSArIHBbcGFyYW0ubmFtZV0udmFsdWUuYi5lbWl0X2RlY2woKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBwYXJhbS5kZWZhdWx0XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBkZWZhdWx0VmFsdWVzIClcblxuICAgICAgICBpZiggaXNBcnJheSApIHtcbiAgICAgICAgICBsZXQgdmFsID0gYXJnc1sgY291bnQrKyBdLCBfX3ZhclxuXG4gICAgICAgICAgaWYoIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgX192YXIgPSBWYXIoIHZhcnNbIHBhcmFtLnR5cGUgXSggdmFsICksIG51bGwsICd2ZWMzJyApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBfX3ZhciA9ICBwYXJhbV93cmFwKFxuICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgIGdlbnNbIHBhcmFtLnR5cGUgXSggLi4uZGVmYXVsdFZhbHVlcyApIFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZvciBhc3NpZ25pbmcgZW50aXJlIG5ldyB2ZWN0b3JzIHRvIHByb3BlcnR5XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBwLCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS56ID0gdlxuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLncgPSB2XG4gICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGxldCBfX3ZhciAgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgIGFyZ3NbIGNvdW50KysgXSwgXG4gICAgICAgICAgICBnZW5zWyBwYXJhbS50eXBlIF0oIGRlZmF1bHRWYWx1ZXMgKSBcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvL19fdmFyLnNldCggZGVmYXVsdFZhbHVlcyApXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBwLCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICBfX3Zhci5zZXQoIHYgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcC5pZCA9IFZhckFsbG9jLmFsbG9jKClcblxuICAgICAgcC5fX2Rlc2MgPSBkZXNjXG4gICAgICBwLl9fc2V0TWF0ZXJpYWwgPSBmdW5jdGlvbihtYXQpIHtcbiAgICAgICAgaWYoIHR5cGVvZiBtYXQgPT09ICdzdHJpbmcnICkgbWF0ID0gU0RGLk1hdGVyaWFsWyBtYXQgXVxuICAgICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IFNERi5tYXRlcmlhbHMuYWRkTWF0ZXJpYWwoIG1hdCApXG4gICAgICB9XG5cbiAgICAgIHAuX19zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgdGV4ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUgPSBwLnRleHR1cmUuYmluZCggdGhpcyApXG4gICAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IFNERi5UZXh0dXJlKCB0ZXgscHJvcHMsdGhpcy50ZXh0dXJlIClcbiAgICAgICAgICB0aGlzLl9fdGV4dHVyZUlEID0gdGhpcy5fX3RleHR1cmVPYmouaWRcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IE9iamVjdC5hc3NpZ24oIHRleCwgcHJvcHMgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlSUQgPSB0aGlzLl9fdGV4dHVyZU9iai5pZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwLl9fc2V0QnVtcCA9IGZ1bmN0aW9uKHRleCxwcm9wcykge1xuICAgICAgICAvL3RoaXMuYnVtcCA9IHAuYnVtcC5iaW5kKCB0aGlzIClcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuYnVtcCA9IHRoaXMuX19idW1wT2JqID0gU0RGLkJ1bXAoIHRoaXMsIHRleCwgcHJvcHMgKVxuICAgICAgICB0aGlzLmJ1bXAudGV4dHVyZSA9IHRoaXMuYnVtcC5hbW91bnQudmFsdWVcbiAgICAgICAgdGhpcy5fX2J1bXBJRCA9IHRoaXMuX19idW1wT2JqLmlkXG4gICAgICAgIHRoaXMucm90YXRlID0gdGhpcy5idW1wLnJvdGF0ZVxuICAgICAgICB0aGlzLnRyYW5zbGF0ZSA9IHRoaXMuYnVtcC50cmFuc2xhdGVcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuYnVtcC5zY2FsZVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuYnVtcCwgJ3N0cmVuZ3RoJywge1xuICAgICAgICAgIGdldCgpIHsgcmV0dXJuIGIuc2l6ZSB9LFxuICAgICAgICAgIHNldCh2KXsgYi5zaXplID0gdiB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oIHAsIHtcbiAgICAgICAgcmVuZGVyaW5nQnVtcCA6IGZhbHNlLFxuICAgICAgICBlbWl0dGluZ0RlY2wgIDogZmFsc2UsXG4gICAgICAgIHVwbG9hZGluZyAgICAgOiBmYWxzZSxcbiAgICAgICAgdXBkYXRpbmcgICAgICA6IGZhbHNlXG4gICAgICB9KVxuXG4gICAgICBpZiggcC5fX21hdGVyaWFsID09PSBudWxsICkgcC5fX3NldE1hdGVyaWFsKClcblxuICAgICAgU0RGLmdlb21ldHJpZXMucHVzaCggcCApXG5cbiAgICAgIHJldHVybiBwXG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIHByb3RvdHlwZSB0byB1c2VcbiAgICBQcmltaXRpdmVzWyBuYW1lIF0ucHJvdG90eXBlID0gU2NlbmVOb2RlKClcbiAgICBQcmltaXRpdmVzWyBuYW1lIF0ucHJvdG90eXBlLnR5cGUgPSAnZ2VvbWV0cnknXG4gICAgXG4gICAgLy8gY3JlYXRlIGNvZGVnZW4gc3RyaW5nXG5cblxuICAgIFByaW1pdGl2ZXNbIG5hbWUgXS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICggX19uYW1lLCB0cmFuc2Zvcm0gPSBudWxsLCBidW1wPW51bGwsIHNjYWxlPW51bGwgKSB7XG4gICAgICBpZiggU0RGLm1lbW9bIHRoaXMuaWQgXSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHsgcHJlZmFjZTonJywgb3V0Om5hbWUrdGhpcy5tYXRJZCB9XG4gICAgICBpZiggdGhpcy5fX2J1bXBPYmogIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJlbmRlcmluZ0J1bXAgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyaW5nQnVtcCA9IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLmVtaXQoIF9fbmFtZSwgdHJhbnNmb3JtIClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2hhZGVyQ29kZSA9IGRlc2MuZ2xzbGlmeS5pbmRleE9mKCcjJykgPiAtMSBcbiAgICAgICAgPyBkZXNjLmdsc2xpZnkuc2xpY2UoMTgpIFxuICAgICAgICA6IGRlc2MuZ2xzbGlmeVxuXG4gICAgICBpZiggU0RGLnJlcXVpcmVkR2VvbWV0cmllcy5pbmRleE9mKCBzaGFkZXJDb2RlICkgPT09IC0gMSApIHtcbiAgICAgICAgU0RGLnJlcXVpcmVkR2VvbWV0cmllcy5wdXNoKCBzaGFkZXJDb2RlIClcbiAgICAgIH0gXG5cbiAgICAgIGlmKCB0cmFuc2Zvcm0gIT09IG51bGwgKSB0aGlzLnRyYW5zZm9ybS5hcHBseSggdHJhbnNmb3JtLCBmYWxzZSApXG4gICAgICAvL3RoaXMudHJhbnNmb3JtLmludmVydCggdHJ1ZSApXG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnRlcm5hbCgpXG5cbiAgICAgIGNvbnN0IHBuYW1lID0gdHlwZW9mIF9fbmFtZSAhPT0gJ3N0cmluZycgPyAncCcgOiBfX25hbWUsXG4gICAgICAgICAgICBpZCA9IHRoaXMuX19zZGZJRCxcbiAgICAgICAgICAgIHMgPSBzY2FsZSA9PT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKSA6IGAke3RoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKX0gKiAke3NjYWxlfWAsXG4gICAgICAgICAgICB0c3RyaW5nID0gYCggJHtwbmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX0gKS54eXpgXG4gICAgICBcbiAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IGBcbiAgICAgICAgdmVjMiAke25hbWV9JHt0aGlzLmlkfSA9IHZlYzIoICR7ZGVzYy5wcmltaXRpdmVTdHJpbmcuY2FsbCggdGhpcywgdHN0cmluZywgYnVtcCApfSAqICR7c30sICR7aWR9Lik7XG4gICAgICBgXG4gICAgICBTREYubWVtb1sgdGhpcy5pZCBdID0gbmFtZSArIHRoaXMuaWRcblxuICAgICAgdGhpcy5yZW5kZXJpbmdCdW1wID0gZmFsc2VcbiAgICAgIHJldHVybiB7IHByZWZhY2U6cHJpbWl0aXZlLCBvdXQ6bmFtZSt0aGlzLmlkICB9XG4gICAgfVxuICAgIFxuICAgIC8vIGRlY2xhcmUgYW55IHVuaWZvcm0gdmFyaWFibGVzXG4gICAgUHJpbWl0aXZlc1sgbmFtZSBdLnByb3RvdHlwZS5lbWl0X2RlY2wgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZW1pdHRpbmdEZWNsID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLmVtaXRfZGVjbCgpIFxuICAgICAgfVxuICAgICAgbGV0IGRlY2wgPSAnJ1xuICAgICAgZGVjbCArPSB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKVxuXG4gICAgICAvL2RlYnVnZ2VyXG4gICAgICBpZiggdGhpcy5fX3JlcGVhdCAhPT0gdW5kZWZpbmVkICkgZGVjbCArPSB0aGlzLl9fcmVwZWF0LmVtaXRfZGVjbCggZmFsc2UgKVxuICAgICAgaWYoIHRoaXMuX19wb2xhclJlcGVhdCAhPT0gdW5kZWZpbmVkICkgZGVjbCArPSB0aGlzLl9fcG9sYXJSZXBlYXQuZW1pdF9kZWNsKCBmYWxzZSApXG5cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHBhcmFtcyApIHtcbiAgICAgICAgaWYoIHBhcmFtLm5hbWUgIT09ICdtYXRlcmlhbCcgKVxuICAgICAgICAgIGRlY2wgKz0gdGhpc1sgcGFyYW0ubmFtZSBdLmVtaXRfZGVjbCggKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IGZhbHNlXG4gICAgICByZXR1cm4gZGVjbFxuICAgIH1cblxuICAgIFByaW1pdGl2ZXNbIG5hbWUgXS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cGRhdGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy51cGRhdGluZyA9IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgfVxuXG4gICAgICBmb3IoIGxldCBwYXJhbSBvZiBwYXJhbXMgKSB7XG4gICAgICAgIGlmKCBwYXJhbS50eXBlICE9PSAnb2JqJyApIHtcbiAgICAgICAgICBpZiggcGFyYW0ubmFtZSAhPT0gJ21hdGVyaWFsJyApIFxuICAgICAgICAgICAgdGhpc1sgcGFyYW0ubmFtZSBdLnVwZGF0ZV9sb2NhdGlvbiggZ2wscHJvZ3JhbSApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHRoaXMuX19yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRoaXMuX19yZXBlYXQudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSwgZmFsc2UgKVxuICAgICAgaWYoIHRoaXMuX19wb2xhclJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGhpcy5fX3BvbGFyUmVwZWF0LnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0sIGZhbHNlIClcbiAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgdGhpcy51cGRhdGluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgUHJpbWl0aXZlc1sgbmFtZSBdLnByb3RvdHlwZS51cGxvYWRfZGF0YSA9IGZ1bmN0aW9uKCBnbCApIHtcbiAgICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMudXBsb2FkaW5nICA9PT0gZmFsc2UgKSB7XG4gICAgICAgIHRoaXMudXBsb2FkaW5nID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5fX2J1bXBPYmoudXBsb2FkX2RhdGEoIGdsIClcbiAgICAgIH1cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHBhcmFtcyApIHtcbiAgICAgICAgaWYoIHBhcmFtLnR5cGUgIT09ICdvYmonICYmIHBhcmFtLm5hbWUgIT09ICdtYXRlcmlhbCcgKVxuICAgICAgICAgIHRoaXNbIHBhcmFtLm5hbWUgXS51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgfVxuXG4gICAgICBpZiggdGhpcy5fX3BvbGFyUmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0aGlzLl9fcG9sYXJSZXBlYXQudXBsb2FkX2RhdGEoIGdsLCBmYWxzZSApXG4gICAgICB0aGlzLnRyYW5zZm9ybS51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgdGhpcy51cGxvYWRpbmcgPSBmYWxzZVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gUHJpbWl0aXZlc1sgbmFtZSBdXG4gIH1cbiAgXG4gIGZvciggbGV0IG5hbWUgaW4gZGVzY3JpcHRpb25zICkge1xuICAgIGNvbnN0IGRlc2MgPSBkZXNjcmlwdGlvbnNbIG5hbWUgXVxuICAgIGNyZWF0ZVByaW1pdGl2ZSggbmFtZSwgZGVzYyApXG4gIH1cblxuICBQcmltaXRpdmVzLmNyZWF0ZSA9IGNyZWF0ZVByaW1pdGl2ZVxuXG4gIHJldHVybiBQcmltaXRpdmVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUHJpbWl0aXZlc1xuIiwiY29uc3QgZ2xzbCA9IHJlcXVpcmUoICdnbHNsaWZ5JyApXG5cbmNvbnN0IGdldE1haW5Db250aW51b3VzID0gZnVuY3Rpb24oIHN0ZXBzLCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UsIHBvc3Rwcm9jZXNzaW5nICkge1xuICBjb25zdCBvdXQgPSBgXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbGRmU1dzXG4gIHZlYzMgY2FsY05vcm1hbCh2ZWMzIHBvcywgZmxvYXQgZXBzKSB7XG4gICAgY29uc3QgdmVjMyB2MSA9IHZlYzMoIDEuMCwtMS4wLC0xLjApO1xuICAgIGNvbnN0IHZlYzMgdjIgPSB2ZWMzKC0xLjAsLTEuMCwgMS4wKTtcbiAgICBjb25zdCB2ZWMzIHYzID0gdmVjMygtMS4wLCAxLjAsLTEuMCk7XG4gICAgY29uc3QgdmVjMyB2NCA9IHZlYzMoIDEuMCwgMS4wLCAxLjApO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZSggdjEgKiBzY2VuZSAoIHBvcyArIHYxKmVwcyApLngrXG4gICAgICAgICAgICAgICAgICAgICAgdjIgKiBzY2VuZSAoIHBvcyArIHYyKmVwcyApLngrXG4gICAgICAgICAgICAgICAgICAgICAgdjMgKiBzY2VuZSAoIHBvcyArIHYzKmVwcyApLngrXG4gICAgICAgICAgICAgICAgICAgICAgdjQgKiBzY2VuZSAoIHBvcyArIHY0KmVwcyApLngpO1xuICB9XG5cbiAgdmVjMyBjYWxjTm9ybWFsKHZlYzMgcG9zKSB7XG4gICAgcmV0dXJuIGNhbGNOb3JtYWwocG9zLCAwLjAwMik7XG4gIH1cblxuICAvLyBBZGFwdGVkIGZyb20gZnJvbSBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbGRmU1dzXG4gIHZlYzIgY2FsY1JheUludGVyc2VjdGlvbiggdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyLCBmbG9hdCBtYXhkLCBmbG9hdCBwcmVjaXMgKSB7XG4gICAgZmxvYXQgbGF0ZXN0ID0gcHJlY2lzICogMi4wO1xuICAgIGZsb2F0IGRpc3QgICA9ICswLjA7XG4gICAgZmxvYXQgdHlwZSAgID0gLTEuMDtcbiAgICB2ZWMyIHJlc3VsdDtcbiAgICB2ZWMyIHJlcyA9IHZlYzIoLTUwMDAwLiwgLTEuKTs7XG5cbiAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7c3RlcHN9IDsgaSsrKSB7XG4gICAgICBpZiAobGF0ZXN0IDwgcHJlY2lzIHx8IGRpc3QgPiBtYXhkKSBicmVhaztcblxuICAgICAgcmVzdWx0ID0gc2NlbmUocmF5T3JpZ2luICsgcmF5RGlyICogZGlzdCk7XG5cbiAgICAgIGxhdGVzdCA9IHJlc3VsdC54O1xuICAgICAgZGlzdCAgKz0gbGF0ZXN0O1xuICAgIH1cblxuICAgIGlmKCBkaXN0IDwgbWF4ZCApIHtcbiAgICAgIHJlc3VsdC54ID0gZGlzdDtcbiAgICAgIHJlcyA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgb3V0IHZlYzQgY29sO1xuICB2b2lkIG1haW4oKSB7XG4gICAgdmVjMiBwb3MgPSB2X3V2ICogMi4wIC0gMS4wO1xuXG4gICAgLy8gbm90IHN1cmUgd2h5IEkgbmVlZCB0aGUgLXkgYXhpcyBidXQgd2l0aG91dCBpdFxuICAgIC8vIGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCB1c2luZyBwZXJzcGVjdGl2ZS1jYW1lcmFcbiAgICBwb3MueCAqPSAoIHJlc29sdXRpb24ueCAvIC1yZXNvbHV0aW9uLnkgKTtcblxuICAgIHZlYzMgY29sb3IgPSBiZzsgXG4gICAgdmVjMyBybyA9IGNhbWVyYV9wb3M7XG4gICAgdmVjMyByZCA9IG5vcm1hbGl6ZSggbWF0MyhjYW1lcmEpICogdmVjMyggcG9zLCAyLiApICk7IFxuICAgIFxuICAgIHZlYzIgdCA9IGNhbGNSYXlJbnRlcnNlY3Rpb24oIHJvLCByZCwgJHttYXhEaXN0YW5jZX0sICR7bWluRGlzdGFuY2V9ICk7XG5cbiAgICBpZiggdC54ID4gLTAuNSApIHtcbiAgICAgIHZlYzMgcG9zID0gcm8gKyByZCAqIHQueDtcbiAgICAgIHZlYzMgbm9yID0gY2FsY05vcm1hbCggcG9zICk7XG5cbiAgICAgIGNvbG9yID0gbGlnaHRpbmcoIHBvcywgbm9yLCBybywgcmQsIHQueSwgdHJ1ZSApOyBcbiAgICB9XG5cbiAgICAke3Bvc3Rwcm9jZXNzaW5nfVxuICAgIFxuICAgIGNvbCA9IGNsYW1wKCB2ZWM0KCBjb2xvciwgMS4wICksIDAuLCAxLiApO1xuICB9YFxuXG4gIHJldHVybiBvdXRcbn1cblxuY29uc3QgZ2V0TWFpblZveGVscyA9IGZ1bmN0aW9uKCBzdGVwcywgcG9zdHByb2Nlc3NpbmcsIHZveGVsU2l6ZSA9IC4xICkge1xuICBjb25zdCBvdXQgPSBgXG4gIHN0cnVjdCBWb3hlbERpc3RhbmNlIHtcbiAgICBidmVjMyBtYXNrO1xuICAgIHZlYzMgIGRpc3RhbmNlO1xuICAgIGZsb2F0IGZvZ0NvZWZmO1xuICAgIGludCAgIGlkO1xuICB9O1xuXG4gIFZveGVsRGlzdGFuY2UgY2FsY1JheUludGVyc2VjdGlvbiggdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyICkge1xuICAgIHZlYzIgcmVzdWx0O1xuXG4gICAgZmxvYXQgbSA9ICR7dm94ZWxTaXplfTtcbiAgICByYXlPcmlnaW4gKj0gMS4vbTtcbiAgICB2ZWMzIG1hcFBvcyA9IHZlYzMoZmxvb3IocmF5T3JpZ2luKSk7XG4gICAgdmVjMyBkaWZmID0gbWFwUG9zIC0gcmF5T3JpZ2luO1xuXG4gICAgdmVjMyBkZWx0YURpc3QgPSBhYnModmVjMyhsZW5ndGgocmF5RGlyKSkgLyByYXlEaXIpO1xuICAgIHZlYzMgcmF5U3RlcCA9IHZlYzMoc2lnbihyYXlEaXIpKTtcbiAgICB2ZWMzIHNpZGVEaXN0ID0gKHNpZ24ocmF5RGlyKSAqIGRpZmYgKyAoc2lnbihyYXlEaXIpICogMC41KSArIDAuNSkgKiBkZWx0YURpc3Q7IFxuXG4gICAgYnZlYzMgbWFzaztcbiAgICB2ZWMzIGQgPSB2ZWMzKC0xMDAwMDAuKTtcbiAgICBmbG9hdCBmb2dDb2VmZiA9IDAuO1xuXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke01hdGgucm91bmQoc3RlcHMqMS92b3hlbFNpemUpfSA7IGkrKykge1xuICAgICAgcmVzdWx0ID0gc2NlbmUobWFwUG9zKm0pO1xuICAgICAgaWYoIHJlc3VsdC54IDw9IDAuICkge1xuICAgICAgICBkID0gbWFwUG9zKm0rcmVzdWx0Lng7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtYXNrID0gYnZlYzMoIGxlc3NUaGFuRXF1YWwoc2lkZURpc3QueHl6LCBtaW4oc2lkZURpc3QueXp4LCBzaWRlRGlzdC56eHkpKSApO1xuICAgICAgc2lkZURpc3QgKz0gdmVjMyggbWFzayApICogZGVsdGFEaXN0OyBcbiAgICAgIG1hcFBvcyArPSB2ZWMzKG1hc2spICogcmF5U3RlcDtcbiAgICAgIGZvZ0NvZWZmICs9IHJlc3VsdC54ICogbTtcbiAgICB9XG5cbiAgICBWb3hlbERpc3RhbmNlIHZkID0gVm94ZWxEaXN0YW5jZSggbWFzaywgZCwgZm9nQ29lZmYsIGludChyZXN1bHQueSkgKTtcbiAgICByZXR1cm4gdmQ7XG4gIH1cblxuICBvdXQgdmVjNCBjb2w7XG4gIHZvaWQgbWFpbigpIHtcbiAgICB2ZWMyIHBvcyA9IHZfdXYgKiAyLjAgLSAxLjA7XG5cbiAgICAvLyBub3Qgc3VyZSB3aHkgSSBuZWVkIHRoZSAteSBheGlzIGJ1dCB3aXRob3V0IGl0XG4gICAgLy8gZXZlcnl0aGluZyBpcyBmbGlwcGVkIHVzaW5nIHBlcnNwZWN0aXZlLWNhbWVyYVxuICAgIHBvcy54ICo9ICggcmVzb2x1dGlvbi54IC8gLXJlc29sdXRpb24ueSApO1xuICAgIFxuICAgIHZlYzMgY29sb3IgPSBiZzsgXG4gICAgdmVjMyBybyA9IGNhbWVyYV9wb3M7XG4gICAgdmVjMyByZCA9IG5vcm1hbGl6ZSggbWF0MyhjYW1lcmEpICogdmVjMyggcG9zLCAyLiApICk7IFxuICAgICAgICAgICAgICAgICBcbiAgICBWb3hlbERpc3RhbmNlIHZkID0gY2FsY1JheUludGVyc2VjdGlvbiggcm8sIHJkICk7XG4gICAgYnZlYzMgbWFzayA9IHZkLm1hc2s7XG4gICAgXG4gICAgdmVjMyBub3I7XG4gICAgaWYgKG1hc2sueCkge1xuICAgICAgY29sb3IgPSB2ZWMzKDAuNSk7XG4gICAgICBub3IgPSB2ZWMzKDEuLDAuLDAuKTtcbiAgICB9XG4gICAgaWYgKG1hc2sueSkge1xuICAgICAgY29sb3IgPSB2ZWMzKDEuMCk7XG4gICAgICBub3IgPSB2ZWMzKDAuLDEuLDAuKTtcbiAgICB9XG4gICAgaWYgKG1hc2sueikge1xuICAgICAgY29sb3IgPSB2ZWMzKDAuNzUpO1xuICAgICAgbm9yID0gdmVjMygwLiwwLiwxLik7XG4gICAgfVxuICAgIGlmKCB2ZC5kaXN0YW5jZS54ID09IC0xMDAwMDAuICkge1xuICAgICAgY29sb3IgPSBiZztcbiAgICB9XG4gICAgXG4gICAgZmxvYXQgbW9kQW1vdW50ID0gJHsoMS4vdm94ZWxTaXplKS50b0ZpeGVkKDEpfTtcbiAgICBpZiggY29sb3IgIT0gYmcgKSB7XG4gICAgICB2ZWMzIHBvcyA9IHZkLmRpc3RhbmNlOyBcbiAgICAgIC8vdmVjMyBwb3MgPSBybyArIHJkICogdmQuZm9nQ29lZmY7XG5cbiAgICAgIGNvbG9yICo9IGxpZ2h0aW5nKCBwb3MgKiBtb2RBbW91bnQsIG5vciwgcm8sIHJkLCBmbG9hdCh2ZC5pZCksIGZhbHNlICk7IFxuICAgICAgLy9jb2xvciAqPSBsaWdodGluZyggcG9zLCBub3IsIHJvLCByZCwgZmxvYXQodmQuaWQpLCBmYWxzZSApOyBcbiAgICAgIC8vY29sb3IgPSBtaW4oY29sb3IsMS4pO1xuICAgICAgLy9jb2xvciA9IGdldFRleHR1cmUoIDAsIHBvcyApO1xuICAgICAgXG4gICAgfVxuICAgIFxuICAgIHZlYzIgdCA9IHZlYzIoIHZkLmZvZ0NvZWZmLCB2ZC5pZCApO1xuICAke3Bvc3Rwcm9jZXNzaW5nfTsgXG4gICAgY29sID0gdmVjNCggY29sb3IsIDEuICk7IFxuICB9YFxuXG4gIHJldHVybiBvdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggdmFyaWFibGVzLCBzY2VuZSwgcHJlZmFjZSwgZ2VvbWV0cmllcywgbGlnaHRpbmcsIHBvc3Rwcm9jZXNzaW5nLCBzdGVwcz05MCwgbWluRGlzdGFuY2U9LjAwMSwgbWF4RGlzdGFuY2U9MjAsIG9wcywgdm94ZWxTaXplPTAgKSB7XG5cbiAgY29uc3QgbWFpbiA9IHZveGVsU2l6ZSA9PT0gMFxuICAgID8gZ2V0TWFpbkNvbnRpbnVvdXMoIHN0ZXBzLCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UsIHBvc3Rwcm9jZXNzaW5nICkgXG4gICAgOiBnZXRNYWluVm94ZWxzKCBzdGVwcywgcG9zdHByb2Nlc3NpbmcsIHZveGVsU2l6ZSApXG5cbiAgICBjb25zdCBmc19zb3VyY2UgPSBnbHNsKFtcIiAgICAgI3ZlcnNpb24gMzAwIGVzXFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5cXG4gICAgICBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzO1xcblxcbiAgICAgIGluIHZlYzIgdl91djtcXG5cXG4gICAgICBzdHJ1Y3QgTGlnaHQge1xcbiAgICAgICAgdmVjMyBwb3NpdGlvbjtcXG4gICAgICAgIHZlYzMgY29sb3I7XFxuICAgICAgICBmbG9hdCBhdHRlbnVhdGlvbjtcXG4gICAgICB9O1xcblxcbiAgICAgIGludCByb3RhdGlvbkNvdW50ID0gMTtcXG5cXG4gICAgICBtYXQ0IHJvdGF0aW9uc1s0XSA9IG1hdDRbNF0oXFxuICAgICAgICBtYXQ0KDAuKSwgbWF0NCgwLiksIG1hdDQoMC4pLCBtYXQ0KDAuKVxcbiAgICAgICk7XFxuXFxuICAgICAgc3RydWN0IE1hdGVyaWFsIHtcXG4gICAgICAgIGludCAgbW9kZTtcXG4gICAgICAgIHZlYzMgYW1iaWVudDtcXG4gICAgICAgIHZlYzMgZGlmZnVzZTtcXG4gICAgICAgIHZlYzMgc3BlY3VsYXI7XFxuICAgICAgICBmbG9hdCBzaGluaW5lc3M7XFxuICAgICAgICB2ZWMzIGZyZXNuZWw7XFxuICAgICAgICBpbnQgdGV4dHVyZUlEO1xcbiAgICAgIH07ICAgICBcXG5cXG4gICAgICBzdHJ1Y3QgU0RGIHtcXG4gICAgICAgIGludCBtYXRlcmlhbElEO1xcbiAgICAgICAgbWF0NCB0cmFuc2Zvcm07XFxuICAgICAgICBpbnQgdGV4dHVyZUlEO1xcbiAgICAgICAgdmVjMyByZXBlYXQ7XFxuICAgICAgICBtYXQ0IHJlcGVhdFRyYW5zZm9ybTtcXG4gICAgICB9O1xcblxcbiAgICAgIHVuaWZvcm0gZmxvYXQgdGltZTtcXG4gICAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG4gICAgICB1bmlmb3JtIHZlYzMgY2FtZXJhX3BvcztcXG4gICAgICB1bmlmb3JtIHZlYzMgY2FtZXJhX25vcm1hbDtcXG4gICAgICB1bmlmb3JtIGZsb2F0IGNhbWVyYV9yb3Q7XFxuICAgICAgdW5pZm9ybSBtYXQ0IGNhbWVyYTtcXG5cXG4gICAgICBcIixcIlxcblxcbiAgICAgIC8vIG11c3QgYmUgYmVmb3JlIGdlb21ldHJpZXMhXFxuICAgICAgZmxvYXQgbGVuZ3RoOCggdmVjMiBwICkgeyBcXG4gICAgICAgIHJldHVybiBmbG9hdCggcG93KCBwb3cocC54LDguKStwb3cocC55LDguKSwgMS4vOC4gKSApOyBcXG4gICAgICB9XFxuXFxuICAgICAgXCIsXCJcXG5cXG4gICAgICAvKiBHRU9NRVRSSUVTICovXFxuICAgICAgXCIsXCJcXG5cXG4gICAgICB2ZWMyIHNjZW5lKHZlYzMgcCk7XFxuXFxuICAgICAgLy8gWFhYIHRvZG8gcHV0IHRoaXMgaW4gZG9tYWluT3BlcmF0aW9ucy5qc1xcbiAgICAgIHZlYzMgcG9sYXJSZXBlYXQodmVjMyBwLCBmbG9hdCByZXBldGl0aW9ucykge1xcbiAgICAgICAgZmxvYXQgYW5nbGUgPSAyLipQSS9yZXBldGl0aW9ucztcXG4gICAgICAgIGZsb2F0IGEgPSBhdGFuKHAueiwgcC54KSArIGFuZ2xlLzIuO1xcbiAgICAgICAgZmxvYXQgciA9IGxlbmd0aChwLnh6KTtcXG4gICAgICAgIGZsb2F0IGMgPSBmbG9vcihhL2FuZ2xlKTtcXG4gICAgICAgIGEgPSBtb2QoYSxhbmdsZSkgLSBhbmdsZS8yLjtcXG4gICAgICAgIHZlYzMgX3AgPSB2ZWMzKCBjb3MoYSkgKiByLCBwLnksICBzaW4oYSkgKiByICk7XFxuICAgICAgICAvLyBGb3IgYW4gb2RkIG51bWJlciBvZiByZXBldGl0aW9ucywgZml4IGNlbGwgaW5kZXggb2YgdGhlIGNlbGwgaW4gLXggZGlyZWN0aW9uXFxuICAgICAgICAvLyAoY2VsbCBpbmRleCB3b3VsZCBiZSBlLmcuIC01IGFuZCA1IGluIHRoZSB0d28gaGFsdmVzIG9mIHRoZSBjZWxsKTpcXG4gICAgICAgIGlmIChhYnMoYykgPj0gKHJlcGV0aXRpb25zLzIuKSkgYyA9IGFicyhjKTtcXG4gICAgICAgIHJldHVybiBfcDtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gYWRkZWQgayB2YWx1ZSB0byBnbHNsLXNkZi1vcHMvc29mdC1zaGFkb3dcXG4gICAgICBmbG9hdCBzb2Z0c2hhZG93KCBpbiB2ZWMzIHJvLCBpbiB2ZWMzIHJkLCBpbiBmbG9hdCBtaW50LCBpbiBmbG9hdCB0bWF4LCBpbiBmbG9hdCBrICl7XFxuICAgICAgICBmbG9hdCByZXMgPSAxLjA7XFxuICAgICAgICBmbG9hdCB0ID0gbWludDtcXG5cXG4gICAgICAgIGZvciggaW50IGkgPSAwOyBpIDwgMTI7IGkrKyApIHtcXG4gICAgICAgICAgZmxvYXQgaCA9IHNjZW5lKCBybyArIHJkICogdCApLng7XFxuICAgICAgICAgIHJlcyA9IG1pbiggcmVzLCBrICogaCAvIHQgKTtcXG4gICAgICAgICAgdCArPSBjbGFtcCggaCwgMC4wMiwgMC4xMCApO1xcbiAgICAgICAgICBpZiggaDwwLjAwMSB8fCB0PnRtYXggKSBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBjbGFtcCggcmVzLCAwLjAsIDEuMCApO1xcbiAgICAgIH1cXG5cXG5cIixcIlxcblxcbiAgICB2ZWMyIHNjZW5lKHZlYzMgX3AgKSB7XFxuICAgICAgdmVjNCBwID0gdmVjNCggX3AsIDEuICk7XFxuXCIsXCJcXG4gICAgICByZXR1cm4gXCIsXCI7XFxuICAgIH1cXG4gXFxuXCIsXCJcXG5cIixcIlwiXSx2YXJpYWJsZXMsb3BzLGdlb21ldHJpZXMsbGlnaHRpbmcscHJlZmFjZSxzY2VuZSxtYWluKVxuXG4gICAgcmV0dXJuIGZzX3NvdXJjZVxuICB9XG4iLCJjb25zdCBnZXRGb2cgPSByZXF1aXJlKCAnLi9mb2cuanMnIClcbmNvbnN0IHZpZ25ldHRlID0gcmVxdWlyZSggJy4vdmlnbmV0dGUuanMnIClcbmNvbnN0IHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnIClcbmNvbnN0IF9fbGlnaHRpbmcgPSByZXF1aXJlKCAnLi9saWdodGluZy5qcycgKVxuY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9ID0gcmVxdWlyZSgnLi92YXIuanMnKVxuXG5jb25zdCBnZXRTY2VuZSA9IGZ1bmN0aW9uKCBTREYgKSB7XG5cbiAgU2NlbmUgPSBmdW5jdGlvbiggb2JqcywgY2FudmFzLCBzdGVwcz0xMDAsIG1pbkRpc3RhbmNlPS4wMDEsIG1heERpc3RhbmNlPTQwLCBzaXplPTIsIHNob3VsZEFuaW1hdGU9ZmFsc2UgKSB7XG4gICAgY29uc3Qgc2NlbmUgID0gT2JqZWN0LmNyZWF0ZSggU2NlbmUucHJvdG90eXBlIClcblxuICAgIE1hdGVyaWFsSUQuY2xlYXIoKVxuXG4gICAgU0RGLmxpZ2h0aW5nLmxpZ2h0cyA9IFtdXG5cbiAgICBzY2VuZS5fX3ByZXJlbmRlciA9IG9ianNcbiAgICBpZiggb2Jqcy5sZW5ndGggPiAxICkge1xuICAgICAgLy8gcmVkdWNlIG9iamVjdHMgdG8gbmVzdGVkIFVuaW9uc1xuICAgICAgc2NlbmUuX19wcmVyZW5kZXIgPSBvYmpzLnJlZHVjZSggKCBjdXJyZW50LCBuZXh0ICkgPT4gU0RGLlVuaW9uKCBjdXJyZW50LCBuZXh0ICkgKVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIHNjZW5lLCB7IFxuICAgICAgb2JqcywgXG4gICAgICBjYW52YXMsXG4gICAgICBwb3N0cHJvY2Vzc2luZzpbXSxcbiAgICAgIF9fc2hhZG93OjhcbiAgICB9KVxuXG4gICAgc2NlbmUuYW5pbWF0ZSggc2hvdWxkQW5pbWF0ZSApXG4gICAgICAuc3RlcHMoIHN0ZXBzIClcbiAgICAgIC50aHJlc2hvbGQoIG1pbkRpc3RhbmNlIClcbiAgICAgIC5mYXJQbGFuZSggbWF4RGlzdGFuY2UgKVxuICAgICAgLnJlc29sdXRpb24oIDEgKVxuXG4gICAgc2NlbmUudXNlUXVhbGl0eSA9IHRydWVcbiAgICBzY2VuZS51c2VWb3hlbHMgID0gZmFsc2VcblxuICAgIFNERi5fX3NjZW5lID0gc2NlbmVcblxuICAgIHJldHVybiBzY2VuZVxuICB9XG5cbiAgU2NlbmUucHJvdG90eXBlID0ge1xuICAgIGFuaW1hdGUoIHYgKSB7IHRoaXMuX19hbmltYXRlID0gdjsgcmV0dXJuIHRoaXMgfSwgIFxuICAgIHJlc29sdXRpb24oIHYgKSB7IFxuICAgICAgdGhpcy53aWR0aCA9IE1hdGguZmxvb3IoIHRoaXMuY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGggKiB2IClcbiAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggdGhpcy5jYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICogdiApXG4gICAgICBcbiAgICAgIHRoaXMuX19yZXNvbHV0aW9uID0gdjtcbiAgICAgIHRoaXMudXNlUXVhbGl0eSA9IGZhbHNlXG4gICAgICByZXR1cm4gdGhpcyBcbiAgICB9LCAgXG4gICAgdm94ZWwoIHYgPSAuMSApIHsgXG4gICAgICB0aGlzLnVzZVZveGVscyA9IHRydWVcbiAgICAgIHRoaXMuX192b3hlbFNpemUgPSB2XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgdGhyZXNob2xkKCB2ICkgeyB0aGlzLl9fdGhyZXNob2xkID0gdjsgdGhpcy51c2VRdWFsaXR5ID0gZmFsc2U7IHJldHVybiB0aGlzIH0sICBcbiAgICBzdGVwcyggdiApIHsgdGhpcy5fX3N0ZXBzID0gdjsgdGhpcy51c2VRdWFsaXR5ID0gZmFsc2U7IHJldHVybiB0aGlzIH0sICBcbiAgICBmYXJQbGFuZSggdiApIHsgdGhpcy5fX2ZhclBsYW5lID0gdjsgdGhpcy51c2VRdWFsaXR5ID0gZmFsc2U7ICByZXR1cm4gdGhpcyB9LCAgXG4gICAgY2FtZXJhKCB4PTAsIHk9MCwgej01LCBzcGVlZD0xICkge1xuICAgICAgU0RGLmNhbWVyYS5fX2NhbWVyYS5wb3NpdGlvblswXSA9IHhcbiAgICAgIFNERi5jYW1lcmEuX19jYW1lcmEucG9zaXRpb25bMV0gPSB5XG4gICAgICBTREYuY2FtZXJhLl9fY2FtZXJhLnBvc2l0aW9uWzJdID0gelxuICAgICAgU0RGLmNhbWVyYS5fX2NhbWVyYS5yb3RhdGlvblNwZWVkID0gc3BlZWQgKiAuMDFcbiAgICAgIFNERi5jYW1lcmEuX19jYW1lcmEucG9zaXRpb25TcGVlZCA9IHNwZWVkICogLS4yNVxuICAgICAgU0RGLmNhbWVyYS51cGRhdGUoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIHNoYWRvdyggaz0wICkge1xuICAgICAgdGhpcy5fX3NoYWRvdyA9IGs7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHF1YWxpdHkoIHF1YWxpdHk9MTAgKSB7XG4gICAgICB0aGlzLnRocmVzaG9sZCggLjEgLyAocXVhbGl0eSAqIHF1YWxpdHkgKiBxdWFsaXR5ICkgKVxuICAgICAgdGhpcy5zdGVwcyggcXVhbGl0eSAqIDIwIClcbiAgICAgIHRoaXMuZmFyUGxhbmUoIHF1YWxpdHkgKiA1IClcbiAgICAgIHRoaXMucmVzb2x1dGlvbiggTWF0aC5taW4oIC4yICogcXVhbGl0eSwgMiApIClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGxpZ2h0KCAuLi5saWdodHMgKSB7XG4gICAgICBTREYubGlnaHRpbmcubGlnaHRzID0gU0RGLmxpZ2h0aW5nLmxpZ2h0cy5jb25jYXQoIGxpZ2h0cyApXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZm9nOiBnZXRGb2coIFNjZW5lLCBTREYgKSxcbiAgICB2aWduZXR0ZTogdmlnbmV0dGUoIFNjZW5lLCBTREYgKSxcbiAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCAnLi9iYWNrZ3JvdW5kLmpzJyApKCBTY2VuZSwgU0RGICksXG4gICAgcHJlc2V0czoge1xuICAgICAgJ2ZyYWN0YWwuY2xvc2UnOiB7XG4gICAgICAgIGZhclBsYW5lOjEsXG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgc3RlcHM6MTUwLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICB0aHJlc2hvbGQ6LjAwMDEyNVxuICAgICAgfSxcbiAgICAgICdmcmFjdGFsLmtpbmRhY2xvc2UnOiB7XG4gICAgICAgIGZhclBsYW5lOjIsXG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgc3RlcHM6MjUwLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICB0aHJlc2hvbGQ6LjAwMDEyNS8yXG4gICAgICB9LFxuICAgICAgJ2ZyYWN0YWwubWVkJzoge1xuICAgICAgICBmYXJQbGFuZTo1LFxuICAgICAgICByZXNvbHV0aW9uOi43NSxcbiAgICAgICAgc3RlcHM6ODAsXG4gICAgICAgIGFuaW1hdGVkOnRydWUsXG4gICAgICAgIHRocmVzaG9sZDouMDAxLFxuICAgICAgfSxcbiAgICAgICdmcmFjdGFsLmxvdyc6IHtcbiAgICAgICAgZmFyUGxhbmU6My4wLFxuICAgICAgICByZXNvbHV0aW9uOi41LFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczo1MCxcbiAgICAgICAgdGhyZXNob2xkOi4wMDUsXG4gICAgICB9LFxuICAgICAgJ2ZyYWN0YWwuaGlnaCc6IHtcbiAgICAgICAgZmFyUGxhbmU6MTAsXG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgc3RlcHM6MTAwLFxuICAgICAgICB0aHJlc2hvbGQ6LjAwMSxcbiAgICAgIH0sXG4gICAgICAncmVwZWF0Lmxvdyc6IHtcbiAgICAgICAgZmFyUGxhbmU6MjUsXG4gICAgICAgIHJlc29sdXRpb246LjUsXG4gICAgICAgIGFuaW1hdGVkOnRydWUsXG4gICAgICAgIHN0ZXBzOjUwXG4gICAgICB9LFxuICAgICAgJ3JlcGVhdC5tZWQnOiB7XG4gICAgICAgIGZhclBsYW5lOjM1LFxuICAgICAgICByZXNvbHV0aW9uOjEsXG4gICAgICAgIGFuaW1hdGVkOnRydWUsXG4gICAgICAgIHN0ZXBzOjc1XG4gICAgICB9LFxuICAgICAgJ3JlcGVhdC5oaWdoJzoge1xuICAgICAgICBmYXJQbGFuZTo0MCxcbiAgICAgICAgcmVzb2x1dGlvbjoxLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczoxMDBcbiAgICAgIH0sXG4gICAgICAndm94ZWwuaGlnaCc6IHtcbiAgICAgICAgcmVzb2x1dGlvbjoxLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczozMFxuICAgICAgfSxcbiAgICAgICd2b3hlbC5tZWQnOiB7XG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgc3RlcHM6MjBcbiAgICAgIH0sXG4gICAgICAndm94ZWwubG93Jzoge1xuICAgICAgICByZXNvbHV0aW9uOi41LFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczoxMFxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXBwbHlQcmVzZXQoIHByZXNldE5hbWUgKSB7XG4gICAgICBjb25zdCBwcmVzZXQgPSB0aGlzLnByZXNldHNbIHByZXNldE5hbWUgXVxuICAgICAgaWYoIHByZXNldC5mYXJQbGFuZSAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYXJQbGFuZSggcHJlc2V0LmZhclBsYW5lIClcbiAgICAgIHRoaXMuc3RlcHMoIHByZXNldC5zdGVwcyApXG4gICAgICB0aGlzLnJlc29sdXRpb24oIHByZXNldC5yZXNvbHV0aW9uIClcbiAgICAgIHRoaXMudGhyZXNob2xkKCBwcmVzZXQudGhyZXNob2xkIHx8IC4wMDEgKVxuXG4gICAgICByZXR1cm4gcHJlc2V0LmFuaW1hdGVkXG4gICAgfSxcbiAgICByZW5kZXIoIHF1YWxpdHk9MTAsIGFuaW1hdGU9ZmFsc2UsIHVzZVF1YWxpdHk9dHJ1ZSApIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZCgpIC8vIGFkZHMgZGVmYXVsdCBpZiBub25lIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgICAgaWYoIHR5cGVvZiBxdWFsaXR5ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgYW5pbWF0ZSA9IHRoaXMuYXBwbHlQcmVzZXQoIHF1YWxpdHkgKVxuICAgICAgfWVsc2UgaWYoIHRoaXMudXNlUXVhbGl0eSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgdGhpcy5xdWFsaXR5KCBxdWFsaXR5IClcbiAgICAgIH1cbiAgICAgIHRoaXMuYW5pbWF0ZSggYW5pbWF0ZSApXG5cbiAgICAgIFNERi5kaXN0YW5jZU9wcy5fX2NsZWFyKClcbiAgICAgIFNERi50ZXh0dXJlcy5jbGVhcigpXG4gICAgICBjb25zdCBnZW9tZXRyaWVzID0gU0RGLnByaW1pdGl2ZXMuZW1pdF9nZW9tZXRyaWVzKClcblxuICAgICAgbGV0IFsgdmFyaWFibGVzRGVjbGFyYXRpb24sIHNjZW5lUmVuZGVyaW5nLCBwb3N0cHJvY2Vzc2luZyBdID0gU0RGLmdlbmVyYXRlU0RGKCB0aGlzIClcblxuICAgICAgY29uc3QgbGlnaHRpbmcgPSBTREYubGlnaHRpbmcuZ2VuKCB0aGlzLl9fc2hhZG93LCBnZW9tZXRyaWVzIClcbiAgICAgIHZhcmlhYmxlc0RlY2xhcmF0aW9uICs9IFNERi5tYXRlcmlhbHMuZW1pdF9kZWNsKCkgXG4gICAgICB2YXJpYWJsZXNEZWNsYXJhdGlvbiArPSBTREYudGV4dHVyZXMuZW1pdF9kZWNsKCkgXG4gICAgICB2YXJpYWJsZXNEZWNsYXJhdGlvbiArPSBTREYubGlnaHRpbmcuZW1pdF9kZWNsKCkgXG5cbiAgICAgIHRoaXMuZnMgPSBTREYucmVuZGVyRnJhZ21lbnRTaGFkZXIoIFxuICAgICAgICB2YXJpYWJsZXNEZWNsYXJhdGlvbiwgXG4gICAgICAgIHNjZW5lUmVuZGVyaW5nLm91dCwgXG4gICAgICAgIHNjZW5lUmVuZGVyaW5nLnByZWZhY2UsXG4gICAgICAgIFNERi5yZXF1aXJlZEdlb21ldHJpZXMuam9pbignXFxuJykgKyBTREYucmVxdWlyZWRPcHMuam9pbignXFxuJyksXG4gICAgICAgIGxpZ2h0aW5nLFxuICAgICAgICBwb3N0cHJvY2Vzc2luZywgXG4gICAgICAgIHRoaXMuX19zdGVwcywgdGhpcy5fX3RocmVzaG9sZCwgdGhpcy5fX2ZhclBsYW5lLnRvRml4ZWQoMSksXG4gICAgICAgIFNERi5kaXN0YW5jZU9wcy5fX2dldEdMU0woKSxcbiAgICAgICAgdGhpcy51c2VWb3hlbHMgPyB0aGlzLl9fdm94ZWxTaXplIDogMFxuICAgICAgKVxuXG4gICAgICBTREYuc3RhcnQoIHRoaXMuZnMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLl9fYW5pbWF0ZSApXG5cbiAgICAgIC8vU0RGLm1hdGVyaWFscy5tYXRlcmlhbHMubGVuZ3RoID0gMFxuXG4gICAgICB0aGlzLnVzZVF1YWxpdHkgPSB0cnVlXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICB9XG5cbiAgcmV0dXJuIFNjZW5lXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTY2VuZSBcbiIsImNvbnN0IFNjZW5lTm9kZSA9ICgpPT4gT2JqZWN0LmNyZWF0ZSggU2NlbmVOb2RlLnByb3RvdHlwZSApXG5jb25zdCBNYXRyaXggPSByZXF1aXJlKCAnLi9leHRlcm5hbC9tYXRyaXguanMnIClcblxuU2NlbmVOb2RlLnByb3RvdHlwZSA9IHtcblx0ZW1pdCgpIHsgcmV0dXJuIFwiI05vdEltcGxlbWVudGVkI1wiOyB9LFxuXG5cdGVtaXRfZGVjbCgpIHsgcmV0dXJuIFwiXCI7IH0sXG5cblx0dXBkYXRlX2xvY2F0aW9uKGdsLCBwcm9ncmFtKSB7fSxcblxuICB1cGxvYWRfZGF0YShnbCkge30sXG5cbiAgZ2V0SUQoKSB7XG4gICAgbGV0IGlkID0gdGhpcy5pZFxuXG4gICAgaWYoIGlkID09PSB1bmRlZmluZWQgJiYgdGhpcy5zZGYgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlkID0gdGhpcy5zZGYuZ2V0SUQoKVxuICAgIH1cblxuICAgIHJldHVybiBpZFxuICB9LFxuXG4gIGdldENlbnRlcigpIHtcbiAgICBsZXQgY2VudGVyID0gdGhpcy5jZW50ZXJcblxuICAgIGlmKCBjZW50ZXIgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNkZiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgaWYoIHRoaXMuc2RmLmdldENlbnRlciA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBjZW50ZXIgPSB0aGlzLnNkZi5fX3dyYXBwZWQuZ2V0Q2VudGVyKClcbiAgICAgIH1lbHNle1xuICAgICAgICBjZW50ZXIgPSB0aGlzLnNkZi5nZXRDZW50ZXIoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjZW50ZXJcbiAgfSxcblxuICBtb3ZlKCAuLi5hcmdzICkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSggLi4uYXJncyApXG4gIH0sXG5cbiAgcm90YXRlKCBhbmdsZSwgeCx5LHogKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24uYW5nbGUgPSBhbmdsZVxuICAgIGlmKCB4ICE9PSB1bmRlZmluZWQgKSB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbi5heGlzLnggPSB4XG4gICAgaWYoIHkgIT09IHVuZGVmaW5lZCApIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uLmF4aXMueSA9IHlcbiAgICBpZiggeiAhPT0gdW5kZWZpbmVkICkgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24uYXhpcy56ID0gelxuICBcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIHJvdGF0ZUJ5KCBhbmdsZSx4LHkseiApIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5fX3JvdGF0aW9ucy5wdXNoKCBNYXRyaXgucm90YXRlKCBhbmdsZSx4LHkseiApIClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIHRyYW5zbGF0ZSggeCx5LHogKSB7XG4gICAgaWYoIHggIT09IHVuZGVmaW5lZCAmJiB4ICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0udHJhbnNsYXRpb24ueCA9IHhcbiAgICBpZiggeSAhPT0gdW5kZWZpbmVkICYmIHkgIT09IG51bGwgKSB0aGlzLnRyYW5zZm9ybS50cmFuc2xhdGlvbi55ID0geVxuICAgIGlmKCB6ICE9PSB1bmRlZmluZWQgJiYgeiAhPT0gbnVsbCApIHRoaXMudHJhbnNmb3JtLnRyYW5zbGF0aW9uLnogPSB6XG4gIFxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgc2NhbGUoIGFtb3VudCApIHtcbiAgICBpZiggYW1vdW50ICE9PSB1bmRlZmluZWQgKSB0aGlzLnRyYW5zZm9ybS5zY2FsZSA9IGFtb3VudFxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgbWF0ZXJpYWwoIG1hdCApIHtcbiAgICB0aGlzLl9fc2V0TWF0ZXJpYWwoIG1hdCApXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICB0ZXh0dXJlKCB0ZXgscHJvcHMgKSB7XG4gICAgdGhpcy5fX3NldFRleHR1cmUoIHRleCxwcm9wcyApXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICBidW1wKCB0ZXgsc3RyZW5ndGggKSB7XG4gICAgdGhpcy5fX3NldEJ1bXAoIHRleCxzdHJlbmd0aCApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5jb25zdCBvcHMgPSBbICdyZXBlYXQnLCAncG9sYXJSZXBlYXQnLCAnZWxvbmdhdGlvbicgXVxuXG5vcHMuZm9yRWFjaCggb3AgPT4ge1xuICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSBvcFswXS50b1VwcGVyQ2FzZSgpICsgb3Auc2xpY2UoMSlcbiAgU2NlbmVOb2RlLnByb3RvdHlwZVsgb3AgXSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgIHRoaXNbIG9wIF0gPSB0aGlzWyBvcCBdLmJpbmQoIHRoaXMgKVxuICAgIE9iamVjdC5hc3NpZ24oIHRoaXNbIG9wIF0sIFNjZW5lTm9kZS5wcm90b3R5cGUgKVxuICAgIHRoaXMuX190YXJnZXQgPSB0aGlzWyBvcCBdXG4gICAgdGhpc1sgJ19fJytvcCBdID0gTWFyY2hpbmdbIGNvbnN0cnVjdG9yTmFtZSBdKCB0aGlzLCAuLi5hcmdzLCB0aGlzWyBvcCBdIClcbiAgICB0aGlzWyBvcCBdLnRyYW5zZm9ybSA9IHRoaXNbICdfXycrb3AgXS50cmFuc2Zvcm1cbiAgICByZXR1cm4gdGhpc1xuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lTm9kZVxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApLFxuICAgICAgZ2V0UGl4ZWxzID0gcmVxdWlyZSggJ2dldC1waXhlbHMnICksXG4gICAgICBjcmVhdGVUZXh0dXJlID0gcmVxdWlyZSggJ2dsLXRleHR1cmUyZCcgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gID0gcmVxdWlyZSggJy4vdmFyLmpzJyApLCBcbiAgICAgIHsgVmVjMiwgVmVjMywgVmVjNCB9ID0gcmVxdWlyZSggJy4vdmVjLmpzJyApXG5cblxuY29uc3QgX19UZXh0dXJlcyA9IGZ1bmN0aW9uKCBTREYgKSB7XG4gIGNvbnN0IGdlbnMgPSB7IFxuICAgIGludDogICBpbnRfdmFyX2dlbixcbiAgICBmbG9hdDogZmxvYXRfdmFyX2dlbixcbiAgICB2ZWMyOiB2ZWMyX3Zhcl9nZW4sXG4gICAgdmVjMzogdmVjM192YXJfZ2VuLFxuICAgIHZlYzQ6IHZlYzRfdmFyX2dlbixcbiAgfVxuXG4gIGNvbnN0IHZhcnMgPSB7IFxuICAgIHZlYzI6IFZlYzIsXG4gICAgdmVjMzogVmVjMyxcbiAgICB2ZWM0OiBWZWM0XG4gIH1cblxuICBjb25zdCBUZXh0dXJlcyA9IHtcbiAgICB0ZXh0dXJlczpbXSxcbiAgICBfX3RleHR1cmVzOltdLFxuXG4gICAgX190ZXh0dXJlUHJlZmFjZXM6W10sXG4gICAgX190ZXh0dXJlQm9kaWVzOiAgW10sXG5cbiAgICBfX3R5cGVzOiByZXF1aXJlKCAnLi90ZXh0dXJlRGVzY3JpcHRpb25zLmpzJyApLFxuICAgIF9fd3JhcCA6IHJlcXVpcmUoICcuL3RleHR1cmVXcmFwLmpzJyApLCBcbiAgICBcbiAgICBfX2VtaXRGdW5jdGlvbigpIHtcbiAgICAgIGxldCBwdXNoZWRXcmFwID0gZmFsc2VcblxuICAgICAgbGV0IGRlY2wgPSBgXG4gICAgICB2ZWMzIGdldFRleHR1cmUoIGludCBpZCwgdmVjMyBwb3MgKSB7XG4gICAgICAgIHZlYzMgdGV4O1xuICAgICAgICB2ZWMyIHBvczI7XG5cbiAgICAgICAgc3dpdGNoKCBpZCApIHtcXG5gXG4gICAgICBcbiAgICAgIFRleHR1cmVzLl9fdGV4dHVyZUJvZGllcy5sZW5ndGggPSAwXG5cbiAgICAgIGxldCBmdW5jZGVmcyA9ICcnXG4gICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2goICh0LGkpID0+IHtcbiAgICAgICAgY29uc3QgbW9kZSA9IHQubW9kZSAhPT0gJzJkJyAmJiB0Lmdsc2wgIT09IHVuZGVmaW5lZCA/ICczZCcgOiAnMmQnXG5cbiAgICAgICAgLy8gYWRkIHRleHR1cmUgd3JhcCBmdW5jdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgaWYoIG1vZGUgPT09ICcyZCcgJiYgcHVzaGVkV3JhcCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgVGV4dHVyZXMuX190ZXh0dXJlQm9kaWVzLnB1c2goIFRleHR1cmVzLl9fd3JhcCApXG4gICAgICAgICAgcHVzaGVkV3JhcCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdsc2wgPSBtb2RlID09PSAnM2QnID8gdC5nbHNsIDogdC5nbHNsMmQgXG4gICAgICAgIGlmKCBUZXh0dXJlcy5fX3RleHR1cmVCb2RpZXMuaW5kZXhPZiggZ2xzbCApID09PSAtMSApIHsgXG4gICAgICAgICAgVGV4dHVyZXMuX190ZXh0dXJlQm9kaWVzLnB1c2goIGdsc2wgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXJncyA9IHQucGFyYW1ldGVycy5tYXAoIHAgPT4gdC5fX3RhcmdldFsgcC5uYW1lIF0uZW1pdCgpICkgXG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IG1vZGUgPT09ICcyZCcgPyB0Lm5hbWUgKyAnMmQnIDogdC5uYW1lIFxuXG4gICAgICAgIC8vZGVjbCArPSBgXG4gICAgICAgIC8vICBjYXNlICR7aX06XG4gICAgICAgIC8vICAgICAgJHttb2RlID09PSAnMmQnIFxuICAgICAgICAvLyAgICAgID8gYCAgICBcbiAgICAgICAgLy8gICAgICB2ZWMzIG4gPSBub3JtYWxpemUoIHBvcyApO1xuICAgICAgICAvLyAgICAgIHZlYzQgdGV4eCA9ICB2ZWM0KCR7ZnVuY3Rpb25OYW1lfSggLjUqbi55eisuNSAkeyBhcmdzLmxlbmd0aCA+IDAgPyAnLCcgKyBhcmdzLmpvaW4oJywnKSA6ICcnfSApLCAxLik7XG4gICAgICAgIC8vICAgICAgdmVjNCB0ZXh5ID0gIHZlYzQoJHtmdW5jdGlvbk5hbWV9KCAuNSpuLnp4Ky41ICR7IGFyZ3MubGVuZ3RoID4gMCA/ICcsJyArIGFyZ3Muam9pbignLCcpIDogJyd9ICksIDEuKTtcbiAgICAgICAgLy8gICAgICB2ZWM0IHRleHogPSAgdmVjNCgke2Z1bmN0aW9uTmFtZX0oIC41Km4ueHkrLjUgJHsgYXJncy5sZW5ndGggPiAwID8gJywnICsgYXJncy5qb2luKCcsJykgOiAnJ30gKSwgMS4pO1xuICAgICAgICAvLyAgICAgIHRleCA9IHRyaXBsYW5hciggbiwgdGV4eCwgdGV4eSx0ZXh6LGZhbHNlLGZhbHNlICkueHl6O2BcbiAgICAgICAgLy8gICAgICA6IGAgXG4gICAgICAgIC8vICAgICAgdGV4ID0gJHtmdW5jdGlvbk5hbWV9KCBwb3MgJHsgYXJncy5sZW5ndGggPiAwID8gJywnICsgYXJncy5qb2luKCcsJykgOiAnJ30gKTtcbiAgICAgICAgLy8gICBgfVxuICAgICAgICAvLyAgICBicmVhaztcXG5gXG5cblxuICAgICAgICBkZWNsICs9YFxuICAgICAgICAgIGNhc2UgJHtpfTpcbiAgICAgICAgICAgICR7bW9kZSA9PT0gJzJkJyA/IGAgICAgIHBvczIgPSBnZXRVVkN1YmljKCBwb3MgKTtcXG5gIDogJyd9IFxuICAgICAgICAgICAgdGV4ID0gJHtmdW5jdGlvbk5hbWV9KCAke21vZGUgPT09ICcyZCcgPydwb3MyJzoncG9zJ30gJHsgYXJncy5sZW5ndGggPiAwID8gJywnICsgYXJncy5qb2luKCcsJykgOiAnJ30gKTtcbiAgICAgICAgICAgIGJyZWFrO1xcbmAgICAgICAgICAgICBcblxuICAgICAgfSlcblxuICAgICAgZGVjbCArPSBgXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRleCA9IHZlYzMoMC4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4O1xuICAgICAgfVxuXG4gICAgICB2ZWMzIGdldFRleHR1cmUoIGludCBpZCwgdmVjMyBwb3MsIHZlYzMgbm9yLCBTREYgc2RmLCBib29sIHVzZVRyYW5zZm9ybSApIHtcbiAgICAgICAgdmVjMyB0ZXg7XG4gICAgICAgIHZlYzIgcG9zMjtcbiAgICAgICAgdmVjMyB0cG9zID0gcG9zO1xuICAgICAgICBpZiggdXNlVHJhbnNmb3JtID09IHRydWUgKSB7XG4gICAgICAgICAgaWYoIGxlbmd0aChzZGYucmVwZWF0KSAhPSAwLiApIHtcbiAgICAgICAgICAgIHRwb3MgPSBtb2QoICh2ZWM0KHBvcywxLikgKiBzZGYucmVwZWF0VHJhbnNmb3JtKS54eXosIHNkZi5yZXBlYXQpIC0gLjUgKiBzZGYucmVwZWF0O1xuICAgICAgICAgICAgdHBvcyA9ICggdmVjNCh0cG9zLCAxLikgKiBzZGYudHJhbnNmb3JtKS54eXo7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0cG9zID0gKHZlYzQodHBvcywxLikgKiBzZGYudHJhbnNmb3JtKS54eXo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFRleHR1cmUoIGlkLCB0cG9zICk7XG4gICAgICB9XG4gICAgICBgXG4gICAgIFxuICAgICAgcmV0dXJuIHsgZ2xzbGRlZnM6IFRleHR1cmVzLl9fdGV4dHVyZUJvZGllcy5qb2luKCAnXFxuJyApLCBtYWluZnVuYzpkZWNsIH1cbiAgICB9LFxuXG4gICAgY2xlYXIoKSB7XG4gICAgICBUZXh0dXJlcy50ZXh0dXJlcy5sZW5ndGggPSAwXG4gICAgfSxcblxuICAgIGFkZFRleHR1cmUoIHRleCApIHtcbiAgICAgIC8vIHdlIGhhdmUgdG8gZGlydHkgdGhlIHRleHR1cmUgc28gdGhhdCBpdHMgZGF0YVxuICAgICAgLy8gd2lsbCBiZSB1cGxvYWRlZCB0byBuZXcgc2hhZGVycywgb3RoZXJ3aXNlIHRoZVxuICAgICAgLy8gdGV4dHVyZSB3aWxsIG9ubHkgd29yayB0aGUgZmlyc3QgdGltZSBpdCdzIHVzZWQsIHdoZW5cbiAgICAgIC8vIGl0J3MgZGlydHkgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICBUZXh0dXJlcy5kaXJ0eSggdGV4IClcblxuICAgICAgLy8gaWYgdGV4dHVyZSB3aXRoIHNhbWUgbmFtZSBpcyBhbHJlYWR5IGZvdW5kLCByZXBsYWNlIGl0LFxuICAgICAgLy8gb3RoZXJ3aXNlIHB1c2ggdGV4dHVyZVxuICAgICAgLy9jb25zdCBvbGRUZXggPSBUZXh0dXJlcy50ZXh0dXJlcy5maW5kKCBfX3RleCA9PiB0ZXgubmFtZSA9PT0gX190ZXgubmFtZSApXG4gICAgICAvL2lmKCBvbGRUZXggIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIC8vICBjb25zdCBpZHggPSBUZXh0dXJlcy50ZXh0dXJlcy5pbmRleE9mKCBvbGRUZXggKVxuICAgICAgLy8gIFRleHR1cmVzLnRleHR1cmVzLnNwbGljZSggaWR4LCAxLCB0ZXggKVxuXG4gICAgICAvLyAgdGV4LmlkID0gaWR4IFxuICAgICAgLy99ZWxzZXtcbiAgICAgICAgdGV4LmlkID0gVGV4dHVyZXMudGV4dHVyZXMubGVuZ3RoXG4gICAgICAgIFRleHR1cmVzLnRleHR1cmVzLnB1c2goIHRleCApXG4gICAgICAvL31cblxuICAgICAgcmV0dXJuIHRleFxuICAgIH0sXG5cbiAgICB0ZXh0dXJlKCBwcmVzZXROYW1lPSdub2lzZScsIHByb3BzPXt9LCB0YXJnZXQ9bnVsbCApe1xuICAgICAgLy9jb25zdCBpc1ByZXNldCA9IGZpbGVuYW1lT3JQcmVzZXQuaW5kZXhPZiggJy4nICkgPT09IC0xXG4gICAgICAvL2NvbnN0IGRlZmF1bHRzID0geyB3cmFwOlNERi5nbC5NSVJST1JFRF9SRVBFQVQgfVxuXG4gICAgICBpZiggVGV4dHVyZXMuX190eXBlc1sgcHJlc2V0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCBgdGhlIHRleHR1cmUgdHlwZSAnJHtwcmVzZXROYW1lfScgZG9lcyBub3QgZXhpc3QuYCApXG4gICAgICB9XG4gICAgICBjb25zdCB0ZXggPSBPYmplY3QuYXNzaWduKCB7IG1vZGU6JzNkJyB9LCBUZXh0dXJlcy5fX3R5cGVzWyBwcmVzZXROYW1lIF0sIHByb3BzIClcblxuICAgICAgaWYoIHRhcmdldCA9PT0gbnVsbCApIHRhcmdldCA9IHRleFxuICAgICAgdGV4Ll9fdGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRleC5wYXJhbWV0ZXJzICkge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0gcGFyYW0uZGVmYXVsdFxuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSggZGVmYXVsdFZhbHVlcyApXG5cbiAgICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgICBpZiggaXNBcnJheSApIHtcbiAgICAgICAgICBsZXQgdmFsID0gcHJvcHNbIHBhcmFtLm5hbWUgXSwgX192YXJcblxuICAgICAgICAgIGlmKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgIF9fdmFyID0gVmFyKCB2YXJzWyBwYXJhbS50eXBlIF0oIHZhbCApLCBudWxsLCAndmVjMycgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc3QgaW5pdHZhbHVlcyA9IHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgX192YXIgPSBWYXIoIHZhcnNbIHBhcmFtLnR5cGUgXSggLi4uaW5pdHZhbHVlcyApLCBudWxsLCBwYXJhbS50eXBlIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmb3IgYXNzaWduaW5nIGVudGlyZSBuZXcgdmVjdG9ycyB0byBwcm9wZXJ0eVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGFyZ2V0LCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS56ID0gdlxuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLncgPSB2XG4gICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGxldCBfX3ZhciAgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgIHByb3BzWyBwYXJhbS5uYW1lIF0sIFxuICAgICAgICAgICAgZ2Vuc1sgcGFyYW0udHlwZSBdKCBkZWZhdWx0VmFsdWVzICkgXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLy9fX3Zhci5zZXQoIGRlZmF1bHRWYWx1ZXMgKVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGFyZ2V0LCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICBfX3Zhci5zZXQoIHYgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHByZXNldE5hbWUgPT09ICdpbWFnZScgKSB7XG4gICAgICAgIGlmKCBwcm9wcy5maWxlbmFtZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHRleC5pbWFnZSA9IGdldFBpeGVscyggcHJvcHMuZmlsZW5hbWUsIChlcnIscGl4ZWxzKSA9PiB7XG4gICAgICAgICAgICBpZiggZXJyICE9PSBudWxsICkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBlcnIgKVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleC5waXhlbHMgPSBwaXhlbHNcbiAgICAgICAgICAgIHRleC5nbHRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKCBTREYuZ2wsIHBpeGVscyApXG4gICAgICAgICAgICB0ZXguZ2x0ZXh0dXJlLndyYXAgPSBwcm9wcy53cmFwID09PSB1bmRlZmluZWQgPyBNYXJjaGluZy5nbC5SRVBFQVQgOiBwcm9wcy53cmFwXG4gICAgICAgICAgfSlcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGV4LmltYWdlID0gbnVsbFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSBmaWxlbmFtZSB3aGVuIHVzaW5nIHRoZSBpYW1nZSBwcmVzZXQuJylcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYoIHByZXNldE5hbWUgPT09ICdjYW52YXMnICkge1xuICAgICAgICBpZiggcHJvcHMuY2FudmFzID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgdGV4LmNhbnZhcyA9IHRleC5pbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgdGV4LmN0eCAgICA9IHRleC5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0ZXguaW1hZ2UgPSBwcm9wcy5jYW52YXNcbiAgICAgICAgfVxuXG4gICAgICAgIHRleC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0ZXguZ2x0ZXh0dXJlLnNldFBpeGVscyggdGV4LmltYWdlIClcbiAgICAgICAgfVxuXG4gICAgICAgIHRleC5nbHRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKCBTREYuZ2wsIHRleC5pbWFnZSApXG4gICAgICAgIHRleC5nbHRleHR1cmUud3JhcCA9IHByb3BzLndyYXAgPT09IHVuZGVmaW5lZCA/IE1hcmNoaW5nLmdsLlJFUEVBVCA6IHByb3BzLndyYXBcblxuICAgICAgICB0ZXgudXBkYXRlKClcbiAgICAgIH1cblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRleCwgJ3dyYXAnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuZ2x0ZXh0dXJlLndyYXAgfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLmdsdGV4dHVyZS53cmFwID0gdiB9XG4gICAgICB9KVxuXG4gICAgICB0ZXgubmFtZSA9IHByZXNldE5hbWVcblxuICAgICAgcmV0dXJuIHRleCBcbiAgICB9LFxuXG4gICAgZGlydHkoIHRleCApIHt9LFxuICAgXG4gICAgZW1pdF9kZWNsKCkge1xuICAgICAgaWYoIHRoaXMudGV4dHVyZXMubGVuZ3RoID09PSAwICkgcmV0dXJuICcnIFxuXG4gICAgICBsZXQgZGVjbCA9ICcnXG5cbiAgICAgIGNvbnN0IG1lbW8gPSBbXVxuICAgICAgbGV0IGltYWdlQ291bnQgPSAwO1xuICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCAodGV4LGkpID0+IHtcbiAgICAgICAgaWYoIG1lbW8uaW5kZXhPZiggdGV4ICkgPT09IC0xICkge1xuICAgICAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRleC5wYXJhbWV0ZXJzICkge1xuICAgICAgICAgICAgaWYoIHBhcmFtLm5hbWUgIT09ICdtYXRlcmlhbCcgKVxuICAgICAgICAgICAgICBkZWNsICs9IHRleC5fX3RhcmdldFsgcGFyYW0ubmFtZSBdLmVtaXRfZGVjbCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbW8ucHVzaCggdGV4IClcbiAgICAgICAgfVxuICAgICAgICBpZiggdGV4Lm5hbWUgPT09ICdpbWFnZScgfHwgdGV4Lm5hbWUgPT09ICdjYW52YXMnICkge1xuICAgICAgICAgIGltYWdlQ291bnQrK1xuXG4gICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGNhbid0IGltbWVkaWF0ZWx5IGNhbGwgdXBkYXRlLi4uIFxuICAgICAgICAgIC8vIGhhdmUgdG8gd2FpdCBmb3Igc29tZSB0eXBlIG9mIGRvbSBpbml0aWFsaXphdGlvbj9cbiAgICAgICAgICAvLyBzbyBjYWxsIGhlcmVcbiAgICAgICAgICBpZiggdGV4LnVwZGF0ZSApIHRleC51cGRhdGUoKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiggaW1hZ2VDb3VudCA+IDAgKSB7XG4gICAgICAgIGRlY2wgKz0gYFxcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVzWyR7aW1hZ2VDb3VudH1dO1xcbmBcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNsXG4gICAgfSxcbiAgICBcbiAgICB1cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgaWYoIHRoaXMudGV4dHVyZXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCAodGV4LGkpID0+IHtcbiAgICAgICAgICBmb3IoIGxldCBwYXJhbSBvZiB0ZXgucGFyYW1ldGVycyApIHtcbiAgICAgICAgICAgIGlmKCBwYXJhbS50eXBlICE9PSAnb2JqJyApIHtcbiAgICAgICAgICAgICAgaWYoIHBhcmFtLm5hbWUgIT09ICdtYXRlcmlhbCcgKSBcbiAgICAgICAgICAgICAgICB0ZXguX190YXJnZXRbIHBhcmFtLm5hbWUgXS51cGRhdGVfbG9jYXRpb24oIGdsLHByb2dyYW0gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiggdGV4Lm5hbWUgPT09ICdpbWFnZScgfHwgdGV4Lm5hbWUgPT09ICdjYW52YXMnICkge1xuICAgICAgICAgICAgdGV4LmxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgYHRleHR1cmVzWyR7dGV4LmlkfV1gIClcbiAgICAgICAgICAgIHRleC5nbHRleHR1cmUuYmluZCggaSApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvL2lmKCB0aGlzLnRleHR1cmVzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAvLyAgdGhpcy50ZXh0dXJlcy5zb3J0KCAoYSxiKSA9PiBhLmlkID4gYi5pZCA/IDEgOiAtMSApIFxuXG4gICAgICAvLyAgZm9yKCBsZXQgdGV4IG9mIHRoaXMudGV4dHVyZXMgKSB7XG4gICAgICAvLyAgICB0ZXgubG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBgdGV4dHVyZXNbJHt0ZXguaWR9XWAgKVxuICAgICAgLy8gICAgdGV4LmdsdGV4dHVyZS5iaW5kKCB0ZXguaWQgKVxuICAgICAgLy8gIH1cblxuICAgICAgLy8gIHRoaXMuX190ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXMuc2xpY2UoIDAgKVxuICAgICAgLy8gIHRoaXMudGV4dHVyZXMubGVuZ3RoID0gMFxuICAgICAgLy99XG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApIHtcbiAgICAgIGlmKCB0aGlzLnRleHR1cmVzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCggKHRleCxpKSA9PiB7XG4gICAgICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgdGV4LnBhcmFtZXRlcnMgKSB7XG4gICAgICAgICAgICBpZiggcGFyYW0udHlwZSAhPT0gJ29iaicgJiYgcGFyYW0ubmFtZSAhPT0gJ21hdGVyaWFsJyApXG4gICAgICAgICAgICAgIHRleC5fX3RhcmdldFsgcGFyYW0ubmFtZSBdLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCB0ZXgubmFtZSA9PT0gJ2ltYWdlJyB8fCB0ZXgubmFtZSA9PT0gJ2NhbnZhcycgKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoIHRleC5sb2MsIGkgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIFRleHR1cmVzLnRleHR1cmUuY3JlYXRlID0gZnVuY3Rpb24oIHByb3BzICkge1xuICAgIFRleHR1cmVzLl9fdHlwZXNbIHByb3BzLm5hbWUgXSA9IHByb3BzXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVGV4dHVyZXMudGV4dHVyZSwge1xuICAgICdyZXBlYXQnOiB7IGdldCgpIHsgcmV0dXJuIE1hcmNoaW5nLmdsLlJFUEVBVCB9IH0sXG4gICAgJ21pcnJvcic6IHsgZ2V0KCkgeyByZXR1cm4gTWFyY2hpbmcuZ2wuTUlSUk9SRURfUkVQRUFUIH0gfSxcbiAgICAnY2xhbXAnOiB7IGdldCgpIHsgcmV0dXJuIE1hcmNoaW5nLmdsLkNMQU1QX1RPX0VER0UgfSB9LFxuICB9KVxuXG4gIGNvbnN0IGYgPSB2YWx1ZSA9PiB2YWx1ZSAlIDEgPT09IDAgPyB2YWx1ZS50b0ZpeGVkKDEpIDogdmFsdWUgXG5cbiAgcmV0dXJuIFRleHR1cmVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gX19UZXh0dXJlc1xuIiwiY29uc3QgZ2xzbCA9IHJlcXVpcmUoICdnbHNsaWZ5JyApXG5cbmNvbnN0IHRleHR1cmVzID0ge1xuICBpbWFnZToge1xuICAgIG5hbWU6J2ltYWdlJyxcbiAgICBnbHNsMmQ6YFxuICAgICAgdmVjMyBpbWFnZTJkKCB2ZWMyIHV2LCBmbG9hdCBzY2FsZSwgZmxvYXQgc3RyZW5ndGggKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlKCB0ZXh0dXJlc1sgMCBdLCB1dipzY2FsZSApLnh5eiAqIHN0cmVuZ3RoO1xuICAgICAgfVxuICAgIGAsXG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonc3RyZW5ndGgnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LCAgIFxuICAgIF1cbiAgfSxcbiAgY2FudmFzOiB7XG4gICAgbmFtZTonY2FudmFzJyxcbiAgICBnbHNsMmQ6YFxuICAgICAgdmVjMyBjYW52YXMyZCggdmVjMiB1diwgZmxvYXQgc2NhbGUsIGZsb2F0IHN0cmVuZ3RoICkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZSggdGV4dHVyZXNbIDAgXSwgdXYqc2NhbGUgKS54eXogKiBzdHJlbmd0aDtcbiAgICAgIH1cbiAgICBgLFxuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J3N0cmVuZ3RoJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSwgICBcbiAgICBdXG4gIH0sXG4gIHJhaW5ib3c6IHtcbiAgICBuYW1lOidyYWluYm93JyxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3N0cmVuZ3RoJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonc2hpZnQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MCB9LFxuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgXSxcbiAgICBnbHNsOmAgXG4gICAgdmVjMyByYWluYm93KCB2ZWMzIHBvcywgZmxvYXQgc3RyZW5ndGgsIGZsb2F0IHNoaWZ0LCBmbG9hdCBzY2FsZSApIHtcbiAgICAgIHBvcyA9IHBvcyAqIHNjYWxlO1xuICAgICAgdmVjMyBhID0gdmVjMygwLjUsMC41LDAuNSksIGIgPSB2ZWMzKDAuNSwwLjUsMC41KSwgYyA9IHZlYzMoMS4wLDEuMCwxLjApLGQgPSB2ZWMzKDAuMCwwLjMzLDAuNjcpO1xuICAgICAgcmV0dXJuIGEgKyBiICogY29zKCA2LjI4MzgxOCAqICggYyAqIG1vZChsZW5ndGgocG9zKSArIHNoaWZ0LCAxLiApICsgZCApICkgKiBzdHJlbmd0aDtcbiAgICB9YCBcbiAgfSxcbiAgY2hlY2tlcnM6IHtcbiAgICBuYW1lOidjaGVja2VycycsXG4gICAgZ2xzbDpgICAgICAgICAgIFxuICAgICAgICB2ZWMzIGNoZWNrZXJzKCB2ZWMzIHBvcywgZmxvYXQgc2l6ZSwgdmVjMyBjb2xvcjEsIHZlYzMgY29sb3IyICkge1xuICAgICAgICAgIHZlYzMgdGV4O1xuICAgICAgICAgIHBvcyAgPSBwb3MgKiBzaXplO1xuICAgICAgICAgIGlmICgoaW50KGZsb29yKHBvcy54KSArIGZsb29yKHBvcy55KSArIGZsb29yKHBvcy56KSkgJiAxKSA9PSAwKSB7XG4gICAgICAgICAgICB0ZXggPSBjb2xvcjE7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0ZXggPSBjb2xvcjI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRleDtcbiAgICAgICAgfWAsXG4gICAgZ2xzbDJkOmBcbiAgICAgICAgdmVjMyBjaGVja2VyczJkKCB2ZWMyIHV2LCBmbG9hdCBzaXplLCB2ZWMzIGNvbG9yMSwgdmVjMyBjb2xvcjIgKSB7XG4gICAgICAgICAgZmxvYXQgZm1vZFJlc3VsdCA9IG1vZChmbG9vcihzaXplICogdXYueCkgKyBmbG9vcihzaXplICogdXYueSksIDIuMCk7XG4gICAgICAgICAgZmxvYXQgZmluID0gbWF4KHNpZ24oZm1vZFJlc3VsdCksIDAuMCk7IFxuXG4gICAgICAgICAgcmV0dXJuIHZlYzMoZmluKTtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsICB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6NSB9LFxuICAgICAgeyBuYW1lOidjb2xvcjEnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMSwxLDFdIH0sXG4gICAgICB7IG5hbWU6J2NvbG9yMicsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlswLDAsMF0gfVxuICAgIF0sXG4gIH0sXG4gIG5vaXNlOiB7XG4gICAgbmFtZTonbm9pc2UnLFxuICAgIGdsc2w6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAgICAgICBcXG4gICAgICAgIC8vXFxuLy8gRGVzY3JpcHRpb24gOiBBcnJheSBhbmQgdGV4dHVyZWxlc3MgR0xTTCAyRC8zRC80RCBzaW1wbGV4XFxuLy8gICAgICAgICAgICAgICBub2lzZSBmdW5jdGlvbnMuXFxuLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cXG4vLyAgTWFpbnRhaW5lciA6IGlqbVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzQgbW9kMjg5KHZlYzQgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDsgfVxcblxcbmZsb2F0IG1vZDI4OShmbG9hdCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wOyB9XFxuXFxudmVjNCBwZXJtdXRlKHZlYzQgeCkge1xcbiAgICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxuZmxvYXQgcGVybXV0ZShmbG9hdCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbmZsb2F0IHRheWxvckludlNxcnQoZmxvYXQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG52ZWM0IGdyYWQ0KGZsb2F0IGosIHZlYzQgaXApXFxuICB7XFxuICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIC0xLjApO1xcbiAgdmVjNCBwLHM7XFxuXFxuICBwLnh5eiA9IGZsb29yKCBmcmFjdCAodmVjMyhqKSAqIGlwLnh5eikgKiA3LjApICogaXAueiAtIDEuMDtcXG4gIHAudyA9IDEuNSAtIGRvdChhYnMocC54eXopLCBvbmVzLnh5eik7XFxuICBzID0gdmVjNChsZXNzVGhhbihwLCB2ZWM0KDAuMCkpKTtcXG4gIHAueHl6ID0gcC54eXogKyAocy54eXoqMi4wIC0gMS4wKSAqIHMud3d3O1xcblxcbiAgcmV0dXJuIHA7XFxuICB9XFxuXFxuLy8gKHNxcnQoNSkgLSAxKS80ID0gRjQsIHVzZWQgb25jZSBiZWxvd1xcbiNkZWZpbmUgRjQgMC4zMDkwMTY5OTQzNzQ5NDc0NTFcXG5cXG5mbG9hdCBzbm9pc2UodmVjNCB2KVxcbiAge1xcbiAgY29uc3QgdmVjNCAgQyA9IHZlYzQoIDAuMTM4MTk2NjAxMTI1MDExLCAgLy8gKDUgLSBzcXJ0KDUpKS8yMCAgRzRcXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjI3NjM5MzIwMjI1MDAyMSwgIC8vIDIgKiBHNFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNDE0NTg5ODAzMzc1MDMyLCAgLy8gMyAqIEc0XFxuICAgICAgICAgICAgICAgICAgICAgICAtMC40NDcyMTM1OTU0OTk5NTgpOyAvLyAtMSArIDQgKiBHNFxcblxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjNCBpICA9IGZsb29yKHYgKyBkb3QodiwgdmVjNChGNCkpICk7XFxuICB2ZWM0IHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4eHgpO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG5cXG4vLyBSYW5rIHNvcnRpbmcgb3JpZ2luYWxseSBjb250cmlidXRlZCBieSBCaWxsIExpY2VhLUthbmUsIEFNRCAoZm9ybWVybHkgQVRJKVxcbiAgdmVjNCBpMDtcXG4gIHZlYzMgaXNYID0gc3RlcCggeDAueXp3LCB4MC54eHggKTtcXG4gIHZlYzMgaXNZWiA9IHN0ZXAoIHgwLnp3dywgeDAueXl6ICk7XFxuLy8gIGkwLnggPSBkb3QoIGlzWCwgdmVjMyggMS4wICkgKTtcXG4gIGkwLnggPSBpc1gueCArIGlzWC55ICsgaXNYLno7XFxuICBpMC55encgPSAxLjAgLSBpc1g7XFxuLy8gIGkwLnkgKz0gZG90KCBpc1laLnh5LCB2ZWMyKCAxLjAgKSApO1xcbiAgaTAueSArPSBpc1laLnggKyBpc1laLnk7XFxuICBpMC56dyArPSAxLjAgLSBpc1laLnh5O1xcbiAgaTAueiArPSBpc1laLno7XFxuICBpMC53ICs9IDEuMCAtIGlzWVouejtcXG5cXG4gIC8vIGkwIG5vdyBjb250YWlucyB0aGUgdW5pcXVlIHZhbHVlcyAwLDEsMiwzIGluIGVhY2ggY2hhbm5lbFxcbiAgdmVjNCBpMyA9IGNsYW1wKCBpMCwgMC4wLCAxLjAgKTtcXG4gIHZlYzQgaTIgPSBjbGFtcCggaTAtMS4wLCAwLjAsIDEuMCApO1xcbiAgdmVjNCBpMSA9IGNsYW1wKCBpMC0yLjAsIDAuMCwgMS4wICk7XFxuXFxuICAvLyAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4eFxcbiAgLy8gIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eHhcXG4gIC8vICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHh4XFxuICAvLyAgeDMgPSB4MCAtIGkzICArIDMuMCAqIEMueHh4eFxcbiAgLy8gIHg0ID0geDAgLSAxLjAgKyA0LjAgKiBDLnh4eHhcXG4gIHZlYzQgeDEgPSB4MCAtIGkxICsgQy54eHh4O1xcbiAgdmVjNCB4MiA9IHgwIC0gaTIgKyBDLnl5eXk7XFxuICB2ZWM0IHgzID0geDAgLSBpMyArIEMuenp6ejtcXG4gIHZlYzQgeDQgPSB4MCArIEMud3d3dztcXG5cXG4vLyBQZXJtdXRhdGlvbnNcXG4gIGkgPSBtb2QyODkoaSk7XFxuICBmbG9hdCBqMCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoaS53KSArIGkueikgKyBpLnkpICsgaS54KTtcXG4gIHZlYzQgajEgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlIChcXG4gICAgICAgICAgICAgaS53ICsgdmVjNChpMS53LCBpMi53LCBpMy53LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS56ICsgdmVjNChpMS56LCBpMi56LCBpMy56LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS55ICsgdmVjNChpMS55LCBpMi55LCBpMy55LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS54ICsgdmVjNChpMS54LCBpMi54LCBpMy54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDd4NiBwb2ludHMgb3ZlciBhIGN1YmUsIG1hcHBlZCBvbnRvIGEgNC1jcm9zcyBwb2x5dG9wZVxcbi8vIDcqNyo2ID0gMjk0LCB3aGljaCBpcyBjbG9zZSB0byB0aGUgcmluZyBzaXplIDE3KjE3ID0gMjg5LlxcbiAgdmVjNCBpcCA9IHZlYzQoMS4wLzI5NC4wLCAxLjAvNDkuMCwgMS4wLzcuMCwgMC4wKSA7XFxuXFxuICB2ZWM0IHAwID0gZ3JhZDQoajAsICAgaXApO1xcbiAgdmVjNCBwMSA9IGdyYWQ0KGoxLngsIGlwKTtcXG4gIHZlYzQgcDIgPSBncmFkNChqMS55LCBpcCk7XFxuICB2ZWM0IHAzID0gZ3JhZDQoajEueiwgaXApO1xcbiAgdmVjNCBwNCA9IGdyYWQ0KGoxLncsIGlwKTtcXG5cXG4vLyBOb3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG4gIHA0ICo9IHRheWxvckludlNxcnQoZG90KHA0LHA0KSk7XFxuXFxuLy8gTWl4IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXFxuICB2ZWMzIG0wID0gbWF4KDAuNiAtIHZlYzMoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSksIDAuMCk7XFxuICB2ZWMyIG0xID0gbWF4KDAuNiAtIHZlYzIoZG90KHgzLHgzKSwgZG90KHg0LHg0KSAgICAgICAgICAgICksIDAuMCk7XFxuICBtMCA9IG0wICogbTA7XFxuICBtMSA9IG0xICogbTE7XFxuICByZXR1cm4gNDkuMCAqICggZG90KG0wKm0wLCB2ZWMzKCBkb3QoIHAwLCB4MCApLCBkb3QoIHAxLCB4MSApLCBkb3QoIHAyLCB4MiApKSlcXG4gICAgICAgICAgICAgICArIGRvdChtMSptMSwgdmVjMiggZG90KCBwMywgeDMgKSwgZG90KCBwNCwgeDQgKSApICkgKSA7XFxuXFxuICB9XFxuXFxuICAgICAgICB2ZWMzIG5vaXNlKCB2ZWMzIHBvcywgZmxvYXQgc2NhbGUsIGZsb2F0IHN0cmVuZ3RoLCBmbG9hdCB0aW1lICkge1xcbiAgICAgICAgICBmbG9hdCBuID0gc25vaXNlKCB2ZWM0KHBvcypzY2FsZSwgdGltZSkgKTtcXG4gICAgICAgICAgcmV0dXJuIHZlYzMoIG4gKSAqIHN0cmVuZ3RoO1xcbiAgICAgICAgfVwiLFwiXCJdKSxcbiAgICBnbHNsMmQ6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBcXG4gICAgICAgIC8vXFxuLy8gRGVzY3JpcHRpb24gOiBBcnJheSBhbmQgdGV4dHVyZWxlc3MgR0xTTCAyRC8zRC80RCBzaW1wbGV4XFxuLy8gICAgICAgICAgICAgICBub2lzZSBmdW5jdGlvbnMuXFxuLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cXG4vLyAgTWFpbnRhaW5lciA6IGlqbVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzMgbW9kMjg5KHZlYzMgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxuXFxudmVjNCBtb2QyODkodmVjNCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IHBlcm11dGUodmVjNCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbmZsb2F0IHNub2lzZSh2ZWMzIHYpXFxuICB7XFxuICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XFxuICBjb25zdCB2ZWM0ICBEID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAyLjApO1xcblxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjMyBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eXkpICk7XFxuICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG4gIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xcbiAgdmVjMyBsID0gMS4wIC0gZztcXG4gIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xcbiAgdmVjMyBpMiA9IG1heCggZy54eXosIGwuenh5ICk7XFxuXFxuICAvLyAgIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eDtcXG4gIC8vICAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4O1xcbiAgLy8gICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHg7XFxuICAvLyAgIHgzID0geDAgLSAxLjAgKyAzLjAgKiBDLnh4eDtcXG4gIHZlYzMgeDEgPSB4MCAtIGkxICsgQy54eHg7XFxuICB2ZWMzIHgyID0geDAgLSBpMiArIEMueXl5OyAvLyAyLjAqQy54ID0gMS8zID0gQy55XFxuICB2ZWMzIHgzID0geDAgLSBELnl5eTsgICAgICAvLyAtMS4wKzMuMCpDLnggPSAtMC41ID0gLUQueVxcblxcbi8vIFBlcm11dGF0aW9uc1xcbiAgaSA9IG1vZDI4OShpKTtcXG4gIHZlYzQgcCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoXFxuICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnggKyB2ZWM0KDAuMCwgaTEueCwgaTIueCwgMS4wICkpO1xcblxcbi8vIEdyYWRpZW50czogN3g3IHBvaW50cyBvdmVyIGEgc3F1YXJlLCBtYXBwZWQgb250byBhbiBvY3RhaGVkcm9uLlxcbi8vIFRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZSBvZiA0OSAoNDkqNiA9IDI5NClcXG4gIGZsb2F0IG5fID0gMC4xNDI4NTcxNDI4NTc7IC8vIDEuMC83LjBcXG4gIHZlYzMgIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xcblxcbiAgdmVjNCBqID0gcCAtIDQ5LjAgKiBmbG9vcihwICogbnMueiAqIG5zLnopOyAgLy8gIG1vZChwLDcqNylcXG5cXG4gIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XFxuICB2ZWM0IHlfID0gZmxvb3IoaiAtIDcuMCAqIHhfICk7ICAgIC8vIG1vZChqLE4pXFxuXFxuICB2ZWM0IHggPSB4XyAqbnMueCArIG5zLnl5eXk7XFxuICB2ZWM0IHkgPSB5XyAqbnMueCArIG5zLnl5eXk7XFxuICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XFxuXFxuICB2ZWM0IGIwID0gdmVjNCggeC54eSwgeS54eSApO1xcbiAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcXG5cXG4gIC8vdmVjNCBzMCA9IHZlYzQobGVzc1RoYW4oYjAsMC4wKSkqMi4wIC0gMS4wO1xcbiAgLy92ZWM0IHMxID0gdmVjNChsZXNzVGhhbihiMSwwLjApKSoyLjAgLSAxLjA7XFxuICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcXG4gIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xcbiAgdmVjNCBzaCA9IC1zdGVwKGgsIHZlYzQoMC4wKSk7XFxuXFxuICB2ZWM0IGEwID0gYjAueHp5dyArIHMwLnh6eXcqc2gueHh5eSA7XFxuICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XFxuXFxuICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xcbiAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcXG4gIHZlYzMgcDIgPSB2ZWMzKGExLnh5LGgueik7XFxuICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xcblxcbi8vTm9ybWFsaXNlIGdyYWRpZW50c1xcbiAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XFxuICBwMCAqPSBub3JtLng7XFxuICBwMSAqPSBub3JtLnk7XFxuICBwMiAqPSBub3JtLno7XFxuICBwMyAqPSBub3JtLnc7XFxuXFxuLy8gTWl4IGZpbmFsIG5vaXNlIHZhbHVlXFxuICB2ZWM0IG0gPSBtYXgoMC42IC0gdmVjNChkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpLCBkb3QoeDMseDMpKSwgMC4wKTtcXG4gIG0gPSBtICogbTtcXG4gIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QocDIseDIpLCBkb3QocDMseDMpICkgKTtcXG4gIH1cXG5cXG4gICAgICAgIHZlYzMgbm9pc2UyZCggdmVjMiBzdCwgZmxvYXQgc2NhbGUsIGZsb2F0IHN0cmVuZ3RoLCBmbG9hdCB0aW1lICkge1xcbiAgICAgICAgICBmbG9hdCBjb2wgPSBzbm9pc2UoIHZlYzMoIHN0LCB0aW1lICkgKiBzY2FsZSApO1xcblxcbiAgICAgICAgICByZXR1cm4gdmVjMyhjb2wpICogc3RyZW5ndGg7XFxuICAgICAgICB9XFxuXCIsXCJcIl0pICxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjIgfSxcbiAgICAgIHsgbmFtZTonc3RyZW5ndGgnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6LjEgfSxcbiAgICAgIHsgbmFtZTondGltZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH1cbiAgICBdLFxuICB9LFxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly90aGVib29rb2ZzaGFkZXJzLmNvbS8xMC9cbiAgdHJ1Y2hldDoge1xuICAgIG5hbWU6J3RydWNoZXQnLFxuICAgIGdsc2wyZDpgICAgIFxuICAgICAgICBmbG9hdCByYW5kb21fdHJ1Y2hldChpbiB2ZWMyIF9zdCkge1xuICAgICAgICAgIHJldHVybiBmcmFjdChzaW4oZG90KF9zdC54eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKDEyLjk4OTgsNzguMjMzKSkpKlxuICAgICAgICAgICAgICAgICAgICAgICAgNDM3NTguNTQ1MzEyMyk7XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyIHRydWNoZXRQYXR0ZXJuKGluIHZlYzIgX3N0LCBpbiBmbG9hdCBfaW5kZXgpe1xuICAgICAgICAgICAgX2luZGV4ID0gZnJhY3QoKChfaW5kZXgtMC41KSoyLjApKTtcbiAgICAgICAgICAgIGlmIChfaW5kZXggPiAwLjc1KSB7XG4gICAgICAgICAgICAgICAgX3N0ID0gdmVjMigxLjApIC0gX3N0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5kZXggPiAwLjUpIHtcbiAgICAgICAgICAgICAgICBfc3QgPSB2ZWMyKDEuMC1fc3QueCxfc3QueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9pbmRleCA+IDAuMjUpIHtcbiAgICAgICAgICAgICAgICBfc3QgPSAxLjAtdmVjMigxLjAtX3N0LngsX3N0LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzMgdHJ1Y2hldDJkKCB2ZWMyIHN0LCBmbG9hdCBzY2FsZSwgdmVjMyBjb2xvciApIHtcbiAgICAgICAgICAgIHN0ID0gc3QgKiBzY2FsZTtcbiAgICAgICAgICAgIHZlYzIgaXBvcyA9IGZsb29yKHN0KTsgIC8vIGludGVnZXJcbiAgICAgICAgICAgIHZlYzIgZnBvcyA9IGZyYWN0KHN0KTsgIC8vIGZyYWN0aW9uXG5cbiAgICAgICAgICAgIHZlYzIgdGlsZSA9IHRydWNoZXRQYXR0ZXJuKGZwb3MsIHJhbmRvbV90cnVjaGV0KCBpcG9zICkpO1xuXG4gICAgICAgICAgICBmbG9hdCBjb2wgPSBzbW9vdGhzdGVwKHRpbGUueC0wLjMsdGlsZS54LHRpbGUueSktc21vb3Roc3RlcCh0aWxlLngsdGlsZS54Ky4zLHRpbGUueSk7XG4gICAgICAgICAgICByZXR1cm4gY29sb3IgKiBjb2w7XG4gICAgICAgIH1cblxuYCAsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxMCB9LFxuICAgICAgeyBuYW1lOidjb2xvcicsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsxLDEsMV0gfVxuICAgIF0sXG4gIH0sXG4gIGRvdHM6IHtcbiAgICBuYW1lOidkb3RzJyxcbiAgICBnbHNsOmAgICAgICAgICAgXG4gICAgICAgIHZlYzMgZG90cyggdmVjMyBwb3MsIGZsb2F0IGNvdW50LCBmbG9hdCByYWRpdXMsIHZlYzMgY29sb3IgKSB7XG4gICAgICAgICAgdmVjMyB0ZXg7XG4gICAgICAgICAgdGV4ID0gdmVjMyggY29sb3IgLSBzbW9vdGhzdGVwKCByYWRpdXMsIHJhZGl1cysuMDIsIGxlbmd0aChmcmFjdChwb3MqKHJvdW5kKGNvdW50LzIuKSsuNSkpIC0uNSApKSApO1xuICAgICAgICAgIHJldHVybiB0ZXg7XG4gICAgICAgIH1gICxcbiAgICBnbHNsMmQ6YFxuICAgICAgdmVjMiB0aWxlKHZlYzIgX3N0LCBmbG9hdCBfem9vbSl7XG4gICAgICAgIF9zdCAqPSBfem9vbTtcbiAgICAgICAgcmV0dXJuIGZyYWN0KF9zdCk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IGNpcmNsZSh2ZWMyIF9zdCwgZmxvYXQgX3JhZGl1cyl7XG4gICAgICAgIHZlYzIgcG9zID0gdmVjMigwLjUpLV9zdDtcbiAgICAgICAgX3JhZGl1cyAqPSAwLjc1O1xuICAgICAgICByZXR1cm4gMS4tc21vb3Roc3RlcChfcmFkaXVzLShfcmFkaXVzKjAuMDUpLF9yYWRpdXMrKF9yYWRpdXMqMC4wNSksZG90KHBvcyxwb3MpKjMuMTQpO1xuICAgICAgfVxuICAgIFxuICAgICAgdmVjMyBkb3RzMmQoIHZlYzIgX3N0LCBmbG9hdCBzY2FsZSwgZmxvYXQgcmFkaXVzLCB2ZWMzIGNvbG9yICkge1xuICAgICAgICB2ZWMyIHN0ID0gdGlsZShfc3Qsc2NhbGUpO1xuICAgICAgICB2ZWMzIGZpbiA9IHZlYzMoY2lyY2xlKHN0LCByYWRpdXMpKSAqIGNvbG9yO1xuICAgICAgICByZXR1cm4gZmluO1xuICAgICAgfVxuICAgIGAsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDouMyB9LFxuICAgICAgeyBuYW1lOidjb2xvcicsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsxLDEsMV0gfVxuICAgIF0sXG4gIH0sXG4gIHN0cmlwZXM6IHtcbiAgICBuYW1lOidzdHJpcGVzJyxcbiAgICBnbHNsOmAgICAgICAgICAgXG4gICAgICAgIHZlYzMgc3RyaXBlcyggdmVjMyBwb3MsIGZsb2F0IHNjYWxlLCB2ZWMzIGNvbG9yICkge1xuICAgICAgICAgIHZlYzMgdGV4O1xuICAgICAgICAgIHRleCA9IHZlYzMoIGNvbG9yIC0gc21vb3Roc3RlcCgwLjMsIDAuMzIsIGxlbmd0aChmcmFjdCgocG9zLngrcG9zLnkrcG9zLnopKnNjYWxlKSAtLjUgKSkgKTtcbiAgICAgICAgICByZXR1cm4gdGV4O1xuICAgICAgICB9YCAsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgICB7IG5hbWU6J2NvbG9yJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzEsMSwxXSB9XG4gICAgXSxcbiAgfSxcbiAgY2VsbHVsYXI6IHtcbiAgICBuYW1lOidjZWxsdWxhcicsXG4gICAgZ2xzbDpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuICAgICAgICAvLyBQZXJtdXRhdGlvbiBwb2x5bm9taWFsOiAoMzR4XjIgKyB4KSBtb2QgMjg5XFxudmVjMyBwZXJtdXRlKHZlYzMgeCkge1xcbiAgcmV0dXJuIG1vZCgoMzQuMCAqIHggKyAxLjApICogeCwgMjg5LjApO1xcbn1cXG5cXG52ZWMzIGRpc3QodmVjMyB4LCB2ZWMzIHksIHZlYzMgeiwgIGJvb2wgbWFuaGF0dGFuRGlzdGFuY2UpIHtcXG4gIHJldHVybiBtYW5oYXR0YW5EaXN0YW5jZSA/ICBhYnMoeCkgKyBhYnMoeSkgKyBhYnMoeikgOiAgKHggKiB4ICsgeSAqIHkgKyB6ICogeik7XFxufVxcblxcbnZlYzIgd29ybGV5KHZlYzMgUCwgZmxvYXQgaml0dGVyLCBib29sIG1hbmhhdHRhbkRpc3RhbmNlKSB7XFxuZmxvYXQgSyA9IDAuMTQyODU3MTQyODU3OyAvLyAxLzdcXG5mbG9hdCBLbyA9IDAuNDI4NTcxNDI4NTcxOyAvLyAxLzItSy8yXFxuZmxvYXQgIEsyID0gMC4wMjA0MDgxNjMyNjUzMDY7IC8vIDEvKDcqNylcXG5mbG9hdCBLeiA9IDAuMTY2NjY2NjY2NjY3OyAvLyAxLzZcXG5mbG9hdCBLem8gPSAwLjQxNjY2NjY2NjY2NzsgLy8gMS8yLTEvNioyXFxuXFxuXFx0dmVjMyBQaSA9IG1vZChmbG9vcihQKSwgMjg5LjApO1xcbiBcXHR2ZWMzIFBmID0gZnJhY3QoUCkgLSAwLjU7XFxuXFxuXFx0dmVjMyBQZnggPSBQZi54ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFx0dmVjMyBQZnkgPSBQZi55ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFx0dmVjMyBQZnogPSBQZi56ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFxuXFx0dmVjMyBwID0gcGVybXV0ZShQaS54ICsgdmVjMygtMS4wLCAwLjAsIDEuMCkpO1xcblxcdHZlYzMgcDEgPSBwZXJtdXRlKHAgKyBQaS55IC0gMS4wKTtcXG5cXHR2ZWMzIHAyID0gcGVybXV0ZShwICsgUGkueSk7XFxuXFx0dmVjMyBwMyA9IHBlcm11dGUocCArIFBpLnkgKyAxLjApO1xcblxcblxcdHZlYzMgcDExID0gcGVybXV0ZShwMSArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDEyID0gcGVybXV0ZShwMSArIFBpLnopO1xcblxcdHZlYzMgcDEzID0gcGVybXV0ZShwMSArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgcDIxID0gcGVybXV0ZShwMiArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDIyID0gcGVybXV0ZShwMiArIFBpLnopO1xcblxcdHZlYzMgcDIzID0gcGVybXV0ZShwMiArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgcDMxID0gcGVybXV0ZShwMyArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDMyID0gcGVybXV0ZShwMyArIFBpLnopO1xcblxcdHZlYzMgcDMzID0gcGVybXV0ZShwMyArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgb3gxMSA9IGZyYWN0KHAxMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kxMSA9IG1vZChmbG9vcihwMTEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oxMSA9IGZsb29yKHAxMSpLMikqS3ogLSBLem87IC8vIHAxMSA8IDI4OSBndWFyYW50ZWVkXFxuXFxuXFx0dmVjMyBveDEyID0gZnJhY3QocDEyKkspIC0gS287XFxuXFx0dmVjMyBveTEyID0gbW9kKGZsb29yKHAxMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejEyID0gZmxvb3IocDEyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MTMgPSBmcmFjdChwMTMqSykgLSBLbztcXG5cXHR2ZWMzIG95MTMgPSBtb2QoZmxvb3IocDEzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MTMgPSBmbG9vcihwMTMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gyMSA9IGZyYWN0KHAyMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kyMSA9IG1vZChmbG9vcihwMjEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oyMSA9IGZsb29yKHAyMSpLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDIyID0gZnJhY3QocDIyKkspIC0gS287XFxuXFx0dmVjMyBveTIyID0gbW9kKGZsb29yKHAyMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejIyID0gZmxvb3IocDIyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MjMgPSBmcmFjdChwMjMqSykgLSBLbztcXG5cXHR2ZWMzIG95MjMgPSBtb2QoZmxvb3IocDIzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MjMgPSBmbG9vcihwMjMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gzMSA9IGZyYWN0KHAzMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kzMSA9IG1vZChmbG9vcihwMzEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3ozMSA9IGZsb29yKHAzMSpLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDMyID0gZnJhY3QocDMyKkspIC0gS287XFxuXFx0dmVjMyBveTMyID0gbW9kKGZsb29yKHAzMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejMyID0gZmxvb3IocDMyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MzMgPSBmcmFjdChwMzMqSykgLSBLbztcXG5cXHR2ZWMzIG95MzMgPSBtb2QoZmxvb3IocDMzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MzMgPSBmbG9vcihwMzMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgZHgxMSA9IFBmeCArIGppdHRlcipveDExO1xcblxcdHZlYzMgZHkxMSA9IFBmeS54ICsgaml0dGVyKm95MTE7XFxuXFx0dmVjMyBkejExID0gUGZ6LnggKyBqaXR0ZXIqb3oxMTtcXG5cXG5cXHR2ZWMzIGR4MTIgPSBQZnggKyBqaXR0ZXIqb3gxMjtcXG5cXHR2ZWMzIGR5MTIgPSBQZnkueCArIGppdHRlcipveTEyO1xcblxcdHZlYzMgZHoxMiA9IFBmei55ICsgaml0dGVyKm96MTI7XFxuXFxuXFx0dmVjMyBkeDEzID0gUGZ4ICsgaml0dGVyKm94MTM7XFxuXFx0dmVjMyBkeTEzID0gUGZ5LnggKyBqaXR0ZXIqb3kxMztcXG5cXHR2ZWMzIGR6MTMgPSBQZnoueiArIGppdHRlcipvejEzO1xcblxcblxcdHZlYzMgZHgyMSA9IFBmeCArIGppdHRlcipveDIxO1xcblxcdHZlYzMgZHkyMSA9IFBmeS55ICsgaml0dGVyKm95MjE7XFxuXFx0dmVjMyBkejIxID0gUGZ6LnggKyBqaXR0ZXIqb3oyMTtcXG5cXG5cXHR2ZWMzIGR4MjIgPSBQZnggKyBqaXR0ZXIqb3gyMjtcXG5cXHR2ZWMzIGR5MjIgPSBQZnkueSArIGppdHRlcipveTIyO1xcblxcdHZlYzMgZHoyMiA9IFBmei55ICsgaml0dGVyKm96MjI7XFxuXFxuXFx0dmVjMyBkeDIzID0gUGZ4ICsgaml0dGVyKm94MjM7XFxuXFx0dmVjMyBkeTIzID0gUGZ5LnkgKyBqaXR0ZXIqb3kyMztcXG5cXHR2ZWMzIGR6MjMgPSBQZnoueiArIGppdHRlcipvejIzO1xcblxcblxcdHZlYzMgZHgzMSA9IFBmeCArIGppdHRlcipveDMxO1xcblxcdHZlYzMgZHkzMSA9IFBmeS56ICsgaml0dGVyKm95MzE7XFxuXFx0dmVjMyBkejMxID0gUGZ6LnggKyBqaXR0ZXIqb3ozMTtcXG5cXG5cXHR2ZWMzIGR4MzIgPSBQZnggKyBqaXR0ZXIqb3gzMjtcXG5cXHR2ZWMzIGR5MzIgPSBQZnkueiArIGppdHRlcipveTMyO1xcblxcdHZlYzMgZHozMiA9IFBmei55ICsgaml0dGVyKm96MzI7XFxuXFxuXFx0dmVjMyBkeDMzID0gUGZ4ICsgaml0dGVyKm94MzM7XFxuXFx0dmVjMyBkeTMzID0gUGZ5LnogKyBqaXR0ZXIqb3kzMztcXG5cXHR2ZWMzIGR6MzMgPSBQZnoueiArIGppdHRlcipvejMzO1xcblxcblxcdHZlYzMgZDExID0gZGlzdChkeDExLCBkeTExLCBkejExLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMTIgPWRpc3QoZHgxMiwgZHkxMiwgZHoxMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDEzID0gZGlzdChkeDEzLCBkeTEzLCBkejEzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMjEgPSBkaXN0KGR4MjEsIGR5MjEsIGR6MjEsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQyMiA9IGRpc3QoZHgyMiwgZHkyMiwgZHoyMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDIzID0gZGlzdChkeDIzLCBkeTIzLCBkejIzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMzEgPSBkaXN0KGR4MzEsIGR5MzEsIGR6MzEsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQzMiA9IGRpc3QoZHgzMiwgZHkzMiwgZHozMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDMzID0gZGlzdChkeDMzLCBkeTMzLCBkejMzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFxuXFx0dmVjMyBkMWEgPSBtaW4oZDExLCBkMTIpO1xcblxcdGQxMiA9IG1heChkMTEsIGQxMik7XFxuXFx0ZDExID0gbWluKGQxYSwgZDEzKTsgLy8gU21hbGxlc3Qgbm93IG5vdCBpbiBkMTIgb3IgZDEzXFxuXFx0ZDEzID0gbWF4KGQxYSwgZDEzKTtcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMTMpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMTNcXG5cXHR2ZWMzIGQyYSA9IG1pbihkMjEsIGQyMik7XFxuXFx0ZDIyID0gbWF4KGQyMSwgZDIyKTtcXG5cXHRkMjEgPSBtaW4oZDJhLCBkMjMpOyAvLyBTbWFsbGVzdCBub3cgbm90IGluIGQyMiBvciBkMjNcXG5cXHRkMjMgPSBtYXgoZDJhLCBkMjMpO1xcblxcdGQyMiA9IG1pbihkMjIsIGQyMyk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQyM1xcblxcdHZlYzMgZDNhID0gbWluKGQzMSwgZDMyKTtcXG5cXHRkMzIgPSBtYXgoZDMxLCBkMzIpO1xcblxcdGQzMSA9IG1pbihkM2EsIGQzMyk7IC8vIFNtYWxsZXN0IG5vdyBub3QgaW4gZDMyIG9yIGQzM1xcblxcdGQzMyA9IG1heChkM2EsIGQzMyk7XFxuXFx0ZDMyID0gbWluKGQzMiwgZDMzKTsgLy8gMm5kIHNtYWxsZXN0IG5vdyBub3QgaW4gZDMzXFxuXFx0dmVjMyBkYSA9IG1pbihkMTEsIGQyMSk7XFxuXFx0ZDIxID0gbWF4KGQxMSwgZDIxKTtcXG5cXHRkMTEgPSBtaW4oZGEsIGQzMSk7IC8vIFNtYWxsZXN0IG5vdyBpbiBkMTFcXG5cXHRkMzEgPSBtYXgoZGEsIGQzMSk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQzMVxcblxcdGQxMS54eSA9IChkMTEueCA8IGQxMS55KSA/IGQxMS54eSA6IGQxMS55eDtcXG5cXHRkMTEueHogPSAoZDExLnggPCBkMTEueikgPyBkMTEueHogOiBkMTEueng7IC8vIGQxMS54IG5vdyBzbWFsbGVzdFxcblxcdGQxMiA9IG1pbihkMTIsIGQyMSk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQyMVxcblxcdGQxMiA9IG1pbihkMTIsIGQyMik7IC8vIG5vciBpbiBkMjJcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMzEpOyAvLyBub3IgaW4gZDMxXFxuXFx0ZDEyID0gbWluKGQxMiwgZDMyKTsgLy8gbm9yIGluIGQzMlxcblxcdGQxMS55eiA9IG1pbihkMTEueXosZDEyLnh5KTsgLy8gbm9yIGluIGQxMi55elxcblxcdGQxMS55ID0gbWluKGQxMS55LGQxMi56KTsgLy8gT25seSB0d28gbW9yZSB0byBnb1xcblxcdGQxMS55ID0gbWluKGQxMS55LGQxMS56KTsgLy8gRG9uZSEgKFBoZXchKVxcblxcdHJldHVybiBzcXJ0KGQxMS54eSk7IC8vIEYxLCBGMlxcblxcbn1cXG5cXG4gICAgICAgIHZlYzMgY2VsbHVsYXIoIHZlYzMgcG9zLCBmbG9hdCBzY2FsZSwgZmxvYXQgaml0dGVyLCBmbG9hdCBtb2RlLCBmbG9hdCBzdHJlbmd0aCwgZmxvYXQgdGltZSApIHtcXG4gICAgICAgICAgdmVjMiB3ID0gd29ybGV5KCBwb3MgKiBzY2FsZSArIHRpbWUsIGppdHRlciwgZmFsc2UgKTtcXG4gICAgICAgICAgdmVjMyBvO1xcbiAgICAgICAgICBpZiggbW9kZSA9PSAwLiApIHtcXG4gICAgICAgICAgICBvID0gdmVjMyggdy54ICk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoIG1vZGUgPT0gMS4gKSB7XFxuICAgICAgICAgICAgbyA9IHZlYzMoIHcueSApO1xcbiAgICAgICAgICB9IGVsc2V7XFxuICAgICAgICAgICAgbyA9IHZlYzMoIHcueSAtIHcueCApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBvICogc3RyZW5ndGg7XFxuICAgICAgICB9XFxuICAgIFwiLFwiXCJdKSxcbiAgICBnbHNsMmQ6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcblxcbiAgICAgICAgLy8gUGVybXV0YXRpb24gcG9seW5vbWlhbDogKDM0eF4yICsgeCkgbW9kIDI4OVxcbnZlYzMgcGVybXV0ZSh2ZWMzIHgpIHtcXG4gIHJldHVybiBtb2QoKDM0LjAgKiB4ICsgMS4wKSAqIHgsIDI4OS4wKTtcXG59XFxuXFxudmVjMyBkaXN0KHZlYzMgeCwgdmVjMyB5LCB2ZWMzIHosICBib29sIG1hbmhhdHRhbkRpc3RhbmNlKSB7XFxuICByZXR1cm4gbWFuaGF0dGFuRGlzdGFuY2UgPyAgYWJzKHgpICsgYWJzKHkpICsgYWJzKHopIDogICh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xcbn1cXG5cXG52ZWMyIHdvcmxleSh2ZWMzIFAsIGZsb2F0IGppdHRlciwgYm9vbCBtYW5oYXR0YW5EaXN0YW5jZSkge1xcbmZsb2F0IEsgPSAwLjE0Mjg1NzE0Mjg1NzsgLy8gMS83XFxuZmxvYXQgS28gPSAwLjQyODU3MTQyODU3MTsgLy8gMS8yLUsvMlxcbmZsb2F0ICBLMiA9IDAuMDIwNDA4MTYzMjY1MzA2OyAvLyAxLyg3KjcpXFxuZmxvYXQgS3ogPSAwLjE2NjY2NjY2NjY2NzsgLy8gMS82XFxuZmxvYXQgS3pvID0gMC40MTY2NjY2NjY2Njc7IC8vIDEvMi0xLzYqMlxcblxcblxcdHZlYzMgUGkgPSBtb2QoZmxvb3IoUCksIDI4OS4wKTtcXG4gXFx0dmVjMyBQZiA9IGZyYWN0KFApIC0gMC41O1xcblxcblxcdHZlYzMgUGZ4ID0gUGYueCArIHZlYzMoMS4wLCAwLjAsIC0xLjApO1xcblxcdHZlYzMgUGZ5ID0gUGYueSArIHZlYzMoMS4wLCAwLjAsIC0xLjApO1xcblxcdHZlYzMgUGZ6ID0gUGYueiArIHZlYzMoMS4wLCAwLjAsIC0xLjApO1xcblxcblxcdHZlYzMgcCA9IHBlcm11dGUoUGkueCArIHZlYzMoLTEuMCwgMC4wLCAxLjApKTtcXG5cXHR2ZWMzIHAxID0gcGVybXV0ZShwICsgUGkueSAtIDEuMCk7XFxuXFx0dmVjMyBwMiA9IHBlcm11dGUocCArIFBpLnkpO1xcblxcdHZlYzMgcDMgPSBwZXJtdXRlKHAgKyBQaS55ICsgMS4wKTtcXG5cXG5cXHR2ZWMzIHAxMSA9IHBlcm11dGUocDEgKyBQaS56IC0gMS4wKTtcXG5cXHR2ZWMzIHAxMiA9IHBlcm11dGUocDEgKyBQaS56KTtcXG5cXHR2ZWMzIHAxMyA9IHBlcm11dGUocDEgKyBQaS56ICsgMS4wKTtcXG5cXG5cXHR2ZWMzIHAyMSA9IHBlcm11dGUocDIgKyBQaS56IC0gMS4wKTtcXG5cXHR2ZWMzIHAyMiA9IHBlcm11dGUocDIgKyBQaS56KTtcXG5cXHR2ZWMzIHAyMyA9IHBlcm11dGUocDIgKyBQaS56ICsgMS4wKTtcXG5cXG5cXHR2ZWMzIHAzMSA9IHBlcm11dGUocDMgKyBQaS56IC0gMS4wKTtcXG5cXHR2ZWMzIHAzMiA9IHBlcm11dGUocDMgKyBQaS56KTtcXG5cXHR2ZWMzIHAzMyA9IHBlcm11dGUocDMgKyBQaS56ICsgMS4wKTtcXG5cXG5cXHR2ZWMzIG94MTEgPSBmcmFjdChwMTEqSykgLSBLbztcXG5cXHR2ZWMzIG95MTEgPSBtb2QoZmxvb3IocDExKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MTEgPSBmbG9vcihwMTEqSzIpKkt6IC0gS3pvOyAvLyBwMTEgPCAyODkgZ3VhcmFudGVlZFxcblxcblxcdHZlYzMgb3gxMiA9IGZyYWN0KHAxMipLKSAtIEtvO1xcblxcdHZlYzMgb3kxMiA9IG1vZChmbG9vcihwMTIqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oxMiA9IGZsb29yKHAxMipLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDEzID0gZnJhY3QocDEzKkspIC0gS287XFxuXFx0dmVjMyBveTEzID0gbW9kKGZsb29yKHAxMypLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejEzID0gZmxvb3IocDEzKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MjEgPSBmcmFjdChwMjEqSykgLSBLbztcXG5cXHR2ZWMzIG95MjEgPSBtb2QoZmxvb3IocDIxKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MjEgPSBmbG9vcihwMjEqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gyMiA9IGZyYWN0KHAyMipLKSAtIEtvO1xcblxcdHZlYzMgb3kyMiA9IG1vZChmbG9vcihwMjIqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oyMiA9IGZsb29yKHAyMipLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDIzID0gZnJhY3QocDIzKkspIC0gS287XFxuXFx0dmVjMyBveTIzID0gbW9kKGZsb29yKHAyMypLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejIzID0gZmxvb3IocDIzKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MzEgPSBmcmFjdChwMzEqSykgLSBLbztcXG5cXHR2ZWMzIG95MzEgPSBtb2QoZmxvb3IocDMxKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MzEgPSBmbG9vcihwMzEqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gzMiA9IGZyYWN0KHAzMipLKSAtIEtvO1xcblxcdHZlYzMgb3kzMiA9IG1vZChmbG9vcihwMzIqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3ozMiA9IGZsb29yKHAzMipLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDMzID0gZnJhY3QocDMzKkspIC0gS287XFxuXFx0dmVjMyBveTMzID0gbW9kKGZsb29yKHAzMypLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejMzID0gZmxvb3IocDMzKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIGR4MTEgPSBQZnggKyBqaXR0ZXIqb3gxMTtcXG5cXHR2ZWMzIGR5MTEgPSBQZnkueCArIGppdHRlcipveTExO1xcblxcdHZlYzMgZHoxMSA9IFBmei54ICsgaml0dGVyKm96MTE7XFxuXFxuXFx0dmVjMyBkeDEyID0gUGZ4ICsgaml0dGVyKm94MTI7XFxuXFx0dmVjMyBkeTEyID0gUGZ5LnggKyBqaXR0ZXIqb3kxMjtcXG5cXHR2ZWMzIGR6MTIgPSBQZnoueSArIGppdHRlcipvejEyO1xcblxcblxcdHZlYzMgZHgxMyA9IFBmeCArIGppdHRlcipveDEzO1xcblxcdHZlYzMgZHkxMyA9IFBmeS54ICsgaml0dGVyKm95MTM7XFxuXFx0dmVjMyBkejEzID0gUGZ6LnogKyBqaXR0ZXIqb3oxMztcXG5cXG5cXHR2ZWMzIGR4MjEgPSBQZnggKyBqaXR0ZXIqb3gyMTtcXG5cXHR2ZWMzIGR5MjEgPSBQZnkueSArIGppdHRlcipveTIxO1xcblxcdHZlYzMgZHoyMSA9IFBmei54ICsgaml0dGVyKm96MjE7XFxuXFxuXFx0dmVjMyBkeDIyID0gUGZ4ICsgaml0dGVyKm94MjI7XFxuXFx0dmVjMyBkeTIyID0gUGZ5LnkgKyBqaXR0ZXIqb3kyMjtcXG5cXHR2ZWMzIGR6MjIgPSBQZnoueSArIGppdHRlcipvejIyO1xcblxcblxcdHZlYzMgZHgyMyA9IFBmeCArIGppdHRlcipveDIzO1xcblxcdHZlYzMgZHkyMyA9IFBmeS55ICsgaml0dGVyKm95MjM7XFxuXFx0dmVjMyBkejIzID0gUGZ6LnogKyBqaXR0ZXIqb3oyMztcXG5cXG5cXHR2ZWMzIGR4MzEgPSBQZnggKyBqaXR0ZXIqb3gzMTtcXG5cXHR2ZWMzIGR5MzEgPSBQZnkueiArIGppdHRlcipveTMxO1xcblxcdHZlYzMgZHozMSA9IFBmei54ICsgaml0dGVyKm96MzE7XFxuXFxuXFx0dmVjMyBkeDMyID0gUGZ4ICsgaml0dGVyKm94MzI7XFxuXFx0dmVjMyBkeTMyID0gUGZ5LnogKyBqaXR0ZXIqb3kzMjtcXG5cXHR2ZWMzIGR6MzIgPSBQZnoueSArIGppdHRlcipvejMyO1xcblxcblxcdHZlYzMgZHgzMyA9IFBmeCArIGppdHRlcipveDMzO1xcblxcdHZlYzMgZHkzMyA9IFBmeS56ICsgaml0dGVyKm95MzM7XFxuXFx0dmVjMyBkejMzID0gUGZ6LnogKyBqaXR0ZXIqb3ozMztcXG5cXG5cXHR2ZWMzIGQxMSA9IGRpc3QoZHgxMSwgZHkxMSwgZHoxMSwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDEyID1kaXN0KGR4MTIsIGR5MTIsIGR6MTIsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQxMyA9IGRpc3QoZHgxMywgZHkxMywgZHoxMywgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDIxID0gZGlzdChkeDIxLCBkeTIxLCBkejIxLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMjIgPSBkaXN0KGR4MjIsIGR5MjIsIGR6MjIsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQyMyA9IGRpc3QoZHgyMywgZHkyMywgZHoyMywgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDMxID0gZGlzdChkeDMxLCBkeTMxLCBkejMxLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMzIgPSBkaXN0KGR4MzIsIGR5MzIsIGR6MzIsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQzMyA9IGRpc3QoZHgzMywgZHkzMywgZHozMywgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcblxcdHZlYzMgZDFhID0gbWluKGQxMSwgZDEyKTtcXG5cXHRkMTIgPSBtYXgoZDExLCBkMTIpO1xcblxcdGQxMSA9IG1pbihkMWEsIGQxMyk7IC8vIFNtYWxsZXN0IG5vdyBub3QgaW4gZDEyIG9yIGQxM1xcblxcdGQxMyA9IG1heChkMWEsIGQxMyk7XFxuXFx0ZDEyID0gbWluKGQxMiwgZDEzKTsgLy8gMm5kIHNtYWxsZXN0IG5vdyBub3QgaW4gZDEzXFxuXFx0dmVjMyBkMmEgPSBtaW4oZDIxLCBkMjIpO1xcblxcdGQyMiA9IG1heChkMjEsIGQyMik7XFxuXFx0ZDIxID0gbWluKGQyYSwgZDIzKTsgLy8gU21hbGxlc3Qgbm93IG5vdCBpbiBkMjIgb3IgZDIzXFxuXFx0ZDIzID0gbWF4KGQyYSwgZDIzKTtcXG5cXHRkMjIgPSBtaW4oZDIyLCBkMjMpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMjNcXG5cXHR2ZWMzIGQzYSA9IG1pbihkMzEsIGQzMik7XFxuXFx0ZDMyID0gbWF4KGQzMSwgZDMyKTtcXG5cXHRkMzEgPSBtaW4oZDNhLCBkMzMpOyAvLyBTbWFsbGVzdCBub3cgbm90IGluIGQzMiBvciBkMzNcXG5cXHRkMzMgPSBtYXgoZDNhLCBkMzMpO1xcblxcdGQzMiA9IG1pbihkMzIsIGQzMyk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQzM1xcblxcdHZlYzMgZGEgPSBtaW4oZDExLCBkMjEpO1xcblxcdGQyMSA9IG1heChkMTEsIGQyMSk7XFxuXFx0ZDExID0gbWluKGRhLCBkMzEpOyAvLyBTbWFsbGVzdCBub3cgaW4gZDExXFxuXFx0ZDMxID0gbWF4KGRhLCBkMzEpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMzFcXG5cXHRkMTEueHkgPSAoZDExLnggPCBkMTEueSkgPyBkMTEueHkgOiBkMTEueXg7XFxuXFx0ZDExLnh6ID0gKGQxMS54IDwgZDExLnopID8gZDExLnh6IDogZDExLnp4OyAvLyBkMTEueCBub3cgc21hbGxlc3RcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMjEpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMjFcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMjIpOyAvLyBub3IgaW4gZDIyXFxuXFx0ZDEyID0gbWluKGQxMiwgZDMxKTsgLy8gbm9yIGluIGQzMVxcblxcdGQxMiA9IG1pbihkMTIsIGQzMik7IC8vIG5vciBpbiBkMzJcXG5cXHRkMTEueXogPSBtaW4oZDExLnl6LGQxMi54eSk7IC8vIG5vciBpbiBkMTIueXpcXG5cXHRkMTEueSA9IG1pbihkMTEueSxkMTIueik7IC8vIE9ubHkgdHdvIG1vcmUgdG8gZ29cXG5cXHRkMTEueSA9IG1pbihkMTEueSxkMTEueik7IC8vIERvbmUhIChQaGV3ISlcXG5cXHRyZXR1cm4gc3FydChkMTEueHkpOyAvLyBGMSwgRjJcXG5cXG59XFxuXFxuICAgICAgICB2ZWMzIGNlbGx1bGFyKCB2ZWMzIHBvcywgZmxvYXQgc2NhbGUsIGZsb2F0IGppdHRlciwgZmxvYXQgbW9kZSwgZmxvYXQgc3RyZW5ndGggKSB7XFxuICAgICAgICAgIHZlYzIgdyA9IHdvcmxleSggcG9zLCBqaXR0ZXIsIGZhbHNlICk7XFxuICAgICAgICAgIHZlYzMgbztcXG4gICAgICAgICAgaWYoIG1vZGUgPT0gMC4gKSB7XFxuICAgICAgICAgICAgbyA9IHZlYzMoIHcueCApO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKCBtb2RlID09IDEuICkge1xcbiAgICAgICAgICAgIG8gPSB2ZWMzKCB3LnkgKTtcXG4gICAgICAgICAgfSBlbHNle1xcbiAgICAgICAgICAgIG8gPSB2ZWMzKCB3LnkgLSB3LnggKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gbyAqIHN0cmVuZ3RoO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMyBjZWxsdWxhcjJkKCB2ZWMyIHN0LCBmbG9hdCBzY2FsZSwgZmxvYXQgaml0dGVyLCBmbG9hdCBtb2RlLCBmbG9hdCBzdHJlbmd0aCwgZmxvYXQgdGltZSApIHtcXG4gICAgICAgICAgcmV0dXJuIGNlbGx1bGFyKCB2ZWMzKHN0ICogc2NhbGUsIHRpbWUpLCBub3IsIHNjYWxlLCBqaXR0ZXIsIG1vZGUsIHN0cmVuZ3RoICk7XFxuICAgICAgICB9XFxuICAgIFwiLFwiXCJdKSxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonaml0dGVyJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTondHlwZScsICB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6IDAgfSxcbiAgICAgIHsgbmFtZTonc3RyZW5ndGgnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MiB9LFxuICAgICAgeyBuYW1lOid0aW1lJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfVxuICAgIF0sICAgICBcbiAgfSxcblxuICB2b3Jvbm9pOiB7XG4gICAgbmFtZTondm9yb25vaScsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J3JlcycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxMDAgfSxcbiAgICAgIHsgbmFtZTondGltZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J21vZGUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MCB9XG4gICAgXSxcbiAgICBnbHNsOmBcbiAgICB2ZWMzIHZvcm9ub2lfaGFzaCh2ZWMzIHApIHtcbiAgICAgIHJldHVybiBmcmFjdChcbiAgICAgICAgICBzaW4odmVjMyhkb3QocCwgdmVjMygxLjAsIDU3LjAsIDExMy4wKSksIGRvdChwLCB2ZWMzKDU3LjAsIDExMy4wLCAxLjApKSxcbiAgICAgICAgICAgICAgICAgICBkb3QocCwgdmVjMygxMTMuMCwgMS4wLCA1Ny4wKSkpKSAqXG4gICAgICAgICAgNDM3NTguNTQ1Myk7XG4gICAgfVxuXG4gICAgdmVjMyB2b3Jvbm9pXzNkKGNvbnN0IGluIHZlYzMgeCwgZmxvYXQgX3JlcyApIHtcbiAgICAgIHZlYzMgcCA9IGZsb29yKHgpO1xuICAgICAgdmVjMyBmID0gZnJhY3QoeCk7XG5cbiAgICAgIGZsb2F0IGlkID0gMC4wO1xuICAgICAgdmVjMiByZXMgPSB2ZWMyKCBfcmVzICk7XG4gICAgICBmb3IgKGludCBrID0gLTE7IGsgPD0gMTsgaysrKSB7XG4gICAgICAgIGZvciAoaW50IGogPSAtMTsgaiA8PSAxOyBqKyspIHtcbiAgICAgICAgICBmb3IgKGludCBpID0gLTE7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2ZWMzIGIgPSB2ZWMzKGZsb2F0KGkpLCBmbG9hdChqKSwgZmxvYXQoaykpO1xuICAgICAgICAgICAgdmVjMyByID0gdmVjMyhiKSAtIGYgKyB2b3Jvbm9pX2hhc2gocCArIGIpO1xuICAgICAgICAgICAgZmxvYXQgZCA9IGRvdChyLCByKTtcblxuICAgICAgICAgICAgZmxvYXQgY29uZCA9IG1heChzaWduKHJlcy54IC0gZCksIDAuMCk7XG4gICAgICAgICAgICBmbG9hdCBuQ29uZCA9IDEuMCAtIGNvbmQ7XG5cbiAgICAgICAgICAgIGZsb2F0IGNvbmQyID0gbkNvbmQgKiBtYXgoc2lnbihyZXMueSAtIGQpLCAwLjApO1xuICAgICAgICAgICAgZmxvYXQgbkNvbmQyID0gMS4wIC0gY29uZDI7XG5cbiAgICAgICAgICAgIGlkID0gKGRvdChwICsgYiwgdmVjMygxLjAsIDU3LjAsIDExMy4wKSkgKiBjb25kKSArIChpZCAqIG5Db25kKTtcbiAgICAgICAgICAgIHJlcyA9IHZlYzIoZCwgcmVzLngpICogY29uZCArIHJlcyAqIG5Db25kO1xuXG4gICAgICAgICAgICByZXMueSA9IGNvbmQyICogZCArIG5Db25kMiAqIHJlcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmVjMyhzcXJ0KHJlcyksIGFicyhpZCkpO1xuICAgIH1cblxuICAgIHZlYzMgdm9yb25vaSggdmVjMyBwb3MsIGZsb2F0IHNjYWxlLCBmbG9hdCByZXMsIGZsb2F0IHRpbWUsIGZsb2F0IG1vZGUgKSB7XG4gICAgICB2ZWMzIHYgPSB2b3Jvbm9pXzNkKCBwb3MgKiBzY2FsZSwgcmVzICk7XG4gICAgICB2ZWMzIGZpbjtcbiAgICAgIGlmKCBtb2RlID09IDAuICkgZmluID0gdmVjMyh2LngpO1xuICAgICAgaWYoIG1vZGUgPT0gMS4gKSBmaW4gPSB2ZWMzKHYueSk7XG4gICAgICBpZiggbW9kZSA9PSAyLiApIGZpbiA9IHZlYzModi55IC0gdi54KTsgXG5cbiAgICAgIHJldHVybiBmaW47XG4gICAgfVxuYCxcbiAgICBnbHNsMmQ6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBcXG4gICAgdmVjMyB2b3Jvbm9pX2hhc2godmVjMyBwKSB7XFxuICAgICAgcmV0dXJuIGZyYWN0KFxcbiAgICAgICAgICBzaW4odmVjMyhkb3QocCwgdmVjMygxLjAsIDU3LjAsIDExMy4wKSksIGRvdChwLCB2ZWMzKDU3LjAsIDExMy4wLCAxLjApKSxcXG4gICAgICAgICAgICAgICAgICAgZG90KHAsIHZlYzMoMTEzLjAsIDEuMCwgNTcuMCkpKSkgKiA0Mzc1OC41NDUzKTtcXG4gICAgfVxcblxcbiAgICB2ZWMzIHZvcm9ub2lfM2QoY29uc3QgaW4gdmVjMyB4LCBmbG9hdCBfcmVzICkge1xcbiAgICAgIHZlYzMgcCA9IGZsb29yKHgpO1xcbiAgICAgIHZlYzMgZiA9IGZyYWN0KHgpO1xcblxcbiAgICAgIGZsb2F0IGlkID0gMC4wO1xcbiAgICAgIHZlYzIgcmVzID0gdmVjMiggX3JlcyApO1xcbiAgICAgIGZvciAoaW50IGsgPSAtMTsgayA8PSAxOyBrKyspIHtcXG4gICAgICAgIGZvciAoaW50IGogPSAtMTsgaiA8PSAxOyBqKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IC0xOyBpIDw9IDE7IGkrKykge1xcbiAgICAgICAgICAgIHZlYzMgYiA9IHZlYzMoZmxvYXQoaSksIGZsb2F0KGopLCBmbG9hdChrKSk7XFxuICAgICAgICAgICAgdmVjMyByID0gdmVjMyhiKSAtIGYgKyB2b3Jvbm9pX2hhc2gocCArIGIpO1xcbiAgICAgICAgICAgIGZsb2F0IGQgPSBkb3Qociwgcik7XFxuXFxuICAgICAgICAgICAgZmxvYXQgY29uZCA9IG1heChzaWduKHJlcy54IC0gZCksIDAuMCk7XFxuICAgICAgICAgICAgZmxvYXQgbkNvbmQgPSAxLjAgLSBjb25kO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGNvbmQyID0gbkNvbmQgKiBtYXgoc2lnbihyZXMueSAtIGQpLCAwLjApO1xcbiAgICAgICAgICAgIGZsb2F0IG5Db25kMiA9IDEuMCAtIGNvbmQyO1xcblxcbiAgICAgICAgICAgIGlkID0gKGRvdChwICsgYiwgdmVjMygxLjAsIDU3LjAsIDExMy4wKSkgKiBjb25kKSArIChpZCAqIG5Db25kKTtcXG4gICAgICAgICAgICByZXMgPSB2ZWMyKGQsIHJlcy54KSAqIGNvbmQgKyByZXMgKiBuQ29uZDtcXG5cXG4gICAgICAgICAgICByZXMueSA9IGNvbmQyICogZCArIG5Db25kMiAqIHJlcy55O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB2ZWMzKHNxcnQocmVzKSwgYWJzKGlkKSk7XFxuICAgIH1cXG5cXG4gICAgdmVjMyB2b3Jvbm9pMmQoIHZlYzIgc3QsIGZsb2F0IHNjYWxlLCBmbG9hdCByZXMsIGZsb2F0IHRpbWUsIGZsb2F0IG1vZGUgKSB7XFxuICAgICAgdmVjMyB2ID0gdm9yb25vaV8zZCggdmVjMyhzdCogc2NhbGUsIHRpbWUpLCByZXMgKTtcXG4gICAgICB2ZWMzIGZpbjtcXG4gICAgICBpZiggbW9kZSA9PSAwLiApIGZpbiA9IHZlYzModi54KTtcXG4gICAgICBpZiggbW9kZSA9PSAxLiApIGZpbiA9IHZlYzModi55KTtcXG4gICAgICBpZiggbW9kZSA9PSAyLiApIGZpbiA9IHZlYzModi55IC0gdi54KTsgXFxuXFxuICAgICAgcmV0dXJuIGZpbjtcXG4gICAgfVxcblxcblwiLFwiXCJdKSAsXG4gIH0sXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3RoZWJvb2tvZnNoYWRlcnMuY29tL2VkaXQucGhwIzA5L3ppZ3phZy5mcmFnXG4gIHppZ3phZzoge1xuICAgIG5hbWU6J3ppZ3phZycsXG4gICAgZ2xzbDJkOmAgICAgXG4gICAgICAgdmVjMiBtaXJyb3JUaWxlKHZlYzIgX3N0LCBmbG9hdCBfem9vbSl7XG4gICAgICAgICBfc3QgKj0gX3pvb207XG4gICAgICAgICBpZiAoZnJhY3QoX3N0LnkgKiAwLjUpID4gMC41KXtcbiAgICAgICAgICAgX3N0LnggPSBfc3QueCswLjU7XG4gICAgICAgICAgIF9zdC55ID0gMS4wLV9zdC55O1xuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIGZyYWN0KF9zdCk7XG4gICAgICAgfVxuXG4gICAgICAgZmxvYXQgZmlsbFkodmVjMiBfc3QsIGZsb2F0IF9wY3QsZmxvYXQgX2FudGlhKXtcbiAgICAgICAgIHJldHVybiBzbW9vdGhzdGVwKCBfcGN0LV9hbnRpYSwgX3BjdCwgX3N0LnkpO1xuICAgICAgIH1cblxuICAgICAgIHZlYzMgemlnemFnMmQoIHZlYzIgc3QsIGZsb2F0IHNjYWxlLCBmbG9hdCB0aW1lICkge1xuICAgICAgICAgc3QgPSBtaXJyb3JUaWxlKHN0KnZlYzIoMS4sMi4pLHNjYWxlKTtcbiAgICAgICAgIGZsb2F0IHggPSBzdC54KjIuO1xuICAgICAgICAgZmxvYXQgYSA9IGZsb29yKDEuK3Npbih4KjMuMTQpKTtcbiAgICAgICAgIGZsb2F0IGIgPSBmbG9vcigxLitzaW4oKHgrMS4pKjMuMTQpKTtcbiAgICAgICAgIGZsb2F0IGYgPSBmcmFjdCh4KTtcblxuICAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoIGZpbGxZKHN0LG1peChhLGIsZiksMC4wMSkgKTsgXG5cbiAgICAgICAgIHJldHVybiB2ZWMzKGNvbG9yKTtcbiAgICAgICB9XG5gICxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjUgfSxcbiAgICAgIHsgbmFtZTondGltZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH1cbiAgICBdLFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGV4dHVyZXNcbiIsIm1vZHVsZS5leHBvcnRzID0gYFxuICAgIC8vIHAgPSBwb2ludCBvbiBzdXJmYWNlLCBwMCA9IG9iamVjdCBjZW50ZXJcbiAgICB2ZWMyIGdldFVWQ3ViaWModmVjMyBwICl7XG4gICAgICB2ZWMzIGFic3AgPSBhYnMocCk7XG4gICAgICAgIFxuICAgICAgLy8gRmlyc3QgY29uZGl0aW9uYWw6IElmIHRoZSBwb2ludCBpcyBpbiBvbmUgb2YgdGhlIHNleHRhbnRzIHRvIHRoZSBcbiAgICAgIC8vIGxlZnQgb3IgcmlnaHQgb2YgdGhlIHgtYXhpcywgdGhlIHV2IGNvcmRpbmF0ZSB3aWxsIGJlICgwLjUqcC56eSkvKHAueCkuXG4gICAgICAvLyBJZiB5b3UgdHJhY2UgYSBsaW5lIG91dCB0byBhIHp5IHBsYW5lIHRoYXQgaXMgMC41IHVuaXRzIGZyb20gdGhlIHplcm8gb3JpZ2luLCAgXG4gICAgICAvLyAoMC41KnAueHl6KS8ocC54KSB3aWxsIGJlIHRoZSByZXN1bHQsIGFuZFxuICAgICAgLy8gdGhlIHl6IGNvbXBvbmVudHMgd2lsbCBiZSBvdXIgdXYgY29vcmRpbmF0ZXMsIGhlbmNlICgwLjUqcC56eSkvKHAueCkuXG5cbiAgICAgIHZlYzIgdXYgPSAoKGFic3AueD49YWJzcC55KSYmKGFic3AueD49YWJzcC56KSkgXG4gICAgICAgID8gKDAuNSpwLnp5KS8ocC54KSBcbiAgICAgICAgOiAoKGFic3AueT49YWJzcC56KSYmKGFic3AueT49YWJzcC54KSkgPyAoMC41KnAueHopLyhwLnkpIDogKC0wLjUqcC54eSkvKHAueik7XG5cbiAgICAgIC8vV2Ugc3RpbGwgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2ggc2lkZSBvdXIgdXYgY29yZGluYXRlcyBhcmUgb24gc29cbiAgICAgIC8vdGhhdCB0aGUgdGV4dHVyZSBvcmllbnRzIHRoZSByaWdodCB3YXkuIE5vdGUgdGhhdCB0aGVyZSdzIHNvbWUgXG4gICAgICAvLyByZWR1bmRhbmN5IHRoZXJlLCB3aGljaCBJJ2xsIGZpeCBhdCBzb21lIHN0YWdlLiBGb3Igbm93LCBpdCB3b3Jrcywgc28gSSdtIG5vdCB0b3VjaGluZyBpdC4gOilcbiAgICAgIGlmKCAoKHAueDwwLikmJihhYnNwLng+PWFic3AueSkmJihhYnNwLng+PWFic3AueikpIFxuICAgICAgIHx8ICgocC55PDAuKSYmKGFic3AueT49YWJzcC56KSYmKGFic3AueT49YWJzcC54KSkgXG4gICAgICAgfHwgKChwLno+MC4pJiYoYWJzcC56Pj1hYnNwLngpJiYoYWJzcC56Pj1hYnNwLnkpKSApIHV2LnkqPS0xLjtcbiAgICAgICAgICAgICBcbiAgICAgIC8vIE1hcHBpbmcgdGhlIHV2IHJhbmdlIGZyb20gWy0wLjUsIDAuNV0gdG8gWzAuMCwgMS4wXS5cbiAgICAgIHJldHVybiAodXYrMC41KTtcbiAgICB9XG4gICAgdmVjNCB0cmlwbGFuYXIodmVjMyBuLCB2ZWM0IHRleHgsIHZlYzQgdGV4eSwgdmVjNCB0ZXh6LCBib29sIGFkanVzdDNkLCBib29sIHJlc2NhbGUpIHtcbiAgICAgIC8vaWYgKGRvZmxpcHopIG4ueiA9IC1uLno7XG4gICAgICBpZiAocmVzY2FsZSkge1xuICAgICAgICB0ZXh4ID0gMi4wKnRleHggLSAxLjA7XG4gICAgICAgIHRleHkgPSAyLjAqdGV4eSAtIDEuMDtcbiAgICAgICAgdGV4eiA9IDIuMCp0ZXh6IC0gMS4wO1xuICAgICAgfVxuICAgICAgaWYgKGFkanVzdDNkKSB7XG4gICAgICAgIHRleHgueCAqPSBzaWduKG4ueCk7XG4gICAgICAgIHRleHkueSAqPSBzaWduKG4ueSk7XG4gICAgICAgIHRleHoueiAqPSBzaWduKG4ueik7XG4gICAgICB9XG4gICAgICAvL2lmIChqdXN0dGV4eSkgcmV0dXJuIHRleHk7XG4gICAgICB2ZWMzIHdlaWdodHMgPSBhYnMobik7XG4gICAgICAvL2lmIChkb3dlaWdodGNvcnJlY3Rpb24pIHdlaWdodHMgLz0gZG90KHdlaWdodHMsdmVjMygxKSk7IC8vIEtlZXAgc3BoZXJpY2FsIVxuICAgICAgICByZXR1cm4gbWF0NCh0ZXh4LHRleHksdGV4eix2ZWM0KDApKSp2ZWM0KHdlaWdodHMsMCk7XG4gICAgfSBcbiAgICBgXG4vKlxubW9kdWxlLmV4cG9ydHMgPSBgdmVjMyB0MyhzYW1wbGVyMkQgdGV4LCB2ZWMzIHAsIHZlYzMgbilcbntcbiAgbWF0MyBSID0gbWF0Myh2ZWMzKGNvcyhUKSxzaW4oVCksMCksdmVjMygtc2luKFQpLGNvcyhUKSwwKSx2ZWMzKDAsMCwtMSkpO1xuICBwICo9IFIvOC4wO1xuICBuICo9IFI7XG4gICNpZmRlZiBTbW9vdGhcbiAgcmV0dXJuICAodGV4dHVyZSh0ZXgscC54eSkucmdiKm4ueipuLnpcbiAgICArdGV4dHVyZSh0ZXgscC56eSkucmdiKm4ueCpuLnhcbiAgICArdGV4dHVyZSh0ZXgscC54eikucmdiKm4ueSpuLnkpO1xuICAjZWxzZVxuICAgIHJldHVybiAodGV4dHVyZSh0ZXgscC54eSkucmdiXG4gICAgICArdGV4dHVyZSh0ZXgscC56eSkucmdiXG4gICAgICArdGV4dHVyZSh0ZXgscC54eikucmdiKS8zLjA7XG4gICAgI2VuZGlmXG4gICAgfWBcbiAgICAqL1xuIiwiY29uc3QgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxuY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9ICA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuY29uc3QgTWF0cml4ID0gcmVxdWlyZSggJy4vZXh0ZXJuYWwvbWF0cml4LmpzJyApXG53aW5kb3cuTWF0cml4ID0gTWF0cml4XG5jb25zdCBNYXRyaXhXcmFwID0gZnVuY3Rpb24gKCBzaG91bGRJbnZlcnQgPSBmYWxzZSApIHtcbiAgY29uc3QgbSA9IE9iamVjdC5jcmVhdGUoIE1hdHJpeFdyYXAucHJvdG90eXBlIClcbiAgbS5kaXJ0eSA9IHRydWVcbiAgbS50cmFuc2xhdGlvbiA9IHt9XG4gIG0uc2NhbGUgPSB7fVxuICBtLnNob3VsZEludmVydCA9IHNob3VsZEludmVydFxuICBtLnJvdGF0aW9uID0ge1xuICAgIGF4aXM6IHt9XG4gIH1cbiAgbS5wYXJlbnQgPSBudWxsXG5cbiAgbGV0IHR4ID0gMCwgdHkgPSAwLCB0eiA9IDBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG0udHJhbnNsYXRpb24sIHtcbiAgICB4OiB7XG4gICAgICBnZXQoKSB7IHJldHVybiB0eCB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICB0eCA9IHZcbiAgICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXgudHJhbnNsYXRlKCB0eCwgdHksIHR6ICkgKVxuICAgICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgeToge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gdHkgfSxcbiAgICAgIHNldCh2KXtcbiAgICAgICAgdHkgPSB2XG4gICAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnRyYW5zbGF0ZSggdHgsIHR5LCB0eiApIClcbiAgICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHo6IHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIHR6IH0sXG4gICAgICBzZXQodil7XG4gICAgICAgIHR6ID0gdlxuICAgICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC50cmFuc2xhdGUoIHR4LCB0eSwgdHogKSApXG4gICAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgfSlcblxuICAvLyBzY2FsaW5nIG11c3QgYmUgc2VudCBhcyBzZXBhcmF0ZSB1bmlmb3JtIHRvIGF2b2lkIHNkZiBvdmVyIGVzdGltYXRpb24gXG4gIGxldCBzY2FsZSA9IDFcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtLCdzY2FsZScsIHtcbiAgICBnZXQoKSB7IHJldHVybiBzY2FsZSB9LFxuICAgIHNldCh2KXtcbiAgICAgIHNjYWxlID0gdlxuICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXgucm90YXRlKCBhbmdsZSwgcngsIHJ5LCByeiApIClcbiAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgfSBcbiAgfSlcblxuICAvKiBGT1IgTk9OLVVOSUZPUk0gU0NBTElORzpcbiAgICpcbiAgICogMS4gY29tbWVudCBvdXQgc2NhbGUgcHJvcGVydHkgYWJvdmVcbiAgICogMi4gdW5jb21tZW50IHNjYWxlIHByb3BlcnR5IGJlbG93XG4gICAqIDMuIGNoYW5nZSBlbWl0X2RlY2wgdG8gdXNlIGEgdmVjMyBmb3Igc2NhbGVcbiAgICogNC4gY2hhbmdlIHVwbG9hZF9kYXRhIHRvIHVwbG9hZCBhIDNmXG4gICAqIDUuIEluIFwicHJpbWl0aXZlcy5qc1wiLCByZXBsYWNlIGxpbmUgMTU1IChwYXJ0IG9mIGVtaXQpIHRvIHVzZSBjb21wZW5zYXRlZCBzY2FsaW5nXG4gICAqLyBcblxuICAvL2xldCBzeCA9IDEsIHN5ID0gMSwgc3ogPSAxXG4gIC8vT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG0uc2NhbGUsIHtcbiAgLy8gIHg6IHtcbiAgLy8gICAgZ2V0KCkgeyByZXR1cm4gc3ggfSxcbiAgLy8gICAgc2V0KHYpe1xuICAvLyAgICAgIHN4ID0gdlxuICAvLyAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnNjYWxlKCBzeCwgc3ksIHN6ICkgKVxuICAvLyAgICAgIG0uZGlydHkgPSB0cnVlXG4gIC8vICAgIH1cbiAgLy8gIH0sXG4gIC8vICB5OiB7XG4gIC8vICAgIGdldCgpIHsgcmV0dXJuIHN5IH0sXG4gIC8vICAgIHNldCh2KXtcbiAgLy8gICAgICBzeSA9IHZcbiAgLy8gICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC5zY2FsZSggc3gsIHN5LCBzeiApIClcbiAgLy8gICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAvLyAgICB9XG4gIC8vICB9LFxuICAvLyAgejoge1xuICAvLyAgICBnZXQoKSB7IHJldHVybiBzeiB9LFxuICAvLyAgICBzZXQodil7XG4gIC8vICAgICAgc3ogPSB2XG4gIC8vICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXguc2NhbGUoIHN4LCBzeSwgc3ogKSApXG4gIC8vICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgLy8gICAgfVxuICAvLyAgfSxcbiAgLy99KVxuXG4gIGxldCBhbmdsZSA9IDBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtLnJvdGF0aW9uLCAnYW5nbGUnLCB7XG4gICAgZ2V0KCkgeyByZXR1cm4gYW5nbGUgfSxcbiAgICBzZXQodil7XG4gICAgICBhbmdsZSA9IHZcbiAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnJvdGF0ZSggYW5nbGUsIHJ4LCByeSwgcnogKSApXG4gICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAgIH0gXG4gIH0pXG5cbiAgbGV0IHJ4ID0gMCwgcnkgPSAwLCByeiA9IDBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG0ucm90YXRpb24uYXhpcywge1xuICAgIHg6IHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIHJ4IH0sXG4gICAgICBzZXQodil7XG4gICAgICAgIHJ4ID0gdlxuICAgICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEgPSBNYXRyaXgucm90YXRlKCBhbmdsZSwgcngsIHJ5LCByeiwgbS5fX2RhdGEgKVxuICAgICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgeToge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gcnkgfSxcbiAgICAgIHNldCh2KXtcbiAgICAgICAgcnkgPSB2XG4gICAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YSA9IE1hdHJpeC5yb3RhdGUoIGFuZ2xlLCByeCwgcnksIHJ6LCBtLl9fZGF0YSApXG4gICAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICB6OiB7XG4gICAgICBnZXQoKSB7IHJldHVybiByeiB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICByeiA9IHZcbiAgICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhID0gTWF0cml4LnJvdGF0ZSggYW5nbGUsIHJ4LCByeSwgcnosIG0uX19kYXRhIClcbiAgICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICB9KVxuXG4gIG0uX19yb3RhdGlvbnMgPSBbXVxuICBtLl9faWQgICA9IFZhckFsbG9jLmFsbG9jKCkgIFxuICBtLl9fZGlydHkgPSBmdW5jdGlvbigpIHt9XG4gIG0uX19kYXRhID0gTWF0cml4LmlkZW50aXR5KClcbiAgbS5fX01hdHJpeCA9IE1hdHJpeFxuICBtLnZhck5hbWUgPSAndHJhbnNmb3JtJyArIG0uX19pZFxuXG4gIHJldHVybiBtXG59XG5cbk1hdHJpeFdyYXAucHJvdG90eXBlID0ge1xuICB0eXBlOiAnbWF0cml4JyxcblxuICBlbWl0KCkgeyByZXR1cm4gdGhpcy52YXJOYW1lIH0sXG5cbiAgZW1pdF9zY2FsZSgpIHsgcmV0dXJuIHRoaXMudmFyTmFtZSArICdfc2NhbGUnIH0sXG5cbiAgZW1pdF9kZWNsKCkgeyBcbiAgICBjb25zdCBkZWNsID0gIGAgICAgdW5pZm9ybSBtYXQ0ICR7dGhpcy52YXJOYW1lfTtcbiAgICB1bmlmb3JtIGZsb2F0ICR7dGhpcy52YXJOYW1lfV9zY2FsZTtcbiAgICBgIFxuXG4gICAgcmV0dXJuIGRlY2xcbiAgfSxcblxuXHR1cGRhdGVfbG9jYXRpb24oZ2wsIHByb2dyYW0pIHtcblx0XHR0aGlzLmxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgdGhpcy52YXJOYW1lIClcblx0XHR0aGlzLmxvY19zY2FsZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgdGhpcy52YXJOYW1lKydfc2NhbGUnIClcblx0fSxcdFxuXG5cdHVwbG9hZF9kYXRhKGdsKSB7XG5cdFx0aWYoICF0aGlzLmRpcnR5ICkgcmV0dXJuXG5cdFx0XG4gICAgdGhpcy5pbnRlcm5hbCgpXG5cbiAgICBpZiggdGhpcy5zaG91bGRJbnZlcnQgPT09IHRydWUgKSB7XG4gICAgICBjb25zdCBpbnZlcnNlID0gTWF0cml4LmludmVyc2UoIHRoaXMuX19kYXRhIClcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMubG9jLCBmYWxzZSwgaW52ZXJzZS5tIClcbiAgICB9ZWxzZXtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMubG9jLCBmYWxzZSwgdGhpcy5fX2RhdGEubSApXG4gICAgfVxuICAgIC8vZ2wudW5pZm9ybTNmKHRoaXMubG9jX3NjYWxlLCB0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSwgdGhpcy5zY2FsZS56IClcbiAgICBcbiAgICAvLyBzY2FsaW5nIG11c3QgYmUgc2VudCBhcyBzZXBhcmF0ZSB1bmlmb3JtIHRvIGF2b2lkIHNkZiBvdmVyLWVzdGltYXRpb24gXG4gICAgZ2wudW5pZm9ybTFmKHRoaXMubG9jX3NjYWxlLCB0aGlzLnNjYWxlIClcblxuXHRcdHRoaXMuZGlydHkgPSBmYWxzZVxuICB9LFxuXG5cbiAgaW50ZXJuYWwoKSB7XG4gICAgdGhpcy5fX2RhdGEgPSBNYXRyaXguaWRlbnRpdHkoKVxuICAgIGlmKCB0aGlzLnBhcmVudCAhPSBudWxsICkgdGhpcy5fX2RhdGEgPSB0aGlzLnBhcmVudC5fX2RhdGFcblxuICAgIHRoaXMuX19kYXRhID0gdGhpcy5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC50cmFuc2xhdGUoIHRoaXMudHJhbnNsYXRpb24ueCwgdGhpcy50cmFuc2xhdGlvbi55LCB0aGlzLnRyYW5zbGF0aW9uLnogKSApIFxuXG4gICAgLy8gaGFuZGxlIGN1bXVsYXRpdmUgcm90YXRpb25zIHZpYSAucm90YXRlQnkoKSBtZXRob2RcbiAgICB0aGlzLl9fcm90YXRpb25zLmZvckVhY2goIHIgPT4gdGhpcy5fX2RhdGEgPSB0aGlzLl9fZGF0YS5tdWx0aXBseSggciApIClcblxuICAgIC8vIGhhbmRsZSBhYnNvbHV0ZSByb3RhdGlvbnMgdmlhIC5yb3RhdGUoKSBtZXRob2QuLi4gc2hvdWxkIHRoaXMgYmUgYWxpYXNlZCB0byByb3RhdGVUbygpID9cbiAgICB0aGlzLl9fZGF0YSA9IHRoaXMuX19kYXRhLm11bHRpcGx5KCBNYXRyaXgucm90YXRlKCB0aGlzLnJvdGF0aW9uLmFuZ2xlLCB0aGlzLnJvdGF0aW9uLmF4aXMueCwgdGhpcy5yb3RhdGlvbi5heGlzLnksIHRoaXMucm90YXRpb24uYXhpcy56ICkgKVxuXG4gICAgdGhpcy5fX2RhdGEgPSB0aGlzLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnNjYWxlKCB0aGlzLnNjYWxlLCB0aGlzLnNjYWxlLCB0aGlzLnNjYWxlICkgKVxuICB9LFxuXG4gIGludmVydCggc2hvdWxkSW52ZXJ0ID0gdHJ1ZSkge1xuICAgIHRoaXMuc2hvdWxkSW52ZXJ0ID0gc2hvdWxkSW52ZXJ0XG4gICAgdGhpcy5kaXJ0eSA9IHRydWVcbiAgfSxcblxuICBhcHBseSggdHJhbnNmb3JtID0gbnVsbCwgc2hvdWxkSW52ZXJ0ID0gZmFsc2UgKSB7XG4gICAgdGhpcy5wYXJlbnQgPSB0cmFuc2Zvcm1cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZVxuICB9IFxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4V3JhcFxuIiwiY29uc3QgVmFyID0gcmVxdWlyZSgnLi92YXIuanMnKS5WYXJcblxuLy8gV3JhcHBlclxuZnVuY3Rpb24gcGFyYW1fd3JhcCggdiwgX19kZWZhdWx0LCBuYW1lPW51bGwgKSB7XG5cdGlmKCB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCApIHJldHVybiBfX2RlZmF1bHQoKVxuXHRpZiggdi5fX2lzVmFyID09PSB0cnVlICkgcmV0dXJuIHZcblx0XG5cdHJldHVybiBWYXIoIHYsIG5hbWUgKVxufVxuXG5jb25zdCBNYXRlcmlhbElEID0ge1xuXHRjdXJyZW50OiAwLFxuXHRhbGxvYygpIHtcblx0XHRyZXR1cm4gTWF0ZXJpYWxJRC5jdXJyZW50KytcbiAgfSxcbiAgY2xlYXIoKSB7XG4gICAgTWF0ZXJpYWxJRC5jdXJyZW50ID0gMFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH1cbiIsImNvbnN0IHsgVmVjMiwgVmVjMywgVmVjNCB9ID0gcmVxdWlyZSggJy4vdmVjLmpzJyApXG5jb25zdCBmbG9hdCA9IHJlcXVpcmUoICcuL2Zsb2F0LmpzJyApXG5jb25zdCBpbnQgICA9IHJlcXVpcmUoICcuL2ludC5qcycgKVxuXG4vLyBWYXJcbmNvbnN0IFZhckFsbG9jID0ge1xuXHRjdXJyZW50OiAwLFxuICBjbGVhcigpIHtcbiAgICBWYXJBbGxvYy5jdXJyZW50ID0gMFxuICB9LFxuXHRhbGxvYygpIHtcblx0XHRyZXR1cm4gVmFyQWxsb2MuY3VycmVudCsrXG5cdH1cbn1cblxubGV0IFZhciA9IGZ1bmN0aW9uKCB2YWx1ZSwgZml4ZWROYW1lID0gbnVsbCwgX190eXBlICkge1xuICBjb25zdCB2ID0gT2JqZWN0LmNyZWF0ZSggVmFyLnByb3RvdHlwZSApXG5cdHYudmFyTmFtZSA9IGZpeGVkTmFtZSAhPT0gbnVsbCA/IGZpeGVkTmFtZSA6ICd2YXInICsgVmFyQWxsb2MuYWxsb2MoKVxuICB2LnZhbHVlID0gdmFsdWVcbiAgdi50eXBlID0gdi52YWx1ZS50eXBlXG4gIGlmKCB2LnR5cGUgPT09IHVuZGVmaW5lZCApIHYudHlwZSA9IF9fdHlwZSB8fCAnZmxvYXQnIFxuXG4gIHZhbHVlLnZhciA9IHZcblxuICBpZiggdi50eXBlICE9PSAnZmxvYXQnICYmIHYudHlwZSAhPT0gJ2ludCcgKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHYsIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy52YWx1ZS54IH0sXG4gICAgICAgIHNldCh2KXsgdGhpcy52YWx1ZS54ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWUgfVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy52YWx1ZS55IH0sXG4gICAgICAgIHNldCh2KXsgdGhpcy52YWx1ZS55ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWUgfVxuICAgICAgfSxcbiAgICAgIHo6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy52YWx1ZS56IH0sXG4gICAgICAgIHNldCh2KXsgdGhpcy52YWx1ZS56ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWUgfVxuICAgICAgfSxcbiAgICAgIHc6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy52YWx1ZS53IH0sXG4gICAgICAgIHNldCh2KXsgdGhpcy52YWx1ZS53ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWUgfVxuICAgICAgfSxcbiAgICB9KVxuICB9LyplbHNle1xuICAgIGxldCBfX3ZhbHVlID0gdi52YWx1ZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdiwgJ3ZhbHVlJywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gX192YWx1ZSB9LFxuICAgICAgc2V0KHYpeyBfX3ZhbHVlID0gdjsgdGhpcy5kaXJ0eSA9IHRydWUgfVxuICAgIH0pXG4gIH0qL1xuXG4gIHJldHVybiB2XG59XG5cblZhci5oYXJkY29kZSA9IGZhbHNlXG5jb25zdCBlbWl0X2Zsb2F0ID0gZnVuY3Rpb24oIGEgKSB7XG5cdGlmIChhICUgMSA9PT0gMClcblx0XHRyZXR1cm4gYS50b0ZpeGVkKCAxIClcblx0ZWxzZVxuXHRcdHJldHVybiBhXG59XG5cblZhci5wcm90b3R5cGUgPSB7XG5cdGRpcnR5OiB0cnVlLFxuXG5cdGxvYzogLTEsXG5cbiAgZW1pdCgpIHsgXG4gICAgbGV0IG91dFxuICAgIGlmKCB0aGlzLnZhbHVlLmlzR2VuICkge1xuICAgICAgY29uc3QgdmVjT3V0ID0gdGhpcy52YWx1ZS5lbWl0KCkgXG4gICAgICBvdXQgPSB2ZWNPdXQucHJlZmFjZSArIHZlY091dC5vdXRcbiAgICAgICAgXG4gICAgfWVsc2V7XG4gICAgICBvdXQgPSB0aGlzLnZhck5hbWUgXG4gICAgfSBcblxuICAgIHJldHVybiBvdXRcbiAgfSxcblxuICBlbWl0X2RlY2woKSB7IFxuICAgIGxldCBvdXQgPSAnJ1xuICAgIGlmKCB0aGlzLnZhbHVlLmlzR2VuICkge1xuICAgICAgb3V0ID0gdGhpcy52YWx1ZS5lbWl0X2RlY2woKVxuICAgIH1lbHNle1xuICAgICAgaWYoIFZhci5oYXJkY29kZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICBpZiggdHlwZW9mIHRoaXMudmFsdWUuZW1pdCAhPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICBpZiggdGhpcy50eXBlID09PSAnZmxvYXQnICkge1xuICAgICAgICAgICAgb3V0ID0gYCR7dGhpcy50eXBlfSAke3RoaXMudmFyTmFtZX0gPSAke2VtaXRfZmxvYXQodGhpcy52YWx1ZSl9O1xcbmBcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIG91dCA9IGAke3RoaXMudHlwZX0gJHt0aGlzLnZhck5hbWV9ID0gJHt0aGlzLnZhbHVlfTtcXG5gXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZS5lbWl0KClcbiAgICAgICAgICBpZiggdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycgKSB2YWwgPSB2YWwub3V0XG4gICAgICAgICAgb3V0ID0gdmFsICE9PSB1bmRlZmluZWQgPyBgJHt0aGlzLnR5cGV9ICR7dGhpcy52YXJOYW1lfSA9ICR7dmFsfTtcXG5gIDogJydcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIG91dCA9IGB1bmlmb3JtICR7dGhpcy50eXBlfSAke3RoaXMudmFyTmFtZX07XFxuYFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH0sXG5cblx0c2V0KHYpIHsgdGhpcy52YWx1ZSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9LFxuXG5cdHVwZGF0ZV9sb2NhdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIGlmKCB0aGlzLnZhbHVlLmlzR2VuICkge1xuICAgICAgdGhpcy52YWx1ZS51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgIHJldHVyblxuICAgIH1cblx0XHR0aGlzLmxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB0aGlzLnZhck5hbWUpXG5cdH0sXHRcblxuXHR1cGxvYWRfZGF0YShnbCkge1xuXHRcdGlmKCAhdGhpcy5kaXJ0eSApIHJldHVyblxuXHRcdFxuICAgIGlmKCB0aGlzLnZhbHVlLmlzR2VuICkge1xuICAgICAgdGhpcy52YWx1ZS51cGxvYWRfZGF0YSggZ2wgIClcbiAgICAgIHRoaXMuZGlydHkgPSBmYWxzZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXHRcdGxldCB2ID0gdGhpcy52YWx1ZVxuXHRcdGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRnbC51bmlmb3JtMWYoIHRoaXMubG9jLCB2IClcblx0XHR9ZWxzZSBpZiAoIHYgaW5zdGFuY2VvZiBWZWMyICkge1xuXHRcdFx0Z2wudW5pZm9ybTJmKHRoaXMubG9jLCB2LngsIHYueSApXG5cdFx0fSBlbHNlIGlmKCB2IGluc3RhbmNlb2YgVmVjMyApIHtcblx0XHRcdGdsLnVuaWZvcm0zZih0aGlzLmxvYywgdi54LCB2LnksIHYueiApXG5cdFx0fSBlbHNlIGlmKCB2IGluc3RhbmNlb2YgVmVjNCApIHtcblx0XHRcdGdsLnVuaWZvcm00Zih0aGlzLmxvYywgdi54LCB2LnksIHYueiwgdi53IClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGNvbG9yIHZhcmlhYmxlc1xuICAgICAgaWYoIHRoaXMudHlwZSA9PT0gJ2Zsb2F0JyApIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKCB0aGlzLmxvYywgdi54IClcbiAgICAgIH1lbHNle1xuICAgICAgICBnbC51bmlmb3JtMWkoIHRoaXMubG9jLCB2LnggKVxuICAgICAgfVxuICAgIH1cblxuXHRcdHRoaXMuZGlydHkgPSBmYWxzZVxuXHR9XG59XG5cblxuZnVuY3Rpb24gaW50X3Zhcl9nZW4oeCxuYW1lPW51bGwpIHsgXG4gIGxldCBvdXRwdXQgPSAoKT0+IHtcbiAgICBsZXQgb3V0ID0gVmFyKCBpbnQoeCksIG5hbWUsICdpbnQnICkgXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuZnVuY3Rpb24gZmxvYXRfdmFyX2dlbih4LG5hbWU9bnVsbCkgeyByZXR1cm4gKCk9PiB7IHJldHVybiBWYXIoIGZsb2F0KHgpLCBuYW1lLCAnZmxvYXQnICkgfSB9XG5cbmZ1bmN0aW9uIHZlYzJfdmFyX2dlbih4LCB5LG5hbWU9bnVsbCkgeyBcbiAgaWYoIHkgPT09IHVuZGVmaW5lZCApIHkgPSB4XG4gIHJldHVybiAoKT0+IFZhciggVmVjMih4LCB5KSwgbmFtZSAgKSBcbn1cblxuZnVuY3Rpb24gdmVjM192YXJfZ2VuKHg9MCwgeSwgeixuYW1lPW51bGwpIHsgXG4gIGlmKCB5ID09PSB1bmRlZmluZWQgKSB5ID0geFxuICBpZiggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHhcbiAgcmV0dXJuICgpPT4gVmFyKCBWZWMzKHgsIHksIHopLCBuYW1lICkgXG59XG5cbmZ1bmN0aW9uIHZlYzRfdmFyX2dlbiggeCwgeSwgeiwgdywgbmFtZT1udWxsICkgeyBcbiAgaWYoIHkgPT09IHVuZGVmaW5lZCApIHkgPSB4XG4gIGlmKCB6ID09PSB1bmRlZmluZWQgKSB6ID0geFxuICBpZiggdyA9PT0gdW5kZWZpbmVkICkgdyA9IHhcbiAgcmV0dXJuIFZhciggVmVjNCggeCwgeSwgeiwgdyApLCBuYW1lICkgXG59XG4vL2Z1bmN0aW9uIGZsb2F0X3Zhcl9nZW4oeCxuYW1lPW51bGwpIHsgcmV0dXJuICgpPT4geyByZXR1cm4gVmFyKCBmbG9hdCh4KSwgbmFtZSwgJ2Zsb2F0JyApIH0gfVxuXG4vL2Z1bmN0aW9uIHZlYzJfdmFyX2dlbih4LCB5LG5hbWU9bnVsbCkgeyByZXR1cm4gKCk9PiBWYXIoIFZlYzIoeCwgeSksIG5hbWUgICkgfVxuXG4vL2Z1bmN0aW9uIHZlYzNfdmFyX2dlbih4LCB5LCB6LG5hbWU9bnVsbCkgeyByZXR1cm4gKCk9PiBWYXIoIFZlYzMoeCwgeSwgeiksIG5hbWUgKSB9XG5cbi8vZnVuY3Rpb24gdmVjNF92YXJfZ2VuKCB4LCB5LCB6LCB3LCBuYW1lPW51bGwgKSB7IHJldHVybiBWYXIoIFZlYzQoIHgsIHksIHosIHcgKSwgbmFtZSApIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH1cblxuLypmdW5jdGlvbiBmbG9hdF92YXJfZ2VuKHgsbmFtZT1udWxsKSB7IHJldHVybiAoKT0+IHsgcmV0dXJuIFZhciggZmxvYXQoeCksIG5hbWUsICdmbG9hdCcgKSB9IH1cblxuZnVuY3Rpb24gdmVjMl92YXJfZ2VuKHgsIHksbmFtZT1udWxsKSB7IFxuICBpZiggeSA9PT0gdW5kZWZpbmVkICkgeSA9IHhcbiAgcmV0dXJuICgpPT4gVmFyKCBWZWMyKHgsIHkpLCBuYW1lICApIFxufVxuXG5mdW5jdGlvbiB2ZWMzX3Zhcl9nZW4oeCwgeSwgeixuYW1lPW51bGwpIHsgXG4gIGlmKCB5ID09PSB1bmRlZmluZWQgKSB5ID0geFxuICBpZiggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHhcbiAgcmV0dXJuICgpPT4gVmFyKCBWZWMzKHgsIHksIHopLCBuYW1lICkgXG59XG5cbmZ1bmN0aW9uIHZlYzRfdmFyX2dlbiggeCwgeSwgeiwgdywgbmFtZT1udWxsICkgeyBcbiAgaWYoIHkgPT09IHVuZGVmaW5lZCApIHkgPSB4XG4gIGlmKCB6ID09PSB1bmRlZmluZWQgKSB6ID0geFxuICBpZiggdyA9PT0gdW5kZWZpbmVkICkgdyA9IHhcbiAgcmV0dXJuIFZhciggVmVjNCggeCwgeSwgeiwgdyApLCBuYW1lICkgXG59XG4qL1xuIiwiY29uc3QgVmVjMiA9IGZ1bmN0aW9uICh4PTAsIHk9MCkge1xuICBjb25zdCB2ID0gT2JqZWN0LmNyZWF0ZSggVmVjMi5wcm90b3R5cGUgKVxuICB2LnggPSB4OyB2LnkgPSB5XG5cbiAgcmV0dXJuIHZcbn1cblxuVmVjMi5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICd2ZWMyJyxcblx0ZW1pdCgpIHsgcmV0dXJuIFwidmVjMihcIiArIHRoaXMueCArIFwiLFwiICsgdGhpcy55ICsgXCIpXCIgfSxcbiAgZW1pdF9kZWNsKCkgeyByZXR1cm4gXCJcIjsgfSxcbiAgY29weSgpIHtcbiAgICByZXR1cm4gVmVjMiggdGhpcy54LCB0aGlzLnkgKVxuICB9XG59XG5cbmNvbnN0IFZlYzMgPSBmdW5jdGlvbiAoeD0wLCB5LCB6KSB7XG4gIGNvbnN0IHYgPSBPYmplY3QuY3JlYXRlKCBWZWMzLnByb3RvdHlwZSApXG4gIGxldCB2eCA9MCx2eT0wLHZ6PTBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHYsIHtcbiAgICB4OiB7XG4gICAgICBnZXQoKSAgeyByZXR1cm4gdnggfSxcbiAgICAgIHNldCh2KSB7IHZ4ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICB9LFxuXG4gICAgeToge1xuICAgICAgZ2V0KCkgIHsgcmV0dXJuIHZ5IH0sXG4gICAgICBzZXQodikgeyB2eSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgfSxcblxuICAgIHo6IHtcbiAgICAgIGdldCgpICB7IHJldHVybiB2eiB9LFxuICAgICAgc2V0KHYpIHsgdnogPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfVxuICAgIH0sXG4gIH0pXG5cbiAgaWYoIHkgPT09IHVuZGVmaW5lZCAmJiB6ID09PSB1bmRlZmluZWQpIHtcbiAgICB2LnggPSB2LnkgPSB2LnogPSB4XG4gIH1lbHNle1xuICAgIHYueCA9IHg7IHYueSA9IHk7IHYueiA9IHo7XG4gIH1cbiBcbiAgdi5pc0dlbiA9IHYueC50eXBlID09PSAnc3RyaW5nJyB8fCB2LnkudHlwZSA9PT0gJ3N0cmluZycgfHwgdi56LnR5cGUgPT09ICdzdHJpbmcnXG4gIHJldHVybiB2XG59O1xuXG5WZWMzLnByb3RvdHlwZSA9IHtcbiAgdHlwZTogJ3ZlYzMnLFxuICBlbWl0KCkgeyBcbiAgICBsZXQgb3V0ID0gYHZlYzMoYFxuICAgIGxldCBwcmVmYWNlID0gJydcblxuICAgIGlmKCB0aGlzLngudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjb25zdCB4b3V0ID0gdGhpcy54LmVtaXQoKVxuICAgICAgb3V0ICs9IHhvdXQub3V0ICsgJywnXG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gdGhpcy54ICsgJywnXG4gICAgfVxuXG4gICAgaWYoIHRoaXMueS50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGNvbnN0IHlvdXQgPSB0aGlzLnkuZW1pdCgpXG4gICAgICBvdXQgKz0geW91dC5vdXQgKyAnLCcgXG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gdGhpcy55ICsgJywnXG4gICAgfVxuICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjb25zdCB6b3V0ID0gdGhpcy56LmVtaXQoKVxuICAgICAgb3V0ICs9IHpvdXQub3V0XG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gdGhpcy56IFxuICAgIH1cblxuICAgIG91dCArPSAnKSdcblxuICAgIHJldHVybiB7IG91dCwgcHJlZmFjZSB9XG4gIH0sXG4gIGVtaXRfZGVjbCgpIHsgXG4gICAgbGV0IG91dCA9ICcnXG4gICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIG91dCArPSB0aGlzLnguZW1pdF9kZWNsKClcbiAgICB9IFxuICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy54ICE9PSB0aGlzLnkgICkge1xuICAgICAgb3V0ICs9IHRoaXMueS5lbWl0X2RlY2woKVxuICAgIH0gXG4gICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnogIT09IHRoaXMueSAmJiB0aGlzLnogIT09IHRoaXMueCApIHtcbiAgICAgIG91dCArPSB0aGlzLnouZW1pdF9kZWNsKClcbiAgICB9IFxuICAgIHJldHVybiBvdXRcbiAgfSxcblxuXHR1cGRhdGVfbG9jYXRpb24oZ2wsIHByb2dyYW0pIHtcbiAgICBpZiggdGhpcy5pc0dlbiApIHtcbiAgICAgIGlmKCB0aGlzLngudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMueC51cGRhdGVfbG9jYXRpb24oZ2wscHJvZ3JhbSlcbiAgICAgIH0gXG4gICAgICBpZiggdGhpcy55LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueCAhPT0gdGhpcy55ICApIHtcbiAgICAgICAgdGhpcy55LnVwZGF0ZV9sb2NhdGlvbihnbCxwcm9ncmFtKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy56ICE9PSB0aGlzLnkgJiYgdGhpcy56ICE9PSB0aGlzLnggKSB7XG4gICAgICAgIHRoaXMuei51cGRhdGVfbG9jYXRpb24oZ2wscHJvZ3JhbSlcbiAgICAgIH0gICAgICBcbiAgICB9XG4gIH0sXG4gIFxuICB1cGxvYWRfZGF0YShnbCkge1xuICAgIGlmKCB0aGlzLmlzR2VuICkge1xuICAgICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgdGhpcy54LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy54ICE9PSB0aGlzLnkgICkge1xuICAgICAgICB0aGlzLnkudXBsb2FkX2RhdGEoZ2wpXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnogIT09IHRoaXMueSAmJiB0aGlzLnogIT09IHRoaXMueCApIHtcbiAgICAgICAgdGhpcy56LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSAgICAgIFxuICAgIH1cbiAgfSxcblxuICBjb3B5KCkge1xuICAgIHJldHVybiBWZWMzKCB0aGlzLngsIHRoaXMueSwgdGhpcy56IClcbiAgfVxuXG59XG5cbmNvbnN0IFZlYzQgPSBmdW5jdGlvbiAoeD0wLCB5LCB6KSB7XG4gIGNvbnN0IHYgPSBPYmplY3QuY3JlYXRlKCBWZWM0LnByb3RvdHlwZSApXG5cbiAgaWYoIHkgPT09IHVuZGVmaW5lZCAmJiB6ID09PSB1bmRlZmluZWQpIHtcbiAgICB2LnggPSB2LnkgPSB2LnogPSB4XG4gIH1lbHNle1xuICAgIHYueCA9IHg7IHYueSA9IHk7IHYueiA9IHo7XG4gIH1cblxuICB2LmlzR2VuID0gdi54LnR5cGUgPT09ICdzdHJpbmcnIHx8IHYueS50eXBlID09PSAnc3RyaW5nJyB8fCB2LnoudHlwZSA9PT0gJ3N0cmluZydcblxuICByZXR1cm4gdlxufTtcblxuVmVjNC5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICd2ZWM0JyxcbiAgZW1pdCgpIHsgXG4gICAgbGV0IG91dCA9IGB2ZWM0KGBcbiAgICBsZXQgcHJlZmFjZSA9ICcnXG5cbiAgICBpZiggdGhpcy54LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgY29uc3QgeG91dCA9IHRoaXMueC5lbWl0KClcbiAgICAgIG91dCArPSB4b3V0Lm91dCArICcsJ1xuICAgIH1lbHNle1xuICAgICAgb3V0ICs9IHRoaXMueCArICcsJ1xuICAgIH1cblxuICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjb25zdCB5b3V0ID0gdGhpcy55LmVtaXQoKVxuICAgICAgb3V0ICs9IHlvdXQub3V0ICsgJywnIFxuICAgIH1lbHNle1xuICAgICAgb3V0ICs9IHRoaXMueSArICcsJ1xuICAgIH1cblxuICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjb25zdCB6b3V0ID0gdGhpcy56LmVtaXQoKVxuICAgICAgb3V0ICs9IHpvdXQub3V0XG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gdGhpcy56IFxuICAgIH1cbiAgICBcbiAgICBpZiggdGhpcy53LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgY29uc3Qgd291dCA9IHRoaXMudy5lbWl0KClcbiAgICAgIG91dCArPSB3b3V0Lm91dFxuICAgIH1lbHNle1xuICAgICAgb3V0ICs9IHRoaXMudyBcbiAgICB9XG5cbiAgICBvdXQgKz0gJyknXG5cbiAgICByZXR1cm4geyBvdXQsIHByZWZhY2UgfVxuICB9LFxuICBlbWl0X2RlY2woKSB7IFxuICAgIGxldCBvdXQgPSAnJ1xuICAgIGlmKCB0aGlzLngudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBvdXQgKz0gdGhpcy54LmVtaXRfZGVjbCgpXG4gICAgfSBcbiAgICBpZiggdGhpcy55LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueCAhPT0gdGhpcy55ICApIHtcbiAgICAgIG91dCArPSB0aGlzLnkuZW1pdF9kZWNsKClcbiAgICB9IFxuICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy56ICE9PSB0aGlzLnkgJiYgdGhpcy56ICE9PSB0aGlzLnggKSB7XG4gICAgICBvdXQgKz0gdGhpcy56LmVtaXRfZGVjbCgpXG4gICAgfSBcbiAgICBpZiggdGhpcy53LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMudyAhPT0gdGhpcy55ICYmIHRoaXMudyAhPT0gdGhpcy54ICYmIHRoaXMudyAhPT0gdGhpcy56ICkge1xuICAgICAgb3V0ICs9IHRoaXMudy5lbWl0X2RlY2woKVxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH0sXG5cblx0dXBkYXRlX2xvY2F0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgaWYoIHRoaXMuaXNHZW4gKSB7XG4gICAgICBpZiggdGhpcy54LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgICB0aGlzLngudXBkYXRlX2xvY2F0aW9uKGdsLHByb2dyYW0pXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMueS50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnggIT09IHRoaXMueSAgKSB7XG4gICAgICAgIHRoaXMueS51cGRhdGVfbG9jYXRpb24oZ2wscHJvZ3JhbSlcbiAgICAgIH0gXG4gICAgICBpZiggdGhpcy56LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueiAhPT0gdGhpcy55ICYmIHRoaXMueiAhPT0gdGhpcy54ICkge1xuICAgICAgICB0aGlzLnoudXBkYXRlX2xvY2F0aW9uKGdsLHByb2dyYW0pXG4gICAgICB9ICAgICAgXG4gICAgICBpZiggdGhpcy53LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMudyAhPT0gdGhpcy55ICYmIHRoaXMudyAhPT0gdGhpcy54ICYmIHRoaXMudyAhPT0gdGhpcy56ICkge1xuICAgICAgICB0aGlzLncudXBkYXRlX2xvY2F0aW9uKGdsLHByb2dyYW0pXG4gICAgICB9ICBcbiAgICB9XG4gIH0sXG4gIFxuICB1cGxvYWRfZGF0YShnbCkge1xuICAgIGlmKCB0aGlzLmlzR2VuICkge1xuICAgICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgdGhpcy54LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy54ICE9PSB0aGlzLnkgICkge1xuICAgICAgICB0aGlzLnkudXBsb2FkX2RhdGEoZ2wpXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnogIT09IHRoaXMueSAmJiB0aGlzLnogIT09IHRoaXMueCApIHtcbiAgICAgICAgdGhpcy56LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLncudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy53ICE9PSB0aGlzLnkgJiYgdGhpcy53ICE9PSB0aGlzLnggJiYgdGhpcy53ICE9PSB0aGlzLnogKSB7XG4gICAgICAgIHRoaXMudy51cGxvYWRfZGF0YShnbClcbiAgICAgIH0gICAgICBcbiAgICB9XG4gIH0sXG5cbiAgY29weSgpIHtcbiAgICByZXR1cm4gVmVjNCggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53IClcbiAgfVxufVxuLy8gVmVjNFxuXG4vL2xldCBWZWM0ID0gZnVuY3Rpb24gKHgsIHksIHosIHcpIHtcbi8vICBjb25zdCB2ID0gT2JqZWN0LmNyZWF0ZSggVmVjNC5wcm90b3R5cGUgKVxuLy8gIHYueCA9IHg7IHYueSA9IHk7IHYueiA9IHo7IHYudyA9IHdcblxuLy8gIHJldHVybiB2XG4vL307XG5cbi8vVmVjNC5wcm90b3R5cGUgPSB7XG4vLyAgdHlwZTogJ3ZlYzQnLFxuLy8gIGVtaXQoKSB7IHJldHVybiBcInZlYzQoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiLFwiICsgdGhpcy56ICsgXCIsXCIgKyB0aGlzLncgKyBcIilcIjsgfSxcbi8vICBlbWl0X2RlY2woKSB7IHJldHVybiBcIlwiOyB9XG4vL31cblxuXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgVmVjMiwgVmVjMywgVmVjNCB9IFxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApLFxuICAgICAgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKSxcbiAgICAgIHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuLCBpbnRfdmFyX2dlbiwgVmFyQWxsb2MgfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuXG5jb25zdCBWaWduZXR0ZSA9IGZ1bmN0aW9uKCBTY2VuZSwgU0RGICkge1xuXG4gIGNvbnN0IFZnbiA9IGZ1bmN0aW9uKCByYWRpdXM9MC4xLCBzbW9vdGhuZXNzPS4xICkge1xuICAgIGNvbnN0IHZnbiA9IE9iamVjdC5jcmVhdGUoIFZnbi5wcm90b3R5cGUgKVxuICAgIGNvbnN0IF9fcmFkaXVzID0gcGFyYW1fd3JhcCggcmFkaXVzLCBmbG9hdF92YXJfZ2VuKCByYWRpdXMgKSApICBcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHZnbiwgJ3JhZGl1cycsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIF9fcmFkaXVzIH0sXG4gICAgICBzZXQoIHYgKSB7XG4gICAgICAgIF9fcmFkaXVzLnNldCggdiApXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IF9fc21vb3RobmVzcyA9IHBhcmFtX3dyYXAoIHNtb290aG5lc3MsIGZsb2F0X3Zhcl9nZW4oIHNtb290aG5lc3MgKSApICBcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHZnbiwgJ3Ntb290aG5lc3MnLCB7XG4gICAgICBnZXQoKSB7IHJldHVybiBfX3Ntb290aG5lc3MgfSxcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgX19zbW9vdGhuZXNzLnNldCggdiApXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAvLyB0aGlzIHJlZmVycyB0byB0aGUgY3VycmVudCBzY2VuZSB2aWEgaW1wbGljaXQgYmluZGluZyBpbiBzY2VuZS5qc1xuICAgIHRoaXMucG9zdHByb2Nlc3NpbmcucHVzaCggdmduIClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBWZ24ucHJvdG90eXBlID0gU2NlbmVOb2RlKClcbiBcbiAgT2JqZWN0LmFzc2lnbiggVmduLnByb3RvdHlwZSwge1xuICAgIGVtaXQoKSB7XG4gICAgICByZXR1cm4gYCAgY29sb3IgKj0gdmlnbmV0dGUoIHZfdXYsICR7dGhpcy5yYWRpdXMuZW1pdCgpfSwgJHt0aGlzLnNtb290aG5lc3MuZW1pdCgpfSApO2BcbiAgICB9LFxuICAgXG4gICAgZW1pdF9kZWNsKCkge1xuICAgICAgbGV0IHN0ciA9IHRoaXMucmFkaXVzLmVtaXRfZGVjbCgpICsgdGhpcy5zbW9vdGhuZXNzLmVtaXRfZGVjbCgpXG4gICAgICAvLyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3ItbHllaC1hcmNoaXZlZC8xNzBiNTNmY2RjMGUxN2FmY2YxNVxuICAgICAgLy8gb3JpZ2luYWxseSBpcVxuICAgICAgY29uc3QgcHJlZmFjZSA9IGAgIGZsb2F0IHZpZ25ldHRlKHZlYzIgdXYsIGZsb2F0IHJhZGl1cywgZmxvYXQgc21vb3RobmVzcykge1xuICAgICAgICByZXR1cm4gcmFkaXVzICsgMC41KjE2LjAqdXYueCp1di55KigxLjAtdXYueCkqKDEuMC11di55KTsgXG4gICAgICB9XG4gIGBcbiAgICAgIGlmKCBTREYubWVtby52Z24gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgc3RyID0gc3RyICsgcHJlZmFjZVxuICAgICAgICBTREYubWVtby52Z24gPSB0cnVlXG4gICAgICB9ZWxzZXtcbiAgICAgICAgc3RyID0gJydcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0clxuICAgIH0sXG5cbiAgICB1cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgdGhpcy5yYWRpdXMudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICB0aGlzLnNtb290aG5lc3MudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCApIHtcbiAgICAgIHRoaXMucmFkaXVzLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICB0aGlzLnNtb290aG5lc3MudXBsb2FkX2RhdGEoIGdsIClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIFZnblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZ25ldHRlIFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKipcbiAqIEJpdCB0d2lkZGxpbmcgaGFja3MgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQXV0aG9yOiBNaWtvbGEgTHlzZW5rb1xuICpcbiAqIFBvcnRlZCBmcm9tIFN0YW5mb3JkIGJpdCB0d2lkZGxpbmcgaGFjayBsaWJyYXJ5OlxuICogICAgaHR0cDovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbi8vTnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50ZWdlclxudmFyIElOVF9CSVRTID0gMzI7XG5cbi8vQ29uc3RhbnRzXG5leHBvcnRzLklOVF9CSVRTICA9IElOVF9CSVRTO1xuZXhwb3J0cy5JTlRfTUFYICAgPSAgMHg3ZmZmZmZmZjtcbmV4cG9ydHMuSU5UX01JTiAgID0gLTE8PChJTlRfQklUUy0xKTtcblxuLy9SZXR1cm5zIC0xLCAwLCArMSBkZXBlbmRpbmcgb24gc2lnbiBvZiB4XG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAodiA+IDApIC0gKHYgPCAwKTtcbn1cblxuLy9Db21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBpbnRlZ2VyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIG1hc2sgPSB2ID4+IChJTlRfQklUUy0xKTtcbiAgcmV0dXJuICh2IF4gbWFzaykgLSBtYXNrO1xufVxuXG4vL0NvbXB1dGVzIG1pbmltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB5IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ29tcHV0ZXMgbWF4aW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHggXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9DaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d29cbmV4cG9ydHMuaXNQb3cyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gISh2ICYgKHYtMSkpICYmICghIXYpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDIgb2YgdlxuZXhwb3J0cy5sb2cyID0gZnVuY3Rpb24odikge1xuICB2YXIgciwgc2hpZnQ7XG4gIHIgPSAgICAgKHYgPiAweEZGRkYpIDw8IDQ7IHYgPj4+PSByO1xuICBzaGlmdCA9ICh2ID4gMHhGRiAgKSA8PCAzOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweEYgICApIDw8IDI7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4MyAgICkgPDwgMTsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8ICh2ID4+IDEpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDEwIG9mIHZcbmV4cG9ydHMubG9nMTAgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKHYgPj0gMTAwMDAwMDAwMCkgPyA5IDogKHYgPj0gMTAwMDAwMDAwKSA/IDggOiAodiA+PSAxMDAwMDAwMCkgPyA3IDpcbiAgICAgICAgICAodiA+PSAxMDAwMDAwKSA/IDYgOiAodiA+PSAxMDAwMDApID8gNSA6ICh2ID49IDEwMDAwKSA/IDQgOlxuICAgICAgICAgICh2ID49IDEwMDApID8gMyA6ICh2ID49IDEwMCkgPyAyIDogKHYgPj0gMTApID8gMSA6IDA7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiBiaXRzXG5leHBvcnRzLnBvcENvdW50ID0gZnVuY3Rpb24odikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKHYpIHtcbiAgdmFyIGMgPSAzMjtcbiAgdiAmPSAtdjtcbiAgaWYgKHYpIGMtLTtcbiAgaWYgKHYgJiAweDAwMDBGRkZGKSBjIC09IDE2O1xuICBpZiAodiAmIDB4MDBGRjAwRkYpIGMgLT0gODtcbiAgaWYgKHYgJiAweDBGMEYwRjBGKSBjIC09IDQ7XG4gIGlmICh2ICYgMHgzMzMzMzMzMykgYyAtPSAyO1xuICBpZiAodiAmIDB4NTU1NTU1NTUpIGMgLT0gMTtcbiAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNvdW50VHJhaWxpbmdaZXJvcyA9IGNvdW50VHJhaWxpbmdaZXJvcztcblxuLy9Sb3VuZHMgdG8gbmV4dCBwb3dlciBvZiAyXG5leHBvcnRzLm5leHRQb3cyID0gZnVuY3Rpb24odikge1xuICB2ICs9IHYgPT09IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5cbi8vUm91bmRzIGRvd24gdG8gcHJldmlvdXMgcG93ZXIgb2YgMlxuZXhwb3J0cy5wcmV2UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiAtICh2Pj4+MSk7XG59XG5cbi8vQ29tcHV0ZXMgcGFyaXR5IG9mIHdvcmRcbmV4cG9ydHMucGFyaXR5ID0gZnVuY3Rpb24odikge1xuICB2IF49IHYgPj4+IDE2O1xuICB2IF49IHYgPj4+IDg7XG4gIHYgXj0gdiA+Pj4gNDtcbiAgdiAmPSAweGY7XG4gIHJldHVybiAoMHg2OTk2ID4+PiB2KSAmIDE7XG59XG5cbnZhciBSRVZFUlNFX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbihmdW5jdGlvbih0YWIpIHtcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyArK2kpIHtcbiAgICB2YXIgdiA9IGksIHIgPSBpLCBzID0gNztcbiAgICBmb3IgKHYgPj4+PSAxOyB2OyB2ID4+Pj0gMSkge1xuICAgICAgciA8PD0gMTtcbiAgICAgIHIgfD0gdiAmIDE7XG4gICAgICAtLXM7XG4gICAgfVxuICAgIHRhYltpXSA9IChyIDw8IHMpICYgMHhmZjtcbiAgfVxufSkoUkVWRVJTRV9UQUJMRSk7XG5cbi8vUmV2ZXJzZSBiaXRzIGluIGEgMzIgYml0IHdvcmRcbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAoUkVWRVJTRV9UQUJMRVsgdiAgICAgICAgICYgMHhmZl0gPDwgMjQpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gOCkgICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgIHxcbiAgICAgICAgICAgUkVWRVJTRV9UQUJMRVsodiA+Pj4gMjQpICYgMHhmZl07XG59XG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDIgY29vcmRpbmF0ZXMgd2l0aCAxNiBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IHF1YWR0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUyID0gZnVuY3Rpb24oeCwgeSkge1xuICB4ICY9IDB4RkZGRjtcbiAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICB5ICY9IDB4RkZGRjtcbiAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vL0V4dHJhY3RzIHRoZSBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50XG5leHBvcnRzLmRlaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgJiAweDU1NTU1NTU1O1xuICB2ID0gKHYgfCAodiA+Pj4gMSkpICAmIDB4MzMzMzMzMzM7XG4gIHYgPSAodiB8ICh2ID4+PiAyKSkgICYgMHgwRjBGMEYwRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDQpKSAgJiAweDAwRkYwMEZGO1xuICB2ID0gKHYgfCAodiA+Pj4gMTYpKSAmIDB4MDAwRkZGRjtcbiAgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjtcbn1cblxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAzIGNvb3JkaW5hdGVzLCBlYWNoIHdpdGggMTAgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBvY3RyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHggJj0gMHgzRkY7XG4gIHggID0gKHggfCAoeDw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHggID0gKHggfCAoeDw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeCAgPSAoeCB8ICh4PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeCAgPSAoeCB8ICh4PDwyKSkgICYgMTIyNzEzMzUxMztcblxuICB5ICY9IDB4M0ZGO1xuICB5ICA9ICh5IHwgKHk8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB5ICA9ICh5IHwgKHk8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHkgID0gKHkgfCAoeTw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHkgID0gKHkgfCAoeTw8MikpICAmIDEyMjcxMzM1MTM7XG4gIHggfD0gKHkgPDwgMSk7XG4gIFxuICB6ICY9IDB4M0ZGO1xuICB6ICA9ICh6IHwgKHo8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB6ICA9ICh6IHwgKHo8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHogID0gKHogfCAoejw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHogID0gKHogfCAoejw8MikpICAmIDEyMjcxMzM1MTM7XG4gIFxuICByZXR1cm4geCB8ICh6IDw8IDIpO1xufVxuXG4vL0V4dHJhY3RzIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnQgb2YgYSAzLXR1cGxlXG5leHBvcnRzLmRlaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgICAgICAgJiAxMjI3MTMzNTEzO1xuICB2ID0gKHYgfCAodj4+PjIpKSAgICYgMzI3MjM1NjAzNTtcbiAgdiA9ICh2IHwgKHY+Pj40KSkgICAmIDI1MTcxOTY5NTtcbiAgdiA9ICh2IHwgKHY+Pj44KSkgICAmIDQyNzgxOTAzMzU7XG4gIHYgPSAodiB8ICh2Pj4+MTYpKSAgJiAweDNGRjtcbiAgcmV0dXJuICh2PDwyMik+PjIyO1xufVxuXG4vL0NvbXB1dGVzIG5leHQgY29tYmluYXRpb24gaW4gY29sZXhpY29ncmFwaGljIG9yZGVyICh0aGlzIGlzIG1pc3Rha2VubHkgY2FsbGVkIG5leHRQZXJtdXRhdGlvbiBvbiB0aGUgYml0IHR3aWRkbGluZyBoYWNrcyBwYWdlKVxuZXhwb3J0cy5uZXh0Q29tYmluYXRpb24gPSBmdW5jdGlvbih2KSB7XG4gIHZhciB0ID0gdiB8ICh2IC0gMSk7XG4gIHJldHVybiAodCArIDEpIHwgKCgofnQgJiAtfnQpIC0gMSkgPj4+IChjb3VudFRyYWlsaW5nWmVyb3ModikgKyAxKSk7XG59XG5cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNyZWF0ZVRodW5rID0gcmVxdWlyZShcIi4vbGliL3RodW5rLmpzXCIpXG5cbmZ1bmN0aW9uIFByb2NlZHVyZSgpIHtcbiAgdGhpcy5hcmdUeXBlcyA9IFtdXG4gIHRoaXMuc2hpbUFyZ3MgPSBbXVxuICB0aGlzLmFycmF5QXJncyA9IFtdXG4gIHRoaXMuYXJyYXlCbG9ja0luZGljZXMgPSBbXVxuICB0aGlzLnNjYWxhckFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ0luZGV4ID0gW11cbiAgdGhpcy5pbmRleEFyZ3MgPSBbXVxuICB0aGlzLnNoYXBlQXJncyA9IFtdXG4gIHRoaXMuZnVuY05hbWUgPSBcIlwiXG4gIHRoaXMucHJlID0gbnVsbFxuICB0aGlzLmJvZHkgPSBudWxsXG4gIHRoaXMucG9zdCA9IG51bGxcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDd2lzZSh1c2VyX2FyZ3MpIHtcbiAgLy9DcmVhdGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jID0gbmV3IFByb2NlZHVyZSgpXG4gIFxuICAvL1BhcnNlIGJsb2Nrc1xuICBwcm9jLnByZSAgICA9IHVzZXJfYXJncy5wcmVcbiAgcHJvYy5ib2R5ICAgPSB1c2VyX2FyZ3MuYm9keVxuICBwcm9jLnBvc3QgICA9IHVzZXJfYXJncy5wb3N0XG5cbiAgLy9QYXJzZSBhcmd1bWVudHNcbiAgdmFyIHByb2NfYXJncyA9IHVzZXJfYXJncy5hcmdzLnNsaWNlKDApXG4gIHByb2MuYXJnVHlwZXMgPSBwcm9jX2FyZ3NcbiAgZm9yKHZhciBpPTA7IGk8cHJvY19hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGFyZ190eXBlID0gcHJvY19hcmdzW2ldXG4gICAgaWYoYXJnX3R5cGUgPT09IFwiYXJyYXlcIiB8fCAodHlwZW9mIGFyZ190eXBlID09PSBcIm9iamVjdFwiICYmIGFyZ190eXBlLmJsb2NrSW5kaWNlcykpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcImFycmF5XCJcbiAgICAgIHByb2MuYXJyYXlBcmdzLnB1c2goaSlcbiAgICAgIHByb2MuYXJyYXlCbG9ja0luZGljZXMucHVzaChhcmdfdHlwZS5ibG9ja0luZGljZXMgPyBhcmdfdHlwZS5ibG9ja0luZGljZXMgOiAwKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwiYXJyYXlcIiArIGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNjYWxhclwiKSB7XG4gICAgICBwcm9jLnNjYWxhckFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwic2NhbGFyXCIgKyBpKVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJpbmRleFwiKSB7XG4gICAgICBwcm9jLmluZGV4QXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2hhcGVcIikge1xuICAgICAgcHJvYy5zaGFwZUFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUub2Zmc2V0KSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJvZmZzZXRcIlxuICAgICAgcHJvYy5vZmZzZXRBcmdzLnB1c2goeyBhcnJheTogYXJnX3R5cGUuYXJyYXksIG9mZnNldDphcmdfdHlwZS5vZmZzZXQgfSlcbiAgICAgIHByb2Mub2Zmc2V0QXJnSW5kZXgucHVzaChpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVW5rbm93biBhcmd1bWVudCB0eXBlIFwiICsgcHJvY19hcmdzW2ldKVxuICAgIH1cbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGFycmF5IGFyZ3VtZW50IHdhcyBzcGVjaWZpZWRcbiAgaWYocHJvYy5hcnJheUFyZ3MubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTm8gYXJyYXkgYXJndW1lbnRzIHNwZWNpZmllZFwiKVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhcmd1bWVudHMgYXJlIGNvcnJlY3RcbiAgaWYocHJvYy5wcmUuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwcmUoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MuYm9keS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MucG9zdC5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHBvc3QoKSBibG9ja1wiKVxuICB9XG5cbiAgLy9DaGVjayBkZWJ1ZyBmbGFnXG4gIHByb2MuZGVidWcgPSAhIXVzZXJfYXJncy5wcmludENvZGUgfHwgISF1c2VyX2FyZ3MuZGVidWdcbiAgXG4gIC8vUmV0cmlldmUgbmFtZVxuICBwcm9jLmZ1bmNOYW1lID0gdXNlcl9hcmdzLmZ1bmNOYW1lIHx8IFwiY3dpc2VcIlxuICBcbiAgLy9SZWFkIGluIGJsb2NrIHNpemVcbiAgcHJvYy5ibG9ja1NpemUgPSB1c2VyX2FyZ3MuYmxvY2tTaXplIHx8IDY0XG5cbiAgcmV0dXJuIGNyZWF0ZVRodW5rKHByb2MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUN3aXNlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbi8vIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIHZlcnkgc2ltcGxlIGxvb3BzIGFuYWxvZ291cyB0byBob3cgeW91IHR5cGljYWxseSB0cmF2ZXJzZSBhcnJheXMgKHRoZSBvdXRlcm1vc3QgbG9vcCBjb3JyZXNwb25kcyB0byB0aGUgc2xvd2VzdCBjaGFuZ2luZyBpbmRleCwgdGhlIGlubmVybW9zdCBsb29wIHRvIHRoZSBmYXN0ZXN0IGNoYW5naW5nIGluZGV4KVxuLy8gVE9ETzogSWYgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIHN0cmlkZXMgKGFuZCBvZmZzZXRzKSB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIGRlY3JlYXNpbmcgdGhlIG51bWJlciBvZiBcInBvaW50ZXJzXCIgYW5kIHJlbGF0ZWQgdmFyaWFibGVzLiBUaGUgZHJhd2JhY2sgaXMgdGhhdCB0aGUgdHlwZSBzaWduYXR1cmUgd291bGQgYmVjb21lIG1vcmUgc3BlY2lmaWMgYW5kIHRoYXQgdGhlcmUgd291bGQgdGh1cyBiZSBsZXNzIHBvdGVudGlhbCBmb3IgY2FjaGluZywgYnV0IGl0IG1pZ2h0IHN0aWxsIGJlIHdvcnRoIGl0LCBlc3BlY2lhbGx5IHdoZW4gZGVhbGluZyB3aXRoIGxhcmdlIG51bWJlcnMgb2YgYXJndW1lbnRzLlxuZnVuY3Rpb24gaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGg+MFxuICAgICwgY29kZSA9IFtdXG4gICAgLCB2YXJzID0gW11cbiAgICAsIGlkeD0wLCBwaWR4PTAsIGksIGpcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkgeyAvLyBJdGVyYXRpb24gdmFyaWFibGVzXG4gICAgdmFycy5wdXNoKFtcImlcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL0NvbXB1dGUgc2NhbiBkZWx0YXNcbiAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgcGlkeCA9IGlkeFxuICAgICAgaWR4ID0gb3JkZXJbaV1cbiAgICAgIGlmKGkgPT09IDApIHsgLy8gVGhlIGlubmVybW9zdC9mYXN0ZXN0IGRpbWVuc2lvbidzIGRlbHRhIGlzIHNpbXBseSBpdHMgc3RyaWRlXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPXRcIixqLFwicFwiLGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH0gZWxzZSB7IC8vIEZvciBvdGhlciBkaW1lbnNpb25zIHRoZSBkZWx0YSBpcyBiYXNpY2FsbHkgdGhlIHN0cmlkZSBtaW51cyBzb21ldGhpbmcgd2hpY2ggZXNzZW50aWFsbHkgXCJyZXdpbmRzXCIgdGhlIHByZXZpb3VzIChtb3JlIGlubmVyKSBkaW1lbnNpb25cbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9KHRcIixqLFwicFwiLGlkeCxcIi1zXCIscGlkeCxcIip0XCIsaixcInBcIixwaWR4LFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmFycy5sZW5ndGggPiAwKSB7XG4gICAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgfSAgXG4gIC8vU2NhbiBsb29wXG4gIGZvcihpPWRpbWVuc2lvbi0xOyBpPj0wOyAtLWkpIHsgLy8gU3RhcnQgYXQgbGFyZ2VzdCBzdHJpZGUgYW5kIHdvcmsgeW91ciB3YXkgaW53YXJkc1xuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9QdXNoIGJvZHkgb2YgaW5uZXIgbG9vcFxuICBjb2RlLnB1c2goYm9keSlcbiAgLy9BZHZhbmNlIHNjYW4gcG9pbnRlcnNcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHBpZHggPSBpZHhcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGlmKGkgPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixwaWR4LFwiXS09c1wiLHBpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vIEdlbmVyYXRlIFwib3V0ZXJcIiBsb29wcyB0aGF0IGxvb3Agb3ZlciBibG9ja3Mgb2YgZGF0YSwgYXBwbHlpbmcgXCJpbm5lclwiIGxvb3BzIHRvIHRoZSBibG9ja3MgYnkgbWFuaXB1bGF0aW5nIHRoZSBsb2NhbCB2YXJpYWJsZXMgaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBpbm5lciBsb29wIG9ubHkgXCJzZWVzXCIgdGhlIGN1cnJlbnQgYmxvY2suXG4vLyBUT0RPOiBJZiB0aGlzIGlzIHVzZWQsIHRoZW4gdGhlIHByZXZpb3VzIGRlY2xhcmF0aW9uIChkb25lIGJ5IGdlbmVyYXRlQ3dpc2VPcCkgb2YgcyogaXMgZXNzZW50aWFsbHkgdW5uZWNlc3NhcnkuXG4vLyAgICAgICBJIGJlbGlldmUgdGhlIHMqIGFyZSBub3QgdXNlZCBlbHNld2hlcmUgKGluIHBhcnRpY3VsYXIsIEkgZG9uJ3QgdGhpbmsgdGhleSdyZSB1c2VkIGluIHRoZSBwcmUvcG9zdCBwYXJ0cyBhbmQgXCJzaGFwZVwiIGlzIGRlZmluZWQgaW5kZXBlbmRlbnRseSksIHNvIGl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIG1ha2UgZGVmaW5pbmcgdGhlIHMqIGRlcGVuZGVudCBvbiB3aGF0IGxvb3AgbWV0aG9kIGlzIGJlaW5nIHVzZWQuXG5mdW5jdGlvbiBvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGJsb2NrU2l6ZSA9IHByb2MuYmxvY2tTaXplXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwXG4gICAgLCBjb2RlID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJ2YXIgb2Zmc2V0XCIsaSxcIj1wXCIsaV0uam9pbihcIlwiKSlcbiAgfVxuICAvL0dlbmVyYXRlIGxvb3BzIGZvciB1bm1hdGNoZWQgZGltZW5zaW9uc1xuICAvLyBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgZGltZW5zaW9ucyBhcmUgdHJhdmVyc2VkIGlzIGZhaXJseSBhcmJpdHJhcnkgKGZyb20gc21hbGwgc3RyaWRlIHRvIGxhcmdlIHN0cmlkZSwgZm9yIHRoZSBmaXJzdCBhcmd1bWVudClcbiAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSBpZiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgbG9vcHMgYXJlIHBsYWNlZCB3b3VsZCBhbHNvIGJlIHNvbWVob3cgXCJvcHRpbWFsXCIgKGF0IHRoZSB2ZXJ5IGxlYXN0IHdlIHNob3VsZCBjaGVjayB0aGF0IGl0IHJlYWxseSBkb2Vzbid0IGh1cnQgdXMgaWYgdGhleSdyZSBub3QpLlxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJmb3IodmFyIGpcIitpK1wiPVNTW1wiLCBvcmRlcltpXSwgXCJdfDA7alwiLCBpLCBcIj4wOyl7XCJdLmpvaW4oXCJcIikpIC8vIEl0ZXJhdGUgYmFjayB0byBmcm9udFxuICAgIGNvZGUucHVzaChbXCJpZihqXCIsaSxcIjxcIixibG9ja1NpemUsXCIpe1wiXS5qb2luKFwiXCIpKSAvLyBFaXRoZXIgZGVjcmVhc2UgaiBieSBibG9ja1NpemUgKHMgPSBibG9ja1NpemUpLCBvciBzZXQgaXQgdG8gemVybyAoYWZ0ZXIgc2V0dGluZyBzID0gaikuXG4gICAgY29kZS5wdXNoKFtcInNcIixvcmRlcltpXSxcIj1qXCIsaV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIi09XCIsYmxvY2tTaXplLFwifVwiXS5qb2luKFwiXCIpKVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIHZhciBpbmRleFN0ciA9IFtcIm9mZnNldFwiK2ldXG4gICAgZm9yKHZhciBqPW1hdGNoZWQ7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJwXCIsb3JkZXJbal1dLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJwXCIsaSxcIj0oXCIsaW5kZXhTdHIuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgY29kZS5wdXNoKGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkpXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy9Db3VudCB0aGUgbnVtYmVyIG9mIGNvbXBhdGlibGUgaW5uZXIgb3JkZXJzXG4vLyBUaGlzIGlzIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3QgY29tbW9uIHByZWZpeCBvZiB0aGUgYXJyYXlzIGluIG9yZGVycy5cbi8vIEVhY2ggYXJyYXkgaW4gb3JkZXJzIGxpc3RzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb3JyZXNwb25kIG5kYXJyYXkgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyBzdHJpZGUuXG4vLyBUaGlzIGlzIHRodXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhhdCBjYW4gYmUgZWZmaWNpZW50bHkgdHJhdmVyc2VkIGJ5IHNpbXBsZSBuZXN0ZWQgbG9vcHMgZm9yIGFsbCBhcnJheXMuXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XG4gIHZhciBtYXRjaGVkID0gMCwgZGltZW5zaW9uID0gb3JkZXJzWzBdLmxlbmd0aFxuICB3aGlsZShtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvcmRlcnNbal1bbWF0Y2hlZF0gIT09IG9yZGVyc1swXVttYXRjaGVkXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFxuICAgICAgfVxuICAgIH1cbiAgICArK21hdGNoZWRcbiAgfVxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vL1Byb2Nlc3NlcyBhIGJsb2NrIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGF0YSB0eXBlc1xuLy8gUmVwbGFjZXMgdmFyaWFibGUgbmFtZXMgYnkgZGlmZmVyZW50IG9uZXMsIGVpdGhlciBcImxvY2FsXCIgb25lcyAodGhhdCBhcmUgdGhlbiBmZXJyaWVkIGluIGFuZCBvdXQgb2YgdGhlIGdpdmVuIGFycmF5KSBvciBvbmVzIG1hdGNoaW5nIHRoZSBhcmd1bWVudHMgdGhhdCB0aGUgZnVuY3Rpb24gcGVyZm9ybWluZyB0aGUgdWx0aW1hdGUgbG9vcCB3aWxsIGFjY2VwdC5cbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaywgcHJvYywgZHR5cGVzKSB7XG4gIHZhciBjb2RlID0gYmxvY2suYm9keVxuICB2YXIgcHJlID0gW11cbiAgdmFyIHBvc3QgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxibG9jay5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNhcmcgPSBibG9jay5hcmdzW2ldXG4gICAgaWYoY2FyZy5jb3VudCA8PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGNhcmcubmFtZSwgXCJnXCIpXG4gICAgdmFyIHB0clN0ciA9IFwiXCJcbiAgICB2YXIgYXJyTnVtID0gcHJvYy5hcnJheUFyZ3MuaW5kZXhPZihpKVxuICAgIHN3aXRjaChwcm9jLmFyZ1R5cGVzW2ldKSB7XG4gICAgICBjYXNlIFwib2Zmc2V0XCI6XG4gICAgICAgIHZhciBvZmZBcmdJbmRleCA9IHByb2Mub2Zmc2V0QXJnSW5kZXguaW5kZXhPZihpKVxuICAgICAgICB2YXIgb2ZmQXJnID0gcHJvYy5vZmZzZXRBcmdzW29mZkFyZ0luZGV4XVxuICAgICAgICBhcnJOdW0gPSBvZmZBcmcuYXJyYXlcbiAgICAgICAgcHRyU3RyID0gXCIrcVwiICsgb2ZmQXJnSW5kZXggLy8gQWRkcyBvZmZzZXQgdG8gdGhlIFwicG9pbnRlclwiIGluIHRoZSBhcnJheVxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHB0clN0ciA9IFwicFwiICsgYXJyTnVtICsgcHRyU3RyXG4gICAgICAgIHZhciBsb2NhbFN0ciA9IFwibFwiICsgaVxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cbiAgICAgICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSA9PT0gMCkgeyAvLyBBcmd1bWVudCB0byBib2R5IGlzIGp1c3QgYSBzaW5nbGUgdmFsdWUgZnJvbSB0aGlzIGFycmF5XG4gICAgICAgICAgaWYoY2FyZy5jb3VudCA9PT0gMSkgeyAvLyBBcmd1bWVudC9hcnJheSB1c2VkIG9ubHkgb25jZSg/KVxuICAgICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMgYSBcImJsb2NrXCJcbiAgICAgICAgICB2YXIgcmVTdHJBcnIgPSBbY2FyZy5uYW1lXSwgcHRyU3RyQXJyID0gW3B0clN0cl1cbiAgICAgICAgICBmb3IodmFyIGo9MDsgajxNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2Fyck51bV0pOyBqKyspIHtcbiAgICAgICAgICAgIHJlU3RyQXJyLnB1c2goXCJcXFxccypcXFxcWyhbXlxcXFxdXSspXFxcXF1cIilcbiAgICAgICAgICAgIHB0clN0ckFyci5wdXNoKFwiJFwiICsgKGorMSkgKyBcIip0XCIgKyBhcnJOdW0gKyBcImJcIiArIGopIC8vIE1hdGNoZWQgaW5kZXggdGltZXMgc3RyaWRlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyZVN0ckFyci5qb2luKFwiXCIpLCBcImdcIilcbiAgICAgICAgICBwdHJTdHIgPSBwdHJTdHJBcnIuam9pbihcIitcIilcbiAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIC8qaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBHZW5lcmljIGFycmF5cyBub3Qgc3VwcG9ydGVkIGluIGNvbWJpbmF0aW9uIHdpdGggYmxvY2tzIVwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGRvZXMgbm90IHByb2R1Y2UgYW55IGxvY2FsIHZhcmlhYmxlcywgZXZlbiBpZiB2YXJpYWJsZXMgYXJlIHVzZWQgbXVsdGlwbGUgdGltZXMuIEl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIGRvIHNvLCBidXQgaXQgd291bGQgY29tcGxpY2F0ZSB0aGluZ3MgcXVpdGUgYSBiaXQuXG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcmUuam9pbihcIlxcblwiKSwgY29kZSwgcG9zdC5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiB0eXBlU3VtbWFyeShkdHlwZXMpIHtcbiAgdmFyIHN1bW1hcnkgPSBuZXcgQXJyYXkoZHR5cGVzLmxlbmd0aClcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxuICBmb3IodmFyIGk9MDsgaTxkdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdCA9IGR0eXBlc1tpXVxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcbiAgICBpZighZGlnaXRzKSB7XG4gICAgICBkaWdpdHMgPSBcIlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyA9IGRpZ2l0c1swXVxuICAgIH1cbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xuICAgICAgc3VtbWFyeVtpXSA9IFwidVwiICsgdC5jaGFyQXQoMSkgKyBkaWdpdHNcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXG4gICAgfVxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxuICAgIH1cbiAgfVxuICBpZihhbGxFcXVhbCkge1xuICAgIHJldHVybiBzdW1tYXJ5WzBdXG4gIH1cbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxufVxuXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXG5mdW5jdGlvbiBnZW5lcmF0ZUNXaXNlT3AocHJvYywgdHlwZXNpZykge1xuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cbiAgLy8gQXJyYXlzIGdldCBwdXQgZmlyc3QgaW4gdHlwZXNpZywgYW5kIHRoZXJlIGFyZSB0d28gZW50cmllcyBwZXIgYXJyYXkgKGR0eXBlIGFuZCBvcmRlciksIHNvIHRoaXMgZ2V0cyB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gdGhlIGZpcnN0IGFycmF5IGFyZy5cbiAgdmFyIGRpbWVuc2lvbiA9ICh0eXBlc2lnWzFdLmxlbmd0aCAtIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pKXwwXG4gIHZhciBvcmRlcnMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICB2YXIgZHR5cGVzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cbiAgICBvcmRlcnNbaV0gPSB0eXBlc2lnWzIqaSsxXVxuICB9XG4gIFxuICAvL0RldGVybWluZSB3aGVyZSBibG9jayBhbmQgbG9vcCBpbmRpY2VzIHN0YXJ0IGFuZCBlbmRcbiAgdmFyIGJsb2NrQmVnaW4gPSBbXSwgYmxvY2tFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBleHBvc2VkIGFzIGJsb2Nrc1xuICB2YXIgbG9vcEJlZ2luID0gW10sIGxvb3BFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBpdGVyYXRlZCBvdmVyXG4gIHZhciBsb29wT3JkZXJzID0gW10gLy8gb3JkZXJzIHJlc3RyaWN0ZWQgdG8gdGhlIGxvb3AgaW5kaWNlc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldPDApIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKDApXG4gICAgICBsb29wRW5kLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKGRpbWVuc2lvbilcbiAgICAgIGJsb2NrRW5kLnB1c2goZGltZW5zaW9uK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pIC8vIE5vbi1uZWdhdGl2ZVxuICAgICAgbG9vcEVuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0rZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKDApXG4gICAgICBibG9ja0VuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfVxuICAgIHZhciBuZXdPcmRlciA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b3JkZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobG9vcEJlZ2luW2ldPD1vcmRlcnNbaV1bal0gJiYgb3JkZXJzW2ldW2pdPGxvb3BFbmRbaV0pIHtcbiAgICAgICAgbmV3T3JkZXIucHVzaChvcmRlcnNbaV1bal0tbG9vcEJlZ2luW2ldKSAvLyBJZiB0aGlzIGlzIGEgbG9vcCBpbmRleCwgcHV0IGl0IGluIG5ld09yZGVyLCBzdWJ0cmFjdGluZyBsb29wQmVnaW4sIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBsb29wT3JkZXJzIGFyZSB1c2luZyBhIGNvbW1vbiBzZXQgb2YgaW5kaWNlcy5cbiAgICAgIH1cbiAgICB9XG4gICAgbG9vcE9yZGVycy5wdXNoKG5ld09yZGVyKVxuICB9XG5cbiAgLy9GaXJzdCBjcmVhdGUgYXJndW1lbnRzIGZvciBwcm9jZWR1cmVcbiAgdmFyIGFyZ2xpc3QgPSBbXCJTU1wiXSAvLyBTUyBpcyB0aGUgb3ZlcmFsbCBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGVcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgdmFyIHZhcnMgPSBbXVxuICBcbiAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICB2YXJzLnB1c2goW1wic1wiLCBqLCBcIj1TU1tcIiwgaiwgXCJdXCJdLmpvaW4oXCJcIikpIC8vIFRoZSBsaW1pdHMgZm9yIGVhY2ggZGltZW5zaW9uLlxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiYVwiK2kpIC8vIEFjdHVhbCBkYXRhIGFycmF5XG4gICAgYXJnbGlzdC5wdXNoKFwidFwiK2kpIC8vIFN0cmlkZXNcbiAgICBhcmdsaXN0LnB1c2goXCJwXCIraSkgLy8gT2Zmc2V0IGluIHRoZSBhcnJheSBhdCB3aGljaCB0aGUgZGF0YSBzdGFydHMgKGFsc28gdXNlZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIGRhdGEpXG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgbG9vcGluZ1xuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwicFwiLGosXCI9dFwiLGksXCJbXCIsbG9vcEJlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgYmxvY2sgaXRlcmF0aW9uXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJiXCIsaixcIj10XCIsaSxcIltcIixibG9ja0JlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcIllcIiArIGkpXG4gIH1cbiAgaWYocHJvYy5zaGFwZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgIHZhcnMucHVzaChcInNoYXBlPVNTLnNsaWNlKDApXCIpIC8vIE1ha2VzIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgYXZhaWxhYmxlIHRvIHRoZSB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIChzbyB5b3UgY2FuIHVzZSB3aWR0aC9oZWlnaHQgZm9yIGV4YW1wbGUpXG4gIH1cbiAgaWYocHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFByZXBhcmUgYW4gYXJyYXkgdG8ga2VlcCB0cmFjayBvZiB0aGUgKGxvZ2ljYWwpIGluZGljZXMsIGluaXRpYWxpemVkIHRvIGRpbWVuc2lvbiB6ZXJvZXMuXG4gICAgdmFyIHplcm9zID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgemVyb3NbaV0gPSBcIjBcIlxuICAgIH1cbiAgICB2YXJzLnB1c2goW1wiaW5kZXg9W1wiLCB6ZXJvcy5qb2luKFwiLFwiKSwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5vZmZzZXRBcmdzLmxlbmd0aDsgKytpKSB7IC8vIE9mZnNldCBhcmd1bWVudHMgdXNlZCBmb3Igc3RlbmNpbCBvcGVyYXRpb25zXG4gICAgdmFyIG9mZl9hcmcgPSBwcm9jLm9mZnNldEFyZ3NbaV1cbiAgICB2YXIgaW5pdF9zdHJpbmcgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9mZl9hcmcub2Zmc2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAxKSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW1widFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSkgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW29mZl9hcmcub2Zmc2V0W2pdLCBcIip0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihpbml0X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhcnMucHVzaChcInFcIiArIGkgKyBcIj0wXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChbXCJxXCIsIGksIFwiPVwiLCBpbml0X3N0cmluZy5qb2luKFwiK1wiKV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cblxuICAvL1ByZXBhcmUgdGhpcyB2YXJpYWJsZXNcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLmJvZHkudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLnBvc3QudGhpc1ZhcnMpKVxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcbiAgfVxuICBcbiAgLy9JbmxpbmUgcHJlbHVkZVxuICBpZihwcm9jLnByZS5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucHJlLCBwcm9jLCBkdHlwZXMpKVxuICB9XG5cbiAgLy9Qcm9jZXNzIGJvZHlcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXG4gIHZhciBtYXRjaGVkID0gY291bnRNYXRjaGVzKGxvb3BPcmRlcnMpXG4gIGlmKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBjb2RlLnB1c2gob3V0ZXJGaWxsKG1hdGNoZWQsIGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKSAvLyBUT0RPOiBSYXRoZXIgdGhhbiBwYXNzaW5nIGxvb3BPcmRlcnNbMF0sIGl0IG1pZ2h0IGJlIGludGVyZXN0aW5nIHRvIGxvb2sgYXQgcGFzc2luZyBhbiBvcmRlciB0aGF0IHJlcHJlc2VudHMgdGhlIG1ham9yaXR5IG9mIHRoZSBhcmd1bWVudHMgZm9yIGV4YW1wbGUuXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGlubmVyRmlsbChsb29wT3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfVxuXG4gIC8vSW5saW5lIGVwaWxvZ1xuICBpZihwcm9jLnBvc3QuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnBvc3QsIHByb2MsIGR0eXBlcykpXG4gIH1cbiAgXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIGN3aXNlIHJvdXRpbmUgZm9yIFwiLCB0eXBlc2lnLCBcIjpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICB2YXIgbG9vcE5hbWUgPSBbKHByb2MuZnVuY05hbWV8fFwidW5uYW1lZFwiKSwgXCJfY3dpc2VfbG9vcF9cIiwgb3JkZXJzWzBdLmpvaW4oXCJzXCIpLFwibVwiLG1hdGNoZWQsdHlwZVN1bW1hcnkoZHR5cGVzKV0uam9pbihcIlwiKVxuICB2YXIgZiA9IG5ldyBGdW5jdGlvbihbXCJmdW5jdGlvbiBcIixsb29wTmFtZSxcIihcIiwgYXJnbGlzdC5qb2luKFwiLFwiKSxcIil7XCIsIGNvZGUuam9pbihcIlxcblwiKSxcIn0gcmV0dXJuIFwiLCBsb29wTmFtZV0uam9pbihcIlwiKSlcbiAgcmV0dXJuIGYoKVxufVxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUNXaXNlT3BcbiIsIlwidXNlIHN0cmljdFwiXG5cbi8vIFRoZSBmdW5jdGlvbiBiZWxvdyBpcyBjYWxsZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBjd2lzZSBmdW5jdGlvbiBvYmplY3QsIGFuZCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4vLyBBIGZ1bmN0aW9uIG9iamVjdCBpcyBjb25zdHJ1Y3RlZCB3aGljaCBhY2NlcHRzIGFzIGFyZ3VtZW50IGEgY29tcGlsYXRpb24gZnVuY3Rpb24gYW5kIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbi5cbi8vIEl0IGlzIHRoaXMgb3RoZXIgZnVuY3Rpb24gdGhhdCBpcyBldmVudHVhbGx5IHJldHVybmVkIGJ5IGNyZWF0ZVRodW5rLCBhbmQgdGhpcyBmdW5jdGlvbiBpcyB0aGUgb25lIHRoYXQgYWN0dWFsbHlcbi8vIGNoZWNrcyB3aGV0aGVyIGEgY2VydGFpbiBwYXR0ZXJuIG9mIGFyZ3VtZW50cyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgYmVmb3JlIGFuZCBjb21waWxlcyBuZXcgbG9vcHMgYXMgbmVlZGVkLlxuLy8gVGhlIGNvbXBpbGF0aW9uIHBhc3NlZCB0byB0aGUgZmlyc3QgZnVuY3Rpb24gb2JqZWN0IGlzIHVzZWQgZm9yIGNvbXBpbGluZyBuZXcgZnVuY3Rpb25zLlxuLy8gT25jZSB0aGlzIGZ1bmN0aW9uIG9iamVjdCBpcyBjcmVhdGVkLCBpdCBpcyBjYWxsZWQgd2l0aCBjb21waWxlIGFzIGFyZ3VtZW50LCB3aGVyZSB0aGUgZmlyc3QgYXJndW1lbnQgb2YgY29tcGlsZVxuLy8gaXMgYm91bmQgdG8gXCJwcm9jXCIgKGVzc2VudGlhbGx5IGNvbnRhaW5pbmcgYSBwcmVwcm9jZXNzZWQgdmVyc2lvbiBvZiB0aGUgdXNlciBhcmd1bWVudHMgdG8gY3dpc2UpLlxuLy8gU28gY3JlYXRlVGh1bmsgcm91Z2hseSB3b3JrcyBsaWtlIHRoaXM6XG4vLyBmdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4vLyAgIHZhciB0aHVuayA9IGZ1bmN0aW9uKGNvbXBpbGVCb3VuZCkge1xuLy8gICAgIHZhciBDQUNIRUQgPSB7fVxuLy8gICAgIHJldHVybiBmdW5jdGlvbihhcnJheXMgYW5kIHNjYWxhcnMpIHtcbi8vICAgICAgIGlmIChkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzIGluIENBQ0hFRCkge1xuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXVxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c10gPSBjb21waWxlQm91bmQoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cylcbi8vICAgICAgIH1cbi8vICAgICAgIHJldHVybiBmdW5jKGFycmF5cyBhbmQgc2NhbGFycylcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZDEocHJvYykpXG4vLyB9XG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcIi4vY29tcGlsZS5qc1wiKVxuXG5mdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCIsIFwidmFyIENBQ0hFRD17fVwiXVxuICB2YXIgdmFycyA9IFtdXG4gIHZhciB0aHVua05hbWUgPSBwcm9jLmZ1bmNOYW1lICsgXCJfY3dpc2VfdGh1bmtcIlxuICBcbiAgLy9CdWlsZCB0aHVua1xuICBjb2RlLnB1c2goW1wicmV0dXJuIGZ1bmN0aW9uIFwiLCB0aHVua05hbWUsIFwiKFwiLCBwcm9jLnNoaW1BcmdzLmpvaW4oXCIsXCIpLCBcIil7XCJdLmpvaW4oXCJcIikpXG4gIHZhciB0eXBlc2lnID0gW11cbiAgdmFyIHN0cmluZ190eXBlc2lnID0gW11cbiAgdmFyIHByb2NfYXJncyA9IFtbXCJhcnJheVwiLHByb2MuYXJyYXlBcmdzWzBdLFwiLnNoYXBlLnNsaWNlKFwiLCAvLyBTbGljZSBzaGFwZSBzbyB0aGF0IHdlIG9ubHkgcmV0YWluIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgKHdoaWNoIGdldHMgcGFzc2VkIHRvIHRoZSBjd2lzZSBvcGVyYXRvciBhcyBTUykuXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXTwwPyhcIixcIitwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdK1wiKVwiKTpcIilcIl0uam9pbihcIlwiKV1cbiAgdmFyIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucyA9IFtdLCBzaGFwZUNvbmRpdGlvbnMgPSBbXVxuICAvLyBQcm9jZXNzIGFycmF5IGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBqID0gcHJvYy5hcnJheUFyZ3NbaV1cbiAgICB2YXJzLnB1c2goW1widFwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5kdHlwZSxcIixcbiAgICAgICAgICAgICAgIFwiclwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5vcmRlclwiXS5qb2luKFwiXCIpKVxuICAgIHR5cGVzaWcucHVzaChcInRcIiArIGopXG4gICAgdHlwZXNpZy5wdXNoKFwiclwiICsgailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwidFwiK2opXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInJcIitqK1wiLmpvaW4oKVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5kYXRhXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLnN0cmlkZVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5vZmZzZXR8MFwiKVxuICAgIGlmIChpPjApIHsgLy8gR2F0aGVyIGNvbmRpdGlvbnMgdG8gY2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5IChpZ25vcmluZyBibG9jayBpbmRpY2VzKVxuICAgICAgc2hhcGVMZW5ndGhDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZS5sZW5ndGg9PT1hcnJheVwiICsgaiArIFwiLnNoYXBlLmxlbmd0aCtcIiArIChNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKS1NYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSkpXG4gICAgICBzaGFwZUNvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlW3NoYXBlSW5kZXgrXCIgKyBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pICsgXCJdPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSArIFwiXVwiKVxuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3Igc2hhcGUgZXF1YWxpdHlcbiAgaWYgKHByb2MuYXJyYXlBcmdzLmxlbmd0aCA+IDEpIHtcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25hbGl0eSEnKVwiKVxuICAgIGNvZGUucHVzaChcImZvcih2YXIgc2hhcGVJbmRleD1hcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZS5sZW5ndGgtXCIgKyBNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiOyBzaGFwZUluZGV4LS0+MDspIHtcIilcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBzaGFwZSEnKVwiKVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICAvLyBQcm9jZXNzIHNjYWxhciBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJvY19hcmdzLnB1c2goXCJzY2FsYXJcIiArIHByb2Muc2NhbGFyQXJnc1tpXSlcbiAgfVxuICAvLyBDaGVjayBmb3IgY2FjaGVkIGZ1bmN0aW9uIChhbmQgaWYgbm90IHByZXNlbnQsIGdlbmVyYXRlIGl0KVxuICB2YXJzLnB1c2goW1widHlwZT1bXCIsIHN0cmluZ190eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0uam9pbigpXCJdLmpvaW4oXCJcIikpXG4gIHZhcnMucHVzaChcInByb2M9Q0FDSEVEW3R5cGVdXCIpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIFxuICBjb2RlLnB1c2goW1wiaWYoIXByb2Mpe1wiLFxuICAgICAgICAgICAgIFwiQ0FDSEVEW3R5cGVdPXByb2M9Y29tcGlsZShbXCIsIHR5cGVzaWcuam9pbihcIixcIiksIFwiXSl9XCIsXG4gICAgICAgICAgICAgXCJyZXR1cm4gcHJvYyhcIiwgcHJvY19hcmdzLmpvaW4oXCIsXCIpLCBcIil9XCJdLmpvaW4oXCJcIikpXG5cbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgdGh1bms6XFxuXCIgKyBjb2RlLmpvaW4oXCJcXG5cIikgKyBcIlxcbi0tLS0tLS0tLS1cIilcbiAgfVxuICBcbiAgLy9Db21waWxlIHRodW5rXG4gIHZhciB0aHVuayA9IG5ldyBGdW5jdGlvbihcImNvbXBpbGVcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kKHVuZGVmaW5lZCwgcHJvYykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGh1bmtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdGFVcmlUb0J1ZmZlcjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYEJ1ZmZlcmAgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBVUkkgYHVyaWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaSBEYXRhIFVSSSB0byB0dXJuIGludG8gYSBCdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0J1ZmZlcn0gQnVmZmVyIGluc3RhbmNlIGZyb20gRGF0YSBVUklcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGF0YVVyaVRvQnVmZmVyICh1cmkpIHtcbiAgaWYgKCEvXmRhdGFcXDovaS50ZXN0KHVyaSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgdXJpYCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBEYXRhIFVSSSAobXVzdCBiZWdpbiB3aXRoIFwiZGF0YTpcIiknKTtcbiAgfVxuXG4gIC8vIHN0cmlwIG5ld2xpbmVzXG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKTtcblxuICAvLyBzcGxpdCB0aGUgVVJJIHVwIGludG8gdGhlIFwibWV0YWRhdGFcIiBhbmQgdGhlIFwiZGF0YVwiIHBvcnRpb25zXG4gIHZhciBmaXJzdENvbW1hID0gdXJpLmluZGV4T2YoJywnKTtcbiAgaWYgKC0xID09PSBmaXJzdENvbW1hIHx8IGZpcnN0Q29tbWEgPD0gNCkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWFsZm9ybWVkIGRhdGE6IFVSSScpO1xuXG4gIC8vIHJlbW92ZSB0aGUgXCJkYXRhOlwiIHNjaGVtZSBhbmQgcGFyc2UgdGhlIG1ldGFkYXRhXG4gIHZhciBtZXRhID0gdXJpLnN1YnN0cmluZyg1LCBmaXJzdENvbW1hKS5zcGxpdCgnOycpO1xuXG4gIHZhciBiYXNlNjQgPSBmYWxzZTtcbiAgdmFyIGNoYXJzZXQgPSAnVVMtQVNDSUknO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoJ2Jhc2U2NCcgPT0gbWV0YVtpXSkge1xuICAgICAgYmFzZTY0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKDAgPT0gbWV0YVtpXS5pbmRleE9mKCdjaGFyc2V0PScpKSB7XG4gICAgICBjaGFyc2V0ID0gbWV0YVtpXS5zdWJzdHJpbmcoOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IHRoZSBlbmNvZGVkIGRhdGEgcG9ydGlvbiBhbmQgZGVjb2RlIFVSSS1lbmNvZGVkIGNoYXJzXG4gIHZhciBkYXRhID0gdW5lc2NhcGUodXJpLnN1YnN0cmluZyhmaXJzdENvbW1hICsgMSkpO1xuXG4gIHZhciBlbmNvZGluZyA9IGJhc2U2NCA/ICdiYXNlNjQnIDogJ2FzY2lpJztcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuXG4gIC8vIHNldCBgLnR5cGVgIHByb3BlcnR5IHRvIE1JTUUgdHlwZVxuICBidWZmZXIudHlwZSA9IG1ldGFbMF0gfHwgJ3RleHQvcGxhaW4nO1xuXG4gIC8vIHNldCB0aGUgYC5jaGFyc2V0YCBwcm9wZXJ0eVxuICBidWZmZXIuY2hhcnNldCA9IGNoYXJzZXQ7XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKSB7XG4gIHZhciBjID0gY291bnRbaV18MFxuICBpZihjIDw9IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGMpLCBqXG4gIGlmKGkgPT09IGNvdW50Lmxlbmd0aC0xKSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSsxKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGVfbnVtYmVyKGNvdW50LCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0LCBpXG4gIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yKGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdmFsdWVcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGUoY291bnQsIHZhbHVlKSB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhbHVlID0gMFxuICB9XG4gIHN3aXRjaCh0eXBlb2YgY291bnQpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZihjb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfbnVtYmVyKGNvdW50fDAsIHZhbHVlKVxuICAgICAgfVxuICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYodHlwZW9mIChjb3VudC5sZW5ndGgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgMClcbiAgICAgIH1cbiAgICBicmVha1xuICB9XG4gIHJldHVybiBbXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGR1cGUiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHBhdGggICAgICAgICAgPSByZXF1aXJlKCdwYXRoJylcbnZhciBuZGFycmF5ICAgICAgID0gcmVxdWlyZSgnbmRhcnJheScpXG52YXIgR2lmUmVhZGVyICAgICA9IHJlcXVpcmUoJ29tZ2dpZicpLkdpZlJlYWRlclxudmFyIHBhY2sgICAgICAgICAgPSByZXF1aXJlKCduZGFycmF5LXBhY2snKVxudmFyIHRocm91Z2ggICAgICAgPSByZXF1aXJlKCd0aHJvdWdoJylcbnZhciBwYXJzZURhdGFVUkkgID0gcmVxdWlyZSgnZGF0YS11cmktdG8tYnVmZmVyJylcblxuZnVuY3Rpb24gZGVmYXVsdEltYWdlKHVybCwgY2IpIHtcbiAgdmFyIGltZyA9IG5ldyBJbWFnZSgpXG4gIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCJcbiAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMClcbiAgICB2YXIgcGl4ZWxzID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KVxuICAgIGNiKG51bGwsIG5kYXJyYXkobmV3IFVpbnQ4QXJyYXkocGl4ZWxzLmRhdGEpLCBbaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCA0XSwgWzQsIDQqaW1nLndpZHRoLCAxXSwgMCkpXG4gIH1cbiAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBjYihlcnIpXG4gIH1cbiAgaW1nLnNyYyA9IHVybFxufVxuXG4vL0FuaW1hdGVkIGdpZiBsb2FkaW5nXG5mdW5jdGlvbiBoYW5kbGVHaWYoZGF0YSwgY2IpIHtcbiAgdmFyIHJlYWRlclxuICB0cnkge1xuICAgIHJlYWRlciA9IG5ldyBHaWZSZWFkZXIoZGF0YSlcbiAgfSBjYXRjaChlcnIpIHtcbiAgICBjYihlcnIpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYocmVhZGVyLm51bUZyYW1lcygpID4gMCkge1xuICAgIHZhciBuc2hhcGUgPSBbcmVhZGVyLm51bUZyYW1lcygpLCByZWFkZXIuaGVpZ2h0LCByZWFkZXIud2lkdGgsIDRdXG4gICAgdmFyIG5kYXRhID0gbmV3IFVpbnQ4QXJyYXkobnNoYXBlWzBdICogbnNoYXBlWzFdICogbnNoYXBlWzJdICogbnNoYXBlWzNdKVxuICAgIHZhciByZXN1bHQgPSBuZGFycmF5KG5kYXRhLCBuc2hhcGUpXG4gICAgdHJ5IHtcbiAgICAgIGZvcih2YXIgaT0wOyBpPHJlYWRlci5udW1GcmFtZXMoKTsgKytpKSB7XG4gICAgICAgIHJlYWRlci5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBKGksIG5kYXRhLnN1YmFycmF5KFxuICAgICAgICAgIHJlc3VsdC5pbmRleChpLCAwLCAwLCAwKSxcbiAgICAgICAgICByZXN1bHQuaW5kZXgoaSsxLCAwLCAwLCAwKSkpXG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYihudWxsLCByZXN1bHQudHJhbnNwb3NlKDAsMiwxKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgbnNoYXBlID0gW3JlYWRlci5oZWlnaHQsIHJlYWRlci53aWR0aCwgNF1cbiAgICB2YXIgbmRhdGEgPSBuZXcgVWludDhBcnJheShuc2hhcGVbMF0gKiBuc2hhcGVbMV0gKiBuc2hhcGVbMl0pXG4gICAgdmFyIHJlc3VsdCA9IG5kYXJyYXkobmRhdGEsIG5zaGFwZSlcbiAgICB0cnkge1xuICAgICAgcmVhZGVyLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEoMCwgbmRhdGEpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYihudWxsLCByZXN1bHQudHJhbnNwb3NlKDEsMCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gaHR0cEdpZih1cmwsIGNiKSB7XG4gIHZhciB4aHIgICAgICAgICAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKVxuICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICBpZih4aHIub3ZlcnJpZGVNaW1lVHlwZSl7XG4gICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2JpbmFyeScpXG4gIH1cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBjYihlcnIpXG4gIH1cbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpXG4gICAgaGFuZGxlR2lmKGRhdGEsIGNiKVxuICAgIHJldHVyblxuICB9XG4gIHhoci5zZW5kKClcbn1cblxuZnVuY3Rpb24gY29weUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoYnVmZmVyWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGhcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIHJlc3VsdFtpXSA9IGJ1ZmZlci5nZXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0YUdpZih1cmwsIGNiKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBidWZmZXIgPSBwYXJzZURhdGFVUkkodXJsKVxuICAgICAgaWYoYnVmZmVyKSB7XG4gICAgICAgIGhhbmRsZUdpZihjb3B5QnVmZmVyKGJ1ZmZlciksIGNiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobmV3IEVycm9yKCdFcnJvciBwYXJzaW5nIGRhdGEgVVJJJykpXG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UGl4ZWxzKHVybCwgdHlwZSwgY2IpIHtcbiAgaWYoIWNiKSB7XG4gICAgY2IgPSB0eXBlXG4gICAgdHlwZSA9ICcnXG4gIH1cbiAgdmFyIGV4dCA9IHBhdGguZXh0bmFtZSh1cmwpXG4gIHN3aXRjaCh0eXBlIHx8IGV4dC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgY2FzZSAnLkdJRic6XG4gICAgICBodHRwR2lmKHVybCwgY2IpXG4gICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYoQnVmZmVyLmlzQnVmZmVyKHVybCkpIHtcbiAgICAgICAgdXJsID0gJ2RhdGE6JyArIHR5cGUgKyAnO2Jhc2U2NCwnICsgdXJsLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgfVxuICAgICAgaWYodXJsLmluZGV4T2YoJ2RhdGE6aW1hZ2UvZ2lmOycpID09PSAwKSB7XG4gICAgICAgIGRhdGFHaWYodXJsLCBjYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRJbWFnZSh1cmwsIGNiKVxuICAgICAgfVxuICB9XG59IiwibW9kdWxlLmV4cG9ydHMgPSBhZGpvaW50O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIG91dFswXSAgPSAgKGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbMl0gID0gIChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFszXSAgPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbNV0gID0gIChhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFs2XSAgPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbOF0gID0gIChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xuICAgIG91dFs5XSAgPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gICAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gICAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIG91dFsxNV0gPSAgKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBkZXRlcm1pbmFudDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tUXVhdDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21Sb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgdmFyIHMsIGMsIHRcbiAgdmFyIHggPSBheGlzWzBdXG4gIHZhciB5ID0gYXhpc1sxXVxuICB2YXIgeiA9IGF4aXNbMl1cbiAgdmFyIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopXG5cbiAgaWYgKE1hdGguYWJzKGxlbikgPCAwLjAwMDAwMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZW4gPSAxIC8gbGVuXG4gIHggKj0gbGVuXG4gIHkgKj0gbGVuXG4gIHogKj0gbGVuXG5cbiAgcyA9IE1hdGguc2luKHJhZClcbiAgYyA9IE1hdGguY29zKHJhZClcbiAgdCA9IDEgLSBjXG5cbiAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgY1xuICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogc1xuICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogc1xuICBvdXRbM10gPSAwXG4gIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzXG4gIG91dFs1XSA9IHkgKiB5ICogdCArIGNcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHNcbiAgb3V0WzddID0gMFxuICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogc1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogc1xuICBvdXRbMTBdID0geiAqIHogKiB0ICsgY1xuICBvdXRbMTFdID0gMFxuICBvdXRbMTJdID0gMFxuICBvdXRbMTNdID0gMFxuICBvdXRbMTRdID0gMFxuICBvdXRbMTVdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdikge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgICBvdXRbMV0gPSB4eSArIHd6O1xuICAgIG91dFsyXSA9IHh6IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4eSAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgb3V0WzZdID0geXogKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHh6ICsgd3k7XG4gICAgb3V0WzldID0geXogLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21TY2FsaW5nXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAwXG4gIG91dFs0XSA9IDBcbiAgb3V0WzVdID0gdlsxXVxuICBvdXRbNl0gPSAwXG4gIG91dFs3XSA9IDBcbiAgb3V0WzhdID0gMFxuICBvdXRbOV0gPSAwXG4gIG91dFsxMF0gPSB2WzJdXG4gIG91dFsxMV0gPSAwXG4gIG91dFsxMl0gPSAwXG4gIG91dFsxM10gPSAwXG4gIG91dFsxNF0gPSAwXG4gIG91dFsxNV0gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVRyYW5zbGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYylcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMFxuICBvdXRbNF0gPSAwXG4gIG91dFs1XSA9IDFcbiAgb3V0WzZdID0gMFxuICBvdXRbN10gPSAwXG4gIG91dFs4XSA9IDBcbiAgb3V0WzldID0gMFxuICBvdXRbMTBdID0gMVxuICBvdXRbMTFdID0gMFxuICBvdXRbMTJdID0gdlswXVxuICBvdXRbMTNdID0gdlsxXVxuICBvdXRbMTRdID0gdlsyXVxuICBvdXRbMTVdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21YUm90YXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZClcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSAxXG4gICAgb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IDBcbiAgICBvdXRbM10gPSAwXG4gICAgb3V0WzRdID0gMFxuICAgIG91dFs1XSA9IGNcbiAgICBvdXRbNl0gPSBzXG4gICAgb3V0WzddID0gMFxuICAgIG91dFs4XSA9IDBcbiAgICBvdXRbOV0gPSAtc1xuICAgIG91dFsxMF0gPSBjXG4gICAgb3V0WzExXSA9IDBcbiAgICBvdXRbMTJdID0gMFxuICAgIG91dFsxM10gPSAwXG4gICAgb3V0WzE0XSA9IDBcbiAgICBvdXRbMTVdID0gMVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21ZUm90YXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZClcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBjXG4gICAgb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IC1zXG4gICAgb3V0WzNdID0gMFxuICAgIG91dFs0XSA9IDBcbiAgICBvdXRbNV0gPSAxXG4gICAgb3V0WzZdID0gMFxuICAgIG91dFs3XSA9IDBcbiAgICBvdXRbOF0gPSBzXG4gICAgb3V0WzldID0gMFxuICAgIG91dFsxMF0gPSBjXG4gICAgb3V0WzExXSA9IDBcbiAgICBvdXRbMTJdID0gMFxuICAgIG91dFsxM10gPSAwXG4gICAgb3V0WzE0XSA9IDBcbiAgICBvdXRbMTVdID0gMVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21aUm90YXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVpSb3RhdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZClcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBjXG4gICAgb3V0WzFdID0gc1xuICAgIG91dFsyXSA9IDBcbiAgICBvdXRbM10gPSAwXG4gICAgb3V0WzRdID0gLXNcbiAgICBvdXRbNV0gPSBjXG4gICAgb3V0WzZdID0gMFxuICAgIG91dFs3XSA9IDBcbiAgICBvdXRbOF0gPSAwXG4gICAgb3V0WzldID0gMFxuICAgIG91dFsxMF0gPSAxXG4gICAgb3V0WzExXSA9IDBcbiAgICBvdXRbMTJdID0gMFxuICAgIG91dFsxM10gPSAwXG4gICAgb3V0WzE0XSA9IDBcbiAgICBvdXRbMTVdID0gMVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZydXN0dW07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZydXN0dW0ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KSxcbiAgICAgICAgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAobmVhciAqIDIpICogcmw7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gICAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBpZGVudGl0eTogcmVxdWlyZSgnLi9pZGVudGl0eScpXG4gICwgdHJhbnNwb3NlOiByZXF1aXJlKCcuL3RyYW5zcG9zZScpXG4gICwgaW52ZXJ0OiByZXF1aXJlKCcuL2ludmVydCcpXG4gICwgYWRqb2ludDogcmVxdWlyZSgnLi9hZGpvaW50JylcbiAgLCBkZXRlcm1pbmFudDogcmVxdWlyZSgnLi9kZXRlcm1pbmFudCcpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIHRyYW5zbGF0ZTogcmVxdWlyZSgnLi90cmFuc2xhdGUnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCByb3RhdGU6IHJlcXVpcmUoJy4vcm90YXRlJylcbiAgLCByb3RhdGVYOiByZXF1aXJlKCcuL3JvdGF0ZVgnKVxuICAsIHJvdGF0ZVk6IHJlcXVpcmUoJy4vcm90YXRlWScpXG4gICwgcm90YXRlWjogcmVxdWlyZSgnLi9yb3RhdGVaJylcbiAgLCBmcm9tUm90YXRpb246IHJlcXVpcmUoJy4vZnJvbVJvdGF0aW9uJylcbiAgLCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbjogcmVxdWlyZSgnLi9mcm9tUm90YXRpb25UcmFuc2xhdGlvbicpXG4gICwgZnJvbVNjYWxpbmc6IHJlcXVpcmUoJy4vZnJvbVNjYWxpbmcnKVxuICAsIGZyb21UcmFuc2xhdGlvbjogcmVxdWlyZSgnLi9mcm9tVHJhbnNsYXRpb24nKVxuICAsIGZyb21YUm90YXRpb246IHJlcXVpcmUoJy4vZnJvbVhSb3RhdGlvbicpXG4gICwgZnJvbVlSb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tWVJvdGF0aW9uJylcbiAgLCBmcm9tWlJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21aUm90YXRpb24nKVxuICAsIGZyb21RdWF0OiByZXF1aXJlKCcuL2Zyb21RdWF0JylcbiAgLCBmcnVzdHVtOiByZXF1aXJlKCcuL2ZydXN0dW0nKVxuICAsIHBlcnNwZWN0aXZlOiByZXF1aXJlKCcuL3BlcnNwZWN0aXZlJylcbiAgLCBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldzogcmVxdWlyZSgnLi9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldycpXG4gICwgb3J0aG86IHJlcXVpcmUoJy4vb3J0aG8nKVxuICAsIGxvb2tBdDogcmVxdWlyZSgnLi9sb29rQXQnKVxuICAsIHN0cjogcmVxdWlyZSgnLi9zdHInKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnQ7XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9va0F0O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gICAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbixcbiAgICAgICAgZXlleCA9IGV5ZVswXSxcbiAgICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgICB1cHogPSB1cFsyXSxcbiAgICAgICAgY2VudGVyeCA9IGNlbnRlclswXSxcbiAgICAgICAgY2VudGVyeSA9IGNlbnRlclsxXSxcbiAgICAgICAgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICAgIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCAwLjAwMDAwMSAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCAwLjAwMDAwMSAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCAwLjAwMDAwMSkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107ICBcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBvcnRobztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBvcnRobyhvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IC0yICogbHI7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBwZXJzcGVjdGl2ZTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pLFxuICAgICAgICB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcblxuICAgIG91dFswXSA9IHhTY2FsZTtcbiAgICBvdXRbMV0gPSAwLjA7XG4gICAgb3V0WzJdID0gMC4wO1xuICAgIG91dFszXSA9IDAuMDtcbiAgICBvdXRbNF0gPSAwLjA7XG4gICAgb3V0WzVdID0geVNjYWxlO1xuICAgIG91dFs2XSA9IDAuMDtcbiAgICBvdXRbN10gPSAwLjA7XG4gICAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzldID0gKCh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41KTtcbiAgICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMV0gPSAtMS4wO1xuICAgIG91dFsxMl0gPSAwLjA7XG4gICAgb3V0WzEzXSA9IDAuMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxNV0gPSAwLjA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGU7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgMC4wMDAwMDEpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICAgIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICAgIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVaO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gICAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBzdHI7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5mdW5jdGlvbiBzdHIoYSkge1xuICAgIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNsYXRlO1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXSxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICAgICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFswXSA9IGEwMDsgb3V0WzFdID0gYTAxOyBvdXRbMl0gPSBhMDI7IG91dFszXSA9IGEwMztcbiAgICAgICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc3Bvc2U7XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgICAgICBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGEwMTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGEwMjtcbiAgICAgICAgb3V0WzldID0gYTEyO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhMDM7XG4gICAgICAgIG91dFsxM10gPSBhMTM7XG4gICAgICAgIG91dFsxNF0gPSBhMjM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGFbMV07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhWzJdO1xuICAgICAgICBvdXRbOV0gPSBhWzZdO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbM107XG4gICAgICAgIG91dFsxM10gPSBhWzddO1xuICAgICAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBuZGFycmF5ID0gcmVxdWlyZSgnbmRhcnJheScpXG52YXIgb3BzICAgICA9IHJlcXVpcmUoJ25kYXJyYXktb3BzJylcbnZhciBwb29sICAgID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUZXh0dXJlMkRcblxudmFyIGxpbmVhclR5cGVzID0gbnVsbFxudmFyIGZpbHRlclR5cGVzID0gbnVsbFxudmFyIHdyYXBUeXBlcyAgID0gbnVsbFxuXG5mdW5jdGlvbiBsYXp5SW5pdExpbmVhclR5cGVzKGdsKSB7XG4gIGxpbmVhclR5cGVzID0gW1xuICAgIGdsLkxJTkVBUixcbiAgICBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIsXG4gICAgZ2wuTElORUFSX01JUE1BUF9ORUFSRVNULFxuICAgIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVFxuICBdXG4gIGZpbHRlclR5cGVzID0gW1xuICAgIGdsLk5FQVJFU1QsXG4gICAgZ2wuTElORUFSLFxuICAgIGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QsXG4gICAgZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSLFxuICAgIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCxcbiAgICBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxuICBdXG4gIHdyYXBUeXBlcyA9IFtcbiAgICBnbC5SRVBFQVQsXG4gICAgZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICBnbC5NSVJST1JFRF9SRVBFQVRcbiAgXVxufVxuXG5mdW5jdGlvbiBhY2NlcHRUZXh0dXJlRE9NIChvYmopIHtcbiAgcmV0dXJuIChcbiAgICAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB8fFxuICAgICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAmJiBvYmogaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB8fFxuICAgICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCAmJiBvYmogaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB8fFxuICAgICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgSW1hZ2VEYXRhICYmIG9iaiBpbnN0YW5jZW9mIEltYWdlRGF0YSkpXG59XG5cbnZhciBjb252ZXJ0RmxvYXRUb1VpbnQ4ID0gZnVuY3Rpb24ob3V0LCBpbnApIHtcbiAgb3BzLm11bHMob3V0LCBpbnAsIDI1NS4wKVxufVxuXG5mdW5jdGlvbiByZXNoYXBlVGV4dHVyZSh0ZXgsIHcsIGgpIHtcbiAgdmFyIGdsID0gdGV4LmdsXG4gIHZhciBtYXhTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG4gIGlmKHcgPCAwIHx8IHcgPiBtYXhTaXplIHx8IGggPCAwIHx8IGggPiBtYXhTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgdGV4dHVyZSBzaXplJylcbiAgfVxuICB0ZXguX3NoYXBlID0gW3csIGhdXG4gIHRleC5iaW5kKClcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0ZXguZm9ybWF0LCB3LCBoLCAwLCB0ZXguZm9ybWF0LCB0ZXgudHlwZSwgbnVsbClcbiAgdGV4Ll9taXBMZXZlbHMgPSBbMF1cbiAgcmV0dXJuIHRleFxufVxuXG5mdW5jdGlvbiBUZXh0dXJlMkQoZ2wsIGhhbmRsZSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKSB7XG4gIHRoaXMuZ2wgPSBnbFxuICB0aGlzLmhhbmRsZSA9IGhhbmRsZVxuICB0aGlzLmZvcm1hdCA9IGZvcm1hdFxuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMuX3NoYXBlID0gW3dpZHRoLCBoZWlnaHRdXG4gIHRoaXMuX21pcExldmVscyA9IFswXVxuICB0aGlzLl9tYWdGaWx0ZXIgPSBnbC5ORUFSRVNUXG4gIHRoaXMuX21pbkZpbHRlciA9IGdsLk5FQVJFU1RcbiAgdGhpcy5fd3JhcFMgPSBnbC5DTEFNUF9UT19FREdFXG4gIHRoaXMuX3dyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRVxuICB0aGlzLl9hbmlzb1NhbXBsZXMgPSAxXG5cbiAgdmFyIHBhcmVudCA9IHRoaXNcbiAgdmFyIHdyYXBWZWN0b3IgPSBbdGhpcy5fd3JhcFMsIHRoaXMuX3dyYXBUXVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwVmVjdG9yLCBbXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fd3JhcFNcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC53cmFwUyA9IHZcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuX3dyYXBUXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQud3JhcFQgPSB2XG4gICAgICB9XG4gICAgfVxuICBdKVxuICB0aGlzLl93cmFwVmVjdG9yID0gd3JhcFZlY3RvclxuXG4gIHZhciBzaGFwZVZlY3RvciA9IFt0aGlzLl9zaGFwZVswXSwgdGhpcy5fc2hhcGVbMV1dXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNoYXBlVmVjdG9yLCBbXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fc2hhcGVbMF1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC53aWR0aCA9IHZcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuX3NoYXBlWzFdXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuaGVpZ2h0ID0gdlxuICAgICAgfVxuICAgIH1cbiAgXSlcbiAgdGhpcy5fc2hhcGVWZWN0b3IgPSBzaGFwZVZlY3RvclxufVxuXG52YXIgcHJvdG8gPSBUZXh0dXJlMkQucHJvdG90eXBlXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvLCB7XG4gIG1pbkZpbHRlcjoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWluRmlsdGVyXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsXG4gICAgICBpZih0aGlzLnR5cGUgPT09IGdsLkZMT0FUICYmIGxpbmVhclR5cGVzLmluZGV4T2YodikgPj0gMCkge1xuICAgICAgICBpZighZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSkge1xuICAgICAgICAgIHYgPSBnbC5ORUFSRVNUXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGZpbHRlclR5cGVzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIGZpbHRlciBtb2RlICcgKyB2KVxuICAgICAgfVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHYpXG4gICAgICByZXR1cm4gdGhpcy5fbWluRmlsdGVyID0gdlxuICAgIH1cbiAgfSxcbiAgbWFnRmlsdGVyOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYWdGaWx0ZXJcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgIGlmKHRoaXMudHlwZSA9PT0gZ2wuRkxPQVQgJiYgbGluZWFyVHlwZXMuaW5kZXhPZih2KSA+PSAwKSB7XG4gICAgICAgIGlmKCFnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpKSB7XG4gICAgICAgICAgdiA9IGdsLk5FQVJFU1RcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoZmlsdGVyVHlwZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gZmlsdGVyIG1vZGUgJyArIHYpXG4gICAgICB9XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdilcbiAgICAgIHJldHVybiB0aGlzLl9tYWdGaWx0ZXIgPSB2XG4gICAgfVxuICB9LFxuICBtaXBTYW1wbGVzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbmlzb1NhbXBsZXNcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIHBzYW1wbGVzID0gdGhpcy5fYW5pc29TYW1wbGVzXG4gICAgICB0aGlzLl9hbmlzb1NhbXBsZXMgPSBNYXRoLm1heChpLCAxKXwwXG4gICAgICBpZihwc2FtcGxlcyAhPT0gdGhpcy5fYW5pc29TYW1wbGVzKSB7XG4gICAgICAgIHZhciBleHQgPSB0aGlzLmdsLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJylcbiAgICAgICAgaWYoZXh0KSB7XG4gICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJmKHRoaXMuZ2wuVEVYVFVSRV8yRCwgZXh0LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCB0aGlzLl9hbmlzb1NhbXBsZXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9hbmlzb1NhbXBsZXNcbiAgICB9XG4gIH0sXG4gIHdyYXBTOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwU1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgaWYod3JhcFR5cGVzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIHdyYXAgbW9kZSAnICsgdilcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHYpXG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFMgPSB2XG4gICAgfVxuICB9LFxuICB3cmFwVDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFRcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIGlmKHdyYXBUeXBlcy5pbmRleE9mKHYpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biB3cmFwIG1vZGUgJyArIHYpXG4gICAgICB9XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB2KVxuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUID0gdlxuICAgIH1cbiAgfSxcbiAgd3JhcDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFZlY3RvclxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICBpZighQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICB2ID0gW3Ysdl1cbiAgICAgIH1cbiAgICAgIGlmKHYubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBNdXN0IHNwZWNpZnkgd3JhcCBtb2RlIGZvciByb3dzIGFuZCBjb2x1bW5zJylcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgaT0wOyBpPDI7ICsraSkge1xuICAgICAgICBpZih3cmFwVHlwZXMuaW5kZXhPZih2W2ldKSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biB3cmFwIG1vZGUgJyArIHYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3dyYXBTID0gdlswXVxuICAgICAgdGhpcy5fd3JhcFQgPSB2WzFdXG5cbiAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl93cmFwUylcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX3dyYXBUKVxuXG4gICAgICByZXR1cm4gdlxuICAgIH1cbiAgfSxcbiAgc2hhcGU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlVmVjdG9yXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmKCFBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgIHggPSBbeHwwLHh8MF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKHgubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgdGV4dHVyZSBzaGFwZScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc2hhcGVUZXh0dXJlKHRoaXMsIHhbMF18MCwgeFsxXXwwKVxuICAgICAgcmV0dXJuIFt4WzBdfDAsIHhbMV18MF1cbiAgICB9XG4gIH0sXG4gIHdpZHRoOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaGFwZVswXVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih3KSB7XG4gICAgICB3ID0gd3wwXG4gICAgICByZXNoYXBlVGV4dHVyZSh0aGlzLCB3LCB0aGlzLl9zaGFwZVsxXSlcbiAgICAgIHJldHVybiB3XG4gICAgfVxuICB9LFxuICBoZWlnaHQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlWzFdXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGgpIHtcbiAgICAgIGggPSBofDBcbiAgICAgIHJlc2hhcGVUZXh0dXJlKHRoaXMsIHRoaXMuX3NoYXBlWzBdLCBoKVxuICAgICAgcmV0dXJuIGhcbiAgICB9XG4gIH1cbn0pXG5cbnByb3RvLmJpbmQgPSBmdW5jdGlvbih1bml0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2xcbiAgaWYodW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArICh1bml0fDApKVxuICB9XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuaGFuZGxlKVxuICBpZih1bml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gKHVuaXR8MClcbiAgfVxuICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLkFDVElWRV9URVhUVVJFKSAtIGdsLlRFWFRVUkUwXG59XG5cbnByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMuaGFuZGxlKVxufVxuXG5wcm90by5nZW5lcmF0ZU1pcG1hcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJpbmQoKVxuICB0aGlzLmdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuZ2wuVEVYVFVSRV8yRClcblxuICAvL1VwZGF0ZSBtaXAgbGV2ZWxzXG4gIHZhciBsID0gTWF0aC5taW4odGhpcy5fc2hhcGVbMF0sIHRoaXMuX3NoYXBlWzFdKVxuICBmb3IodmFyIGk9MDsgbD4wOyArK2ksIGw+Pj49MSkge1xuICAgIGlmKHRoaXMuX21pcExldmVscy5pbmRleE9mKGkpIDwgMCkge1xuICAgICAgdGhpcy5fbWlwTGV2ZWxzLnB1c2goaSlcbiAgICB9XG4gIH1cbn1cblxucHJvdG8uc2V0UGl4ZWxzID0gZnVuY3Rpb24oZGF0YSwgeF9vZmYsIHlfb2ZmLCBtaXBfbGV2ZWwpIHtcbiAgdmFyIGdsID0gdGhpcy5nbFxuICB0aGlzLmJpbmQoKVxuICBpZihBcnJheS5pc0FycmF5KHhfb2ZmKSkge1xuICAgIG1pcF9sZXZlbCA9IHlfb2ZmXG4gICAgeV9vZmYgPSB4X29mZlsxXXwwXG4gICAgeF9vZmYgPSB4X29mZlswXXwwXG4gIH0gZWxzZSB7XG4gICAgeF9vZmYgPSB4X29mZiB8fCAwXG4gICAgeV9vZmYgPSB5X29mZiB8fCAwXG4gIH1cbiAgbWlwX2xldmVsID0gbWlwX2xldmVsIHx8IDBcbiAgdmFyIGRpcmVjdERhdGEgPSBhY2NlcHRUZXh0dXJlRE9NKGRhdGEpID8gZGF0YSA6IGRhdGEucmF3XG4gIGlmKGRpcmVjdERhdGEpIHtcbiAgICB2YXIgbmVlZHNNaXAgPSB0aGlzLl9taXBMZXZlbHMuaW5kZXhPZihtaXBfbGV2ZWwpIDwgMFxuICAgIGlmKG5lZWRzTWlwKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBkaXJlY3REYXRhKVxuICAgICAgdGhpcy5fbWlwTGV2ZWxzLnB1c2gobWlwX2xldmVsKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgeF9vZmYsIHlfb2ZmLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBkaXJlY3REYXRhKVxuICAgIH1cbiAgfSBlbHNlIGlmKGRhdGEuc2hhcGUgJiYgZGF0YS5zdHJpZGUgJiYgZGF0YS5kYXRhKSB7XG4gICAgaWYoZGF0YS5zaGFwZS5sZW5ndGggPCAyIHx8XG4gICAgICAgeF9vZmYgKyBkYXRhLnNoYXBlWzFdID4gdGhpcy5fc2hhcGVbMV0+Pj5taXBfbGV2ZWwgfHxcbiAgICAgICB5X29mZiArIGRhdGEuc2hhcGVbMF0gPiB0aGlzLl9zaGFwZVswXT4+Pm1pcF9sZXZlbCB8fFxuICAgICAgIHhfb2ZmIDwgMCB8fFxuICAgICAgIHlfb2ZmIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFRleHR1cmUgZGltZW5zaW9ucyBhcmUgb3V0IG9mIGJvdW5kcycpXG4gICAgfVxuICAgIHRleFN1YkltYWdlQXJyYXkoZ2wsIHhfb2ZmLCB5X29mZiwgbWlwX2xldmVsLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCB0aGlzLl9taXBMZXZlbHMsIGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVuc3VwcG9ydGVkIGRhdGEgdHlwZScpXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBpc1BhY2tlZChzaGFwZSwgc3RyaWRlKSB7XG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiAgKHN0cmlkZVsyXSA9PT0gMSkgJiZcbiAgICAgICAgICAgIChzdHJpZGVbMV0gPT09IHNoYXBlWzBdKnNoYXBlWzJdKSAmJlxuICAgICAgICAgICAgKHN0cmlkZVswXSA9PT0gc2hhcGVbMl0pXG4gIH1cbiAgcmV0dXJuICAoc3RyaWRlWzBdID09PSAxKSAmJlxuICAgICAgICAgIChzdHJpZGVbMV0gPT09IHNoYXBlWzBdKVxufVxuXG5mdW5jdGlvbiB0ZXhTdWJJbWFnZUFycmF5KGdsLCB4X29mZiwgeV9vZmYsIG1pcF9sZXZlbCwgY2Zvcm1hdCwgY3R5cGUsIG1pcExldmVscywgYXJyYXkpIHtcbiAgdmFyIGR0eXBlID0gYXJyYXkuZHR5cGVcbiAgdmFyIHNoYXBlID0gYXJyYXkuc2hhcGUuc2xpY2UoKVxuICBpZihzaGFwZS5sZW5ndGggPCAyIHx8IHNoYXBlLmxlbmd0aCA+IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBuZGFycmF5LCBtdXN0IGJlIDJkIG9yIDNkJylcbiAgfVxuICB2YXIgdHlwZSA9IDAsIGZvcm1hdCA9IDBcbiAgdmFyIHBhY2tlZCA9IGlzUGFja2VkKHNoYXBlLCBhcnJheS5zdHJpZGUuc2xpY2UoKSlcbiAgaWYoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgIHR5cGUgPSBnbC5GTE9BVFxuICB9IGVsc2UgaWYoZHR5cGUgPT09ICdmbG9hdDY0Jykge1xuICAgIHR5cGUgPSBnbC5GTE9BVFxuICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgZHR5cGUgPSAnZmxvYXQzMidcbiAgfSBlbHNlIGlmKGR0eXBlID09PSAndWludDgnKSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgZHR5cGUgPSAndWludDgnXG4gIH1cbiAgdmFyIGNoYW5uZWxzID0gMVxuICBpZihzaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICBmb3JtYXQgPSBnbC5MVU1JTkFOQ0VcbiAgICBzaGFwZSA9IFtzaGFwZVswXSwgc2hhcGVbMV0sIDFdXG4gICAgYXJyYXkgPSBuZGFycmF5KGFycmF5LmRhdGEsIHNoYXBlLCBbYXJyYXkuc3RyaWRlWzBdLCBhcnJheS5zdHJpZGVbMV0sIDFdLCBhcnJheS5vZmZzZXQpXG4gIH0gZWxzZSBpZihzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICBpZihzaGFwZVsyXSA9PT0gMSkge1xuICAgICAgZm9ybWF0ID0gZ2wuQUxQSEFcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDIpIHtcbiAgICAgIGZvcm1hdCA9IGdsLkxVTUlOQU5DRV9BTFBIQVxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gMykge1xuICAgICAgZm9ybWF0ID0gZ2wuUkdCXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSA0KSB7XG4gICAgICBmb3JtYXQgPSBnbC5SR0JBXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHNoYXBlIGZvciBwaXhlbCBjb29yZHMnKVxuICAgIH1cbiAgICBjaGFubmVscyA9IHNoYXBlWzJdXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgc2hhcGUgZm9yIHRleHR1cmUnKVxuICB9XG4gIC8vRm9yIDEtY2hhbm5lbCB0ZXh0dXJlcyBhbGxvdyBjb252ZXJzaW9uIGJldHdlZW4gZm9ybWF0c1xuICBpZigoZm9ybWF0ICA9PT0gZ2wuTFVNSU5BTkNFIHx8IGZvcm1hdCAgPT09IGdsLkFMUEhBKSAmJlxuICAgICAoY2Zvcm1hdCA9PT0gZ2wuTFVNSU5BTkNFIHx8IGNmb3JtYXQgPT09IGdsLkFMUEhBKSkge1xuICAgIGZvcm1hdCA9IGNmb3JtYXRcbiAgfVxuICBpZihmb3JtYXQgIT09IGNmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW5jb21wYXRpYmxlIHRleHR1cmUgZm9ybWF0IGZvciBzZXRQaXhlbHMnKVxuICB9XG4gIHZhciBzaXplID0gYXJyYXkuc2l6ZVxuICB2YXIgbmVlZHNNaXAgPSBtaXBMZXZlbHMuaW5kZXhPZihtaXBfbGV2ZWwpIDwgMFxuICBpZihuZWVkc01pcCkge1xuICAgIG1pcExldmVscy5wdXNoKG1pcF9sZXZlbClcbiAgfVxuICBpZih0eXBlID09PSBjdHlwZSAmJiBwYWNrZWQpIHtcbiAgICAvL0FycmF5IGRhdGEgdHlwZXMgYXJlIGNvbXBhdGlibGUsIGNhbiBkaXJlY3RseSBjb3B5IGludG8gdGV4dHVyZVxuICAgIGlmKGFycmF5Lm9mZnNldCA9PT0gMCAmJiBhcnJheS5kYXRhLmxlbmd0aCA9PT0gc2l6ZSkge1xuICAgICAgaWYobmVlZHNNaXApIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIGNmb3JtYXQsIHNoYXBlWzBdLCBzaGFwZVsxXSwgMCwgY2Zvcm1hdCwgY3R5cGUsIGFycmF5LmRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgeF9vZmYsIHlfb2ZmLCBzaGFwZVswXSwgc2hhcGVbMV0sIGNmb3JtYXQsIGN0eXBlLCBhcnJheS5kYXRhKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihuZWVkc01pcCkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgY2Zvcm1hdCwgc2hhcGVbMF0sIHNoYXBlWzFdLCAwLCBjZm9ybWF0LCBjdHlwZSwgYXJyYXkuZGF0YS5zdWJhcnJheShhcnJheS5vZmZzZXQsIGFycmF5Lm9mZnNldCtzaXplKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCB4X29mZiwgeV9vZmYsIHNoYXBlWzBdLCBzaGFwZVsxXSwgY2Zvcm1hdCwgY3R5cGUsIGFycmF5LmRhdGEuc3ViYXJyYXkoYXJyYXkub2Zmc2V0LCBhcnJheS5vZmZzZXQrc2l6ZSkpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vTmVlZCB0byBkbyB0eXBlIGNvbnZlcnNpb24gdG8gcGFjayBkYXRhIGludG8gYnVmZmVyXG4gICAgdmFyIHBhY2tfYnVmZmVyXG4gICAgaWYoY3R5cGUgPT09IGdsLkZMT0FUKSB7XG4gICAgICBwYWNrX2J1ZmZlciA9IHBvb2wubWFsbG9jRmxvYXQzMihzaXplKVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrX2J1ZmZlciA9IHBvb2wubWFsbG9jVWludDgoc2l6ZSlcbiAgICB9XG4gICAgdmFyIHBhY2tfdmlldyA9IG5kYXJyYXkocGFja19idWZmZXIsIHNoYXBlLCBbc2hhcGVbMl0sIHNoYXBlWzJdKnNoYXBlWzBdLCAxXSlcbiAgICBpZih0eXBlID09PSBnbC5GTE9BVCAmJiBjdHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSkge1xuICAgICAgY29udmVydEZsb2F0VG9VaW50OChwYWNrX3ZpZXcsIGFycmF5KVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHMuYXNzaWduKHBhY2tfdmlldywgYXJyYXkpXG4gICAgfVxuICAgIGlmKG5lZWRzTWlwKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgY2Zvcm1hdCwgc2hhcGVbMF0sIHNoYXBlWzFdLCAwLCBjZm9ybWF0LCBjdHlwZSwgcGFja19idWZmZXIuc3ViYXJyYXkoMCwgc2l6ZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCB4X29mZiwgeV9vZmYsIHNoYXBlWzBdLCBzaGFwZVsxXSwgY2Zvcm1hdCwgY3R5cGUsIHBhY2tfYnVmZmVyLnN1YmFycmF5KDAsIHNpemUpKVxuICAgIH1cbiAgICBpZihjdHlwZSA9PT0gZ2wuRkxPQVQpIHtcbiAgICAgIHBvb2wuZnJlZUZsb2F0MzIocGFja19idWZmZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvb2wuZnJlZVVpbnQ4KHBhY2tfYnVmZmVyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0VGV4dHVyZShnbCkge1xuICB2YXIgdGV4ID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICByZXR1cm4gdGV4XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVTaGFwZShnbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKSB7XG4gIHZhciBtYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKVxuICBpZih3aWR0aCA8IDAgfHwgd2lkdGggPiBtYXhUZXh0dXJlU2l6ZSB8fCBoZWlnaHQgPCAwIHx8IGhlaWdodCAgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuICB9XG4gIGlmKHR5cGUgPT09IGdsLkZMT0FUICYmICFnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogRmxvYXRpbmcgcG9pbnQgdGV4dHVyZXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtJylcbiAgfVxuICB2YXIgdGV4ID0gaW5pdFRleHR1cmUoZ2wpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpXG4gIHJldHVybiBuZXcgVGV4dHVyZTJEKGdsLCB0ZXgsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZURPTShnbCwgZGlyZWN0RGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKSB7XG4gIHZhciB0ZXggPSBpbml0VGV4dHVyZShnbClcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIGZvcm1hdCwgdHlwZSwgZGlyZWN0RGF0YSlcbiAgcmV0dXJuIG5ldyBUZXh0dXJlMkQoZ2wsIHRleCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKVxufVxuXG4vL0NyZWF0ZXMgYSB0ZXh0dXJlIGZyb20gYW4gbmRhcnJheVxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZUFycmF5KGdsLCBhcnJheSkge1xuICB2YXIgZHR5cGUgPSBhcnJheS5kdHlwZVxuICB2YXIgc2hhcGUgPSBhcnJheS5zaGFwZS5zbGljZSgpXG4gIHZhciBtYXhTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG4gIGlmKHNoYXBlWzBdIDwgMCB8fCBzaGFwZVswXSA+IG1heFNpemUgfHwgc2hhcGVbMV0gPCAwIHx8IHNoYXBlWzFdID4gbWF4U2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHRleHR1cmUgc2l6ZScpXG4gIH1cbiAgdmFyIHBhY2tlZCA9IGlzUGFja2VkKHNoYXBlLCBhcnJheS5zdHJpZGUuc2xpY2UoKSlcbiAgdmFyIHR5cGUgPSAwXG4gIGlmKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICB0eXBlID0gZ2wuRkxPQVRcbiAgfSBlbHNlIGlmKGR0eXBlID09PSAnZmxvYXQ2NCcpIHtcbiAgICB0eXBlID0gZ2wuRkxPQVRcbiAgICBwYWNrZWQgPSBmYWxzZVxuICAgIGR0eXBlID0gJ2Zsb2F0MzInXG4gIH0gZWxzZSBpZihkdHlwZSA9PT0gJ3VpbnQ4Jykge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgICBwYWNrZWQgPSBmYWxzZVxuICAgIGR0eXBlID0gJ3VpbnQ4J1xuICB9XG4gIHZhciBmb3JtYXQgPSAwXG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgIGZvcm1hdCA9IGdsLkxVTUlOQU5DRVxuICAgIHNoYXBlID0gW3NoYXBlWzBdLCBzaGFwZVsxXSwgMV1cbiAgICBhcnJheSA9IG5kYXJyYXkoYXJyYXkuZGF0YSwgc2hhcGUsIFthcnJheS5zdHJpZGVbMF0sIGFycmF5LnN0cmlkZVsxXSwgMV0sIGFycmF5Lm9mZnNldClcbiAgfSBlbHNlIGlmKHNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIGlmKHNoYXBlWzJdID09PSAxKSB7XG4gICAgICBmb3JtYXQgPSBnbC5BTFBIQVxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gMikge1xuICAgICAgZm9ybWF0ID0gZ2wuTFVNSU5BTkNFX0FMUEhBXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSAzKSB7XG4gICAgICBmb3JtYXQgPSBnbC5SR0JcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDQpIHtcbiAgICAgIGZvcm1hdCA9IGdsLlJHQkFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgc2hhcGUgZm9yIHBpeGVsIGNvb3JkcycpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHNoYXBlIGZvciB0ZXh0dXJlJylcbiAgfVxuICBpZih0eXBlID09PSBnbC5GTE9BVCAmJiAhZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpKSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgICBwYWNrZWQgPSBmYWxzZVxuICB9XG4gIHZhciBidWZmZXIsIGJ1Zl9zdG9yZVxuICB2YXIgc2l6ZSA9IGFycmF5LnNpemVcbiAgaWYoIXBhY2tlZCkge1xuICAgIHZhciBzdHJpZGUgPSBbc2hhcGVbMl0sIHNoYXBlWzJdKnNoYXBlWzBdLCAxXVxuICAgIGJ1Zl9zdG9yZSA9IHBvb2wubWFsbG9jKHNpemUsIGR0eXBlKVxuICAgIHZhciBidWZfYXJyYXkgPSBuZGFycmF5KGJ1Zl9zdG9yZSwgc2hhcGUsIHN0cmlkZSwgMClcbiAgICBpZigoZHR5cGUgPT09ICdmbG9hdDMyJyB8fCBkdHlwZSA9PT0gJ2Zsb2F0NjQnKSAmJiB0eXBlID09PSBnbC5VTlNJR05FRF9CWVRFKSB7XG4gICAgICBjb252ZXJ0RmxvYXRUb1VpbnQ4KGJ1Zl9hcnJheSwgYXJyYXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wcy5hc3NpZ24oYnVmX2FycmF5LCBhcnJheSlcbiAgICB9XG4gICAgYnVmZmVyID0gYnVmX3N0b3JlLnN1YmFycmF5KDAsIHNpemUpXG4gIH0gZWxzZSBpZiAoYXJyYXkub2Zmc2V0ID09PSAwICYmIGFycmF5LmRhdGEubGVuZ3RoID09PSBzaXplKSB7XG4gICAgYnVmZmVyID0gYXJyYXkuZGF0YVxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciA9IGFycmF5LmRhdGEuc3ViYXJyYXkoYXJyYXkub2Zmc2V0LCBhcnJheS5vZmZzZXQgKyBzaXplKVxuICB9XG4gIHZhciB0ZXggPSBpbml0VGV4dHVyZShnbClcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHNoYXBlWzBdLCBzaGFwZVsxXSwgMCwgZm9ybWF0LCB0eXBlLCBidWZmZXIpXG4gIGlmKCFwYWNrZWQpIHtcbiAgICBwb29sLmZyZWUoYnVmX3N0b3JlKVxuICB9XG4gIHJldHVybiBuZXcgVGV4dHVyZTJEKGdsLCB0ZXgsIHNoYXBlWzBdLCBzaGFwZVsxXSwgZm9ybWF0LCB0eXBlKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlMkQoZ2wpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IE1pc3NpbmcgYXJndW1lbnRzIGZvciB0ZXh0dXJlMmQgY29uc3RydWN0b3InKVxuICB9XG4gIGlmKCFsaW5lYXJUeXBlcykge1xuICAgIGxhenlJbml0TGluZWFyVHlwZXMoZ2wpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY3JlYXRlVGV4dHVyZVNoYXBlKGdsLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdfHxnbC5SR0JBLCBhcmd1bWVudHNbNF18fGdsLlVOU0lHTkVEX0JZVEUpXG4gIH1cbiAgaWYoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVTaGFwZShnbCwgYXJndW1lbnRzWzFdWzBdfDAsIGFyZ3VtZW50c1sxXVsxXXwwLCBhcmd1bWVudHNbMl18fGdsLlJHQkEsIGFyZ3VtZW50c1szXXx8Z2wuVU5TSUdORURfQllURSlcbiAgfVxuICBpZih0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBvYmogPSBhcmd1bWVudHNbMV1cbiAgICB2YXIgZGlyZWN0RGF0YSA9IGFjY2VwdFRleHR1cmVET00ob2JqKSA/IG9iaiA6IG9iai5yYXdcbiAgICBpZiAoZGlyZWN0RGF0YSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVET00oZ2wsIGRpcmVjdERhdGEsIG9iai53aWR0aHwwLCBvYmouaGVpZ2h0fDAsIGFyZ3VtZW50c1syXXx8Z2wuUkdCQSwgYXJndW1lbnRzWzNdfHxnbC5VTlNJR05FRF9CWVRFKVxuICAgIH0gZWxzZSBpZihvYmouc2hhcGUgJiYgb2JqLmRhdGEgJiYgb2JqLnN0cmlkZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVBcnJheShnbCwgb2JqKVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBhcmd1bWVudHMgZm9yIHRleHR1cmUyZCBjb25zdHJ1Y3RvcicpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBhbmdsZVxuXG52YXIgZnJvbVZhbHVlcyA9IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnLi9ub3JtYWxpemUnKVxudmFyIGRvdCA9IHJlcXVpcmUoJy4vZG90JylcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICAgIHZhciB0ZW1wQSA9IGZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSlcbiAgICB2YXIgdGVtcEIgPSBmcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pXG4gXG4gICAgbm9ybWFsaXplKHRlbXBBLCB0ZW1wQSlcbiAgICBub3JtYWxpemUodGVtcEIsIHRlbXBCKVxuIFxuICAgIHZhciBjb3NpbmUgPSBkb3QodGVtcEEsIHRlbXBCKVxuXG4gICAgaWYoY29zaW5lID4gMS4wKXtcbiAgICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSlcbiAgICB9ICAgICBcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2VpbFxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IDBcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gMFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyb3NzO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdXG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieVxuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYnhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGU7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdXG59IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICB2YXIgYjIgPSBiWzJdXG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleGFjdEVxdWFsc1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZsb29yXG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pXG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGxcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gM1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldIFxuICAgICAgICAgICAgdmVjWzFdID0gYVtpKzFdIFxuICAgICAgICAgICAgdmVjWzJdID0gYVtpKzJdXG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICAgICAgYVtpXSA9IHZlY1swXSBcbiAgICAgICAgICAgIGFbaSsxXSA9IHZlY1sxXSBcbiAgICAgICAgICAgIGFbaSsyXSA9IHZlY1syXVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYVxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVBTSUxPTjogcmVxdWlyZSgnLi9lcHNpbG9uJylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgYW5nbGU6IHJlcXVpcmUoJy4vYW5nbGUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBtaW46IHJlcXVpcmUoJy4vbWluJylcbiAgLCBtYXg6IHJlcXVpcmUoJy4vbWF4JylcbiAgLCBmbG9vcjogcmVxdWlyZSgnLi9mbG9vcicpXG4gICwgY2VpbDogcmVxdWlyZSgnLi9jZWlsJylcbiAgLCByb3VuZDogcmVxdWlyZSgnLi9yb3VuZCcpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHNjYWxlQW5kQWRkOiByZXF1aXJlKCcuL3NjYWxlQW5kQWRkJylcbiAgLCBkaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4gICwgZGlzdDogcmVxdWlyZSgnLi9kaXN0JylcbiAgLCBzcXVhcmVkRGlzdGFuY2U6IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiAgLCBzcXJEaXN0OiByZXF1aXJlKCcuL3NxckRpc3QnKVxuICAsIGxlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGgnKVxuICAsIGxlbjogcmVxdWlyZSgnLi9sZW4nKVxuICAsIHNxdWFyZWRMZW5ndGg6IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4gICwgc3FyTGVuOiByZXF1aXJlKCcuL3NxckxlbicpXG4gICwgbmVnYXRlOiByZXF1aXJlKCcuL25lZ2F0ZScpXG4gICwgaW52ZXJzZTogcmVxdWlyZSgnLi9pbnZlcnNlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQ0OiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDQnKVxuICAsIHRyYW5zZm9ybU1hdDM6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MycpXG4gICwgdHJhbnNmb3JtUXVhdDogcmVxdWlyZSgnLi90cmFuc2Zvcm1RdWF0JylcbiAgLCByb3RhdGVYOiByZXF1aXJlKCcuL3JvdGF0ZVgnKVxuICAsIHJvdGF0ZVk6IHJlcXVpcmUoJy4vcm90YXRlWScpXG4gICwgcm90YXRlWjogcmVxdWlyZSgnLi9yb3RhdGVaJylcbiAgLCBmb3JFYWNoOiByZXF1aXJlKCcuL2ZvckVhY2gnKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICBvdXRbMl0gPSAxLjAgLyBhWzJdXG4gIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeilcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl1cbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KVxuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpXG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheilcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtYXg7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKVxuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbWluO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZTtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF1cbiAgICBvdXRbMV0gPSAtYVsxXVxuICAgIG91dFsyXSA9IC1hWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqelxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW5cbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlblxuICAgIH1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb207XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMFxuXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIHZhciB6ID0gKE1hdGgucmFuZG9tKCkgKiAyLjApIC0gMS4wXG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlXG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlXG4gICAgb3V0WzJdID0geiAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieSA9IGJbMV1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyBUcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICAgIHZhciBweiA9IGFbMl0gLSBielxuXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYnkgKyBweSAqIGNjIC0gcHogKiBzY1xuICAgIG91dFsyXSA9IGJ6ICsgcHkgKiBzYyArIHB6ICogY2NcblxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieCA9IGJbMF1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyB0cmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweiA9IGFbMl0gLSBielxuICAgIFxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcbiAgXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB6ICogc2MgKyBweCAqIGNjXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGJ6ICsgcHogKiBjYyAtIHB4ICogc2NcbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVaO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieSA9IGJbMV1cblxuICAgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHggPSBhWzBdIC0gYnhcbiAgICB2YXIgcHkgPSBhWzFdIC0gYnlcbiAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB4ICogY2MgLSBweSAqIHNjXG4gICAgb3V0WzFdID0gYnkgKyBweCAqIHNjICsgcHkgKiBjY1xuICAgIG91dFsyXSA9IGFbMl1cbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3VuZFxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGU7XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiXG4gICAgb3V0WzFdID0gYVsxXSAqIGJcbiAgICBvdXRbMl0gPSBhWzJdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpXG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpXG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl1cbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQzO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl1cbiAgICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl1cbiAgICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN11cbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQ0O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XVxuICAgIHcgPSB3IHx8IDEuMFxuICAgIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3XG4gICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHdcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHdcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1RdWF0O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogelxuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXlcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZ3MpIHtcclxuICBpZiAodHlwZW9mIHN0cmluZ3MgPT09ICdzdHJpbmcnKSBzdHJpbmdzID0gW3N0cmluZ3NdXHJcbiAgdmFyIGV4cHJzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSlcclxuICB2YXIgcGFydHMgPSBbXVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGgtMTsgaSsrKSB7XHJcbiAgICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0sIGV4cHJzW2ldIHx8ICcnKVxyXG4gIH1cclxuICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0pXHJcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXHJcbn1cclxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGEiLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiY3dpc2UtY29tcGlsZXJcIilcblxudmFyIEVtcHR5UHJvYyA9IHtcbiAgYm9keTogXCJcIixcbiAgYXJnczogW10sXG4gIHRoaXNWYXJzOiBbXSxcbiAgbG9jYWxWYXJzOiBbXVxufVxuXG5mdW5jdGlvbiBmaXh1cCh4KSB7XG4gIGlmKCF4KSB7XG4gICAgcmV0dXJuIEVtcHR5UHJvY1xuICB9XG4gIGZvcih2YXIgaT0wOyBpPHguYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhID0geC5hcmdzW2ldXG4gICAgaWYoaSA9PT0gMCkge1xuICAgICAgeC5hcmdzW2ldID0ge25hbWU6IGEsIGx2YWx1ZTp0cnVlLCBydmFsdWU6ICEheC5ydmFsdWUsIGNvdW50OnguY291bnR8fDEgfVxuICAgIH0gZWxzZSB7XG4gICAgICB4LmFyZ3NbaV0gPSB7bmFtZTogYSwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6IDF9XG4gICAgfVxuICB9XG4gIGlmKCF4LnRoaXNWYXJzKSB7XG4gICAgeC50aGlzVmFycyA9IFtdXG4gIH1cbiAgaWYoIXgubG9jYWxWYXJzKSB7XG4gICAgeC5sb2NhbFZhcnMgPSBbXVxuICB9XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIHBjb21waWxlKHVzZXJfYXJncykge1xuICByZXR1cm4gY29tcGlsZSh7XG4gICAgYXJnczogICAgIHVzZXJfYXJncy5hcmdzLFxuICAgIHByZTogICAgICBmaXh1cCh1c2VyX2FyZ3MucHJlKSxcbiAgICBib2R5OiAgICAgZml4dXAodXNlcl9hcmdzLmJvZHkpLFxuICAgIHBvc3Q6ICAgICBmaXh1cCh1c2VyX2FyZ3MucHJvYyksXG4gICAgZnVuY05hbWU6IHVzZXJfYXJncy5mdW5jTmFtZVxuICB9KVxufVxuXG5mdW5jdGlvbiBtYWtlT3AodXNlcl9hcmdzKSB7XG4gIHZhciBhcmdzID0gW11cbiAgZm9yKHZhciBpPTA7IGk8dXNlcl9hcmdzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzLnB1c2goXCJhXCIraSlcbiAgfVxuICB2YXIgd3JhcHBlciA9IG5ldyBGdW5jdGlvbihcIlBcIiwgW1xuICAgIFwicmV0dXJuIGZ1bmN0aW9uIFwiLCB1c2VyX2FyZ3MuZnVuY05hbWUsIFwiX25kYXJyYXlvcHMoXCIsIGFyZ3Muam9pbihcIixcIiksIFwiKSB7UChcIiwgYXJncy5qb2luKFwiLFwiKSwgXCIpO3JldHVybiBhMH1cIlxuICBdLmpvaW4oXCJcIikpXG4gIHJldHVybiB3cmFwcGVyKHBjb21waWxlKHVzZXJfYXJncykpXG59XG5cbnZhciBhc3NpZ25fb3BzID0ge1xuICBhZGQ6ICBcIitcIixcbiAgc3ViOiAgXCItXCIsXG4gIG11bDogIFwiKlwiLFxuICBkaXY6ICBcIi9cIixcbiAgbW9kOiAgXCIlXCIsXG4gIGJhbmQ6IFwiJlwiLFxuICBib3I6ICBcInxcIixcbiAgYnhvcjogXCJeXCIsXG4gIGxzaGlmdDogXCI8PFwiLFxuICByc2hpZnQ6IFwiPj5cIixcbiAgcnJzaGlmdDogXCI+Pj5cIlxufVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGlkIGluIGFzc2lnbl9vcHMpIHtcbiAgICB2YXIgb3AgPSBhc3NpZ25fb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLFxuICAgICAgICAgICAgIGJvZHk6IFwiYT1iXCIrb3ArXCJjXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYVwiK29wK1wiPWJcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic1wiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1iXCIrb3ArXCJzXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkK1wic1wiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic2VxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhXCIrb3ArXCI9c1wifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIHVuYXJ5X29wcyA9IHtcbiAgbm90OiBcIiFcIixcbiAgYm5vdDogXCJ+XCIsXG4gIG5lZzogXCItXCIsXG4gIHJlY2lwOiBcIjEuMC9cIlxufVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGlkIGluIHVuYXJ5X29wcykge1xuICAgIHZhciBvcCA9IHVuYXJ5X29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1cIitvcCtcImJcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9XCIrb3ArXCJhXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgY291bnQ6IDIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIGJpbmFyeV9vcHMgPSB7XG4gIGFuZDogXCImJlwiLFxuICBvcjogXCJ8fFwiLFxuICBlcTogXCI9PT1cIixcbiAgbmVxOiBcIiE9PVwiLFxuICBsdDogXCI8XCIsXG4gIGd0OiBcIj5cIixcbiAgbGVxOiBcIjw9XCIsXG4gIGdlcTogXCI+PVwiXG59XG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIGJpbmFyeV9vcHMpIHtcbiAgICB2YXIgb3AgPSBiaW5hcnlfb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiLCBcImNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wiY1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCIsXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiLCBcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wic1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1hXCIrb3ArXCJiXCJ9LFxuICAgICAgcnZhbHVlOnRydWUsXG4gICAgICBjb3VudDoyLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YVwiK29wK1wic1wifSxcbiAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgY291bnQ6MixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfdW5hcnkgPSBbXG4gIFwiYWJzXCIsXG4gIFwiYWNvc1wiLFxuICBcImFzaW5cIixcbiAgXCJhdGFuXCIsXG4gIFwiY2VpbFwiLFxuICBcImNvc1wiLFxuICBcImV4cFwiLFxuICBcImZsb29yXCIsXG4gIFwibG9nXCIsXG4gIFwicm91bmRcIixcbiAgXCJzaW5cIixcbiAgXCJzcXJ0XCIsXG4gIFwidGFuXCJcbl1cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfdW5hcnkubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IG1hdGhfdW5hcnlbaV1cbiAgICBleHBvcnRzW2ZdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnczogW1wiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6IFtcImFcIl0sIGJvZHk6XCJhPXRoaXNfZihhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcImVxXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfY29tbSA9IFtcbiAgXCJtYXhcIixcbiAgXCJtaW5cIixcbiAgXCJhdGFuMlwiLFxuICBcInBvd1wiXG5dXG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfY29tbS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmPSBtYXRoX2NvbW1baV1cbiAgICBleHBvcnRzW2ZdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYixjKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGZcbiAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYixjKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJzXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wiZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihhLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wiZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJzZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYSxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOnRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDoyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJzZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfbm9uY29tbSA9IFtcbiAgXCJhdGFuMlwiLFxuICBcInBvd1wiXG5dXG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfbm9uY29tbS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmPSBtYXRoX25vbmNvbW1baV1cbiAgICBleHBvcnRzW2YrXCJvcFwiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGMsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BzXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGMsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BzXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIsYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcGVxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BzZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYixhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOnRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDoyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcHNlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICB9XG59KSgpO1xuXG5leHBvcnRzLmFueSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwiaWYoYSl7cmV0dXJuIHRydWV9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIGZhbHNlXCJ9LFxuICBmdW5jTmFtZTogXCJhbnlcIlxufSlcblxuZXhwb3J0cy5hbGwgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcInhcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcImlmKCF4KXtyZXR1cm4gZmFsc2V9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIHRydWVcIn0sXG4gIGZ1bmNOYW1lOiBcImFsbFwiXG59KVxuXG5leHBvcnRzLnN1bSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJ0aGlzX3MrPWFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcInN1bVwiXG59KVxuXG5leHBvcnRzLnByb2QgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MVwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwidGhpc19zKj1hXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJwcm9kXCJcbn0pXG5cbmV4cG9ydHMubm9ybTJzcXVhcmVkID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6Mn1dLCBib2R5OiBcInRoaXNfcys9YSphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMnNxdWFyZWRcIlxufSlcbiAgXG5leHBvcnRzLm5vcm0yID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6Mn1dLCBib2R5OiBcInRoaXNfcys9YSphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gTWF0aC5zcXJ0KHRoaXNfcylcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm0yXCJcbn0pXG4gIFxuXG5leHBvcnRzLm5vcm1pbmYgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDo0fV0sIGJvZHk6XCJpZigtYT50aGlzX3Mpe3RoaXNfcz0tYX1lbHNlIGlmKGE+dGhpc19zKXt0aGlzX3M9YX1cIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm1pbmZcIlxufSlcblxuZXhwb3J0cy5ub3JtMSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjN9XSwgYm9keTogXCJ0aGlzX3MrPWE8MD8tYTphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMVwiXG59KVxuXG5leHBvcnRzLnN1cCA9IGNvbXBpbGUoe1xuICBhcmdzOiBbIFwiYXJyYXlcIiBdLFxuICBwcmU6XG4gICB7IGJvZHk6IFwidGhpc19oPS1JbmZpbml0eVwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIGJvZHk6XG4gICB7IGJvZHk6IFwiaWYoX2lubGluZV8xX2FyZzBfPnRoaXNfaCl0aGlzX2g9X2lubGluZV8xX2FyZzBfXCIsXG4gICAgIGFyZ3M6IFt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6Mn0gXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIHBvc3Q6XG4gICB7IGJvZHk6IFwicmV0dXJuIHRoaXNfaFwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH1cbiB9KVxuXG5leHBvcnRzLmluZiA9IGNvbXBpbGUoe1xuICBhcmdzOiBbIFwiYXJyYXlcIiBdLFxuICBwcmU6XG4gICB7IGJvZHk6IFwidGhpc19oPUluZmluaXR5XCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgYm9keTpcbiAgIHsgYm9keTogXCJpZihfaW5saW5lXzFfYXJnMF88dGhpc19oKXRoaXNfaD1faW5saW5lXzFfYXJnMF9cIixcbiAgICAgYXJnczogW3tcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcwX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoyfSBdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgcG9zdDpcbiAgIHsgYm9keTogXCJyZXR1cm4gdGhpc19oXCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfVxuIH0pXG5cbmV4cG9ydHMuYXJnbWluID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiaW5kZXhcIixcImFycmF5XCIsXCJzaGFwZVwiXSxcbiAgcHJlOntcbiAgICBib2R5Olwie3RoaXNfdj1JbmZpbml0eTt0aGlzX2k9X2lubGluZV8wX2FyZzJfLnNsaWNlKDApfVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMl9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6MX1cbiAgICAgIF0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltdfSxcbiAgYm9keTp7XG4gICAgYm9keTpcIntpZihfaW5saW5lXzFfYXJnMV88dGhpc192KXt0aGlzX3Y9X2lubGluZV8xX2FyZzFfO2Zvcih2YXIgX2lubGluZV8xX2s9MDtfaW5saW5lXzFfazxfaW5saW5lXzFfYXJnMF8ubGVuZ3RoOysrX2lubGluZV8xX2spe3RoaXNfaVtfaW5saW5lXzFfa109X2lubGluZV8xX2FyZzBfW19pbmxpbmVfMV9rXX19fVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfV0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltcIl9pbmxpbmVfMV9rXCJdfSxcbiAgcG9zdDp7XG4gICAgYm9keTpcIntyZXR1cm4gdGhpc19pfVwiLFxuICAgIGFyZ3M6W10sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCJdLFxuICAgIGxvY2FsVmFyczpbXX1cbn0pXG5cbmV4cG9ydHMuYXJnbWF4ID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiaW5kZXhcIixcImFycmF5XCIsXCJzaGFwZVwiXSxcbiAgcHJlOntcbiAgICBib2R5Olwie3RoaXNfdj0tSW5maW5pdHk7dGhpc19pPV9pbmxpbmVfMF9hcmcyXy5zbGljZSgwKX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzJfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjF9XG4gICAgICBdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXX0sXG4gIGJvZHk6e1xuICAgIGJvZHk6XCJ7aWYoX2lubGluZV8xX2FyZzFfPnRoaXNfdil7dGhpc192PV9pbmxpbmVfMV9hcmcxXztmb3IodmFyIF9pbmxpbmVfMV9rPTA7X2lubGluZV8xX2s8X2lubGluZV8xX2FyZzBfLmxlbmd0aDsrK19pbmxpbmVfMV9rKXt0aGlzX2lbX2lubGluZV8xX2tdPV9pbmxpbmVfMV9hcmcwX1tfaW5saW5lXzFfa119fX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn1dLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXCJfaW5saW5lXzFfa1wiXX0sXG4gIHBvc3Q6e1xuICAgIGJvZHk6XCJ7cmV0dXJuIHRoaXNfaX1cIixcbiAgICBhcmdzOltdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiXSxcbiAgICBsb2NhbFZhcnM6W119XG59KSAgXG5cbmV4cG9ydHMucmFuZG9tID0gbWFrZU9wKHtcbiAgYXJnczogW1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5yYW5kb21cIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgYm9keToge2FyZ3M6IFtcImFcIl0sIGJvZHk6XCJhPXRoaXNfZigpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gIGZ1bmNOYW1lOiBcInJhbmRvbVwiXG59KVxuXG5leHBvcnRzLmFzc2lnbiA9IG1ha2VPcCh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sIGJvZHk6XCJhPWJcIn0sXG4gIGZ1bmNOYW1lOiBcImFzc2lnblwiIH0pXG5cbmV4cG9ydHMuYXNzaWducyA9IG1ha2VPcCh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLCBib2R5OlwiYT1iXCJ9LFxuICBmdW5jTmFtZTogXCJhc3NpZ25zXCIgfSlcblxuXG5leHBvcnRzLmVxdWFscyA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJ4XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9LFxuICAgICAgICAgICAgICAge25hbWU6XCJ5XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgXG4gICAgICAgIGJvZHk6IFwiaWYoeCE9PXkpe3JldHVybiBmYWxzZX1cIiwgXG4gICAgICAgIGxvY2FsVmFyczogW10sIFxuICAgICAgICB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiB0cnVlXCJ9LFxuICBmdW5jTmFtZTogXCJlcXVhbHNcIlxufSlcblxuXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG52YXIgZG9fY29udmVydCA9IHJlcXVpcmUoXCIuL2RvQ29udmVydC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnZlcnQoYXJyLCByZXN1bHQpIHtcbiAgdmFyIHNoYXBlID0gW10sIGMgPSBhcnIsIHN6ID0gMVxuICB3aGlsZShBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgc2hhcGUucHVzaChjLmxlbmd0aClcbiAgICBzeiAqPSBjLmxlbmd0aFxuICAgIGMgPSBjWzBdXG4gIH1cbiAgaWYoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5kYXJyYXkoKVxuICB9XG4gIGlmKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBuZGFycmF5KG5ldyBGbG9hdDY0QXJyYXkoc3opLCBzaGFwZSlcbiAgfVxuICBkb19jb252ZXJ0KHJlc3VsdCwgYXJyKVxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKCdjd2lzZS1jb21waWxlcicpKHtcImFyZ3NcIjpbXCJhcnJheVwiLFwic2NhbGFyXCIsXCJpbmRleFwiXSxcInByZVwiOntcImJvZHlcIjpcInt9XCIsXCJhcmdzXCI6W10sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W119LFwiYm9keVwiOntcImJvZHlcIjpcIntcXG52YXIgX2lubGluZV8xX3Y9X2lubGluZV8xX2FyZzFfLF9pbmxpbmVfMV9pXFxuZm9yKF9pbmxpbmVfMV9pPTA7X2lubGluZV8xX2k8X2lubGluZV8xX2FyZzJfLmxlbmd0aC0xOysrX2lubGluZV8xX2kpIHtcXG5faW5saW5lXzFfdj1faW5saW5lXzFfdltfaW5saW5lXzFfYXJnMl9bX2lubGluZV8xX2ldXVxcbn1cXG5faW5saW5lXzFfYXJnMF89X2lubGluZV8xX3ZbX2lubGluZV8xX2FyZzJfW19pbmxpbmVfMV9hcmcyXy5sZW5ndGgtMV1dXFxufVwiLFwiYXJnc1wiOlt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOnRydWUsXCJydmFsdWVcIjpmYWxzZSxcImNvdW50XCI6MX0se1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzFfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjF9LHtcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcyX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjo0fV0sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W1wiX2lubGluZV8xX2lcIixcIl9pbmxpbmVfMV92XCJdfSxcInBvc3RcIjp7XCJib2R5XCI6XCJ7fVwiLFwiYXJnc1wiOltdLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltdfSxcImZ1bmNOYW1lXCI6XCJjb252ZXJ0XCIsXCJibG9ja1NpemVcIjo2NH0pXG4iLCJ2YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKFwiaXMtYnVmZmVyXCIpXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcblxuICBpZihkaW1lbnNpb24gPT09IC0xKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIHRyaXZpYWwgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cblxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSppXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICB2YXIgc2hhcGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIHZhciBzdHJpZGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIGNvZGUucHVzaChcbiAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiICsgc2hhcGVBcmcgKyBcIixcIiArIHN0cmlkZUFyZyArIFwiLGQpe3RoaXMuZGF0YT1hXCIsXG4gICAgICBcInRoaXMuc2hhcGU9W1wiICsgc2hhcGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLnN0cmlkZVswXSk+TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLnN0cmlkZVswXSksczE9TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pLHMyPU1hdGguYWJzKHRoaXMuc3RyaWRlWzJdKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cblxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cblxuICAvL3ZpZXcuZ2V0KGkwLCAuLi4pOlxuICBjb2RlLnB1c2goXCJwcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuZ2V0KFwiK2luZGV4X3N0citcIil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdfVwiKVxuICB9XG5cbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLnNoYXBlW1wiLCBpLCBcIl06aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiK2kgKyBcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCIgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuXG4gIC8vdmlldy5zdGVwKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3N0ZXAoXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixjPXRoaXMub2Zmc2V0LGQ9MCxjZWlsPU1hdGguY2VpbFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicpe1xcXG5kPWlcIitpK1wifDA7XFxcbmlmKGQ8MCl7XFxcbmMrPWJcIitpK1wiKihhXCIraStcIi0xKTtcXFxuYVwiK2krXCI9Y2VpbCgtYVwiK2krXCIvZClcXFxufWVsc2V7XFxcbmFcIitpK1wiPWNlaWwoYVwiK2krXCIvZClcXFxufVxcXG5iXCIraStcIio9ZFxcXG59XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsYyl9XCIpXG5cbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuc3RyaWRlW1wiK2krXCJdKmlcIitpK1wiKXwwfWVsc2V7YS5wdXNoKHRoaXMuc2hhcGVbXCIraStcIl0pO2IucHVzaCh0aGlzLnN0cmlkZVtcIitpK1wiXSl9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG5cbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJidWZmZXJcIlxuICB9XG4gIGlmKGhhc1R5cGVkQXJyYXlzKSB7XG4gICAgc3dpdGNoKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCJcbiAgICB9XG4gIH1cbiAgaWYoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBcImFycmF5XCJcbiAgfVxuICByZXR1cm4gXCJnZW5lcmljXCJcbn1cblxudmFyIENBQ0hFRF9DT05TVFJVQ1RPUlMgPSB7XG4gIFwiZmxvYXQzMlwiOltdLFxuICBcImZsb2F0NjRcIjpbXSxcbiAgXCJpbnQ4XCI6W10sXG4gIFwiaW50MTZcIjpbXSxcbiAgXCJpbnQzMlwiOltdLFxuICBcInVpbnQ4XCI6W10sXG4gIFwidWludDE2XCI6W10sXG4gIFwidWludDMyXCI6W10sXG4gIFwiYXJyYXlcIjpbXSxcbiAgXCJ1aW50OF9jbGFtcGVkXCI6W10sXG4gIFwiYnVmZmVyXCI6W10sXG4gIFwiZ2VuZXJpY1wiOltdXG59XG5cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gQ0FDSEVEX0NPTlNUUlVDVE9SUykge1xuICAgIENBQ0hFRF9DT05TVFJVQ1RPUlNbaWRdLnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGlkLCAtMSkpXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXVxuICAgIHJldHVybiBjdG9yKFtdKVxuICB9IGVsc2UgaWYodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBkYXRhID0gW2RhdGFdXG4gIH1cbiAgaWYoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNoYXBlID0gWyBkYXRhLmxlbmd0aCBdXG4gIH1cbiAgdmFyIGQgPSBzaGFwZS5sZW5ndGhcbiAgaWYoc3RyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpZGUgPSBuZXcgQXJyYXkoZClcbiAgICBmb3IodmFyIGk9ZC0xLCBzej0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIHN0cmlkZVtpXSA9IHN6XG4gICAgICBzeiAqPSBzaGFwZVtpXVxuICAgIH1cbiAgfVxuICBpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldCA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgIGlmKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgb2Zmc2V0IC09IChzaGFwZVtpXS0xKSpzdHJpZGVbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGR0eXBlID0gYXJyYXlEVHlwZShkYXRhKVxuICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1cbiAgd2hpbGUoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkKzEpIHtcbiAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGgtMSkpXG4gIH1cbiAgdmFyIGN0b3IgPSBjdG9yX2xpc3RbZCsxXVxuICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlZE5EQXJyYXlDdG9yXG4iLCIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL29tZ2dpZlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG4vL1xuLy8gb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2Rlcixcbi8vIGluY2x1ZGluZyBhbmltYXRpb24gYW5kIGNvbXByZXNzaW9uLiAgSXQgZG9lcyBub3QgcmVseSBvbiBhbnkgc3BlY2lmaWNcbi8vIHVuZGVybHlpbmcgc3lzdGVtLCBzbyBzaG91bGQgcnVuIGluIHRoZSBicm93c2VyLCBOb2RlLCBvciBQbGFzay5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEdpZldyaXRlcihidWYsIHdpZHRoLCBoZWlnaHQsIGdvcHRzKSB7XG4gIHZhciBwID0gMDtcblxuICB2YXIgZ29wdHMgPSBnb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogZ29wdHM7XG4gIHZhciBsb29wX2NvdW50ID0gZ29wdHMubG9vcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLmxvb3A7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZSA9IGdvcHRzLnBhbGV0dGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5wYWxldHRlO1xuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwIHx8IHdpZHRoID4gNjU1MzUgfHwgaGVpZ2h0ID4gNjU1MzUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpO1xuXG4gIGZ1bmN0aW9uIGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSkge1xuICAgIHZhciBudW1fY29sb3JzID0gcGFsZXR0ZS5sZW5ndGg7XG4gICAgaWYgKG51bV9jb2xvcnMgPCAyIHx8IG51bV9jb2xvcnMgPiAyNTYgfHwgIG51bV9jb2xvcnMgJiAobnVtX2NvbG9ycy0xKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlL2NvbG9yIGxlbmd0aCwgbXVzdCBiZSBwb3dlciBvZiAyIGFuZCAyIC4uIDI1Ni5cIik7XG4gICAgfVxuICAgIHJldHVybiBudW1fY29sb3JzO1xuICB9XG5cbiAgLy8gLSBIZWFkZXIuXG4gIGJ1ZltwKytdID0gMHg0NzsgYnVmW3ArK10gPSAweDQ5OyBidWZbcCsrXSA9IDB4NDY7ICAvLyBHSUZcbiAgYnVmW3ArK10gPSAweDM4OyBidWZbcCsrXSA9IDB4Mzk7IGJ1ZltwKytdID0gMHg2MTsgIC8vIDg5YVxuXG4gIC8vIEhhbmRsaW5nIG9mIEdsb2JhbCBDb2xvciBUYWJsZSAocGFsZXR0ZSkgYW5kIGJhY2tncm91bmQgaW5kZXguXG4gIHZhciBncF9udW1fY29sb3JzX3BvdzIgPSAwO1xuICB2YXIgYmFja2dyb3VuZCA9IDA7XG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIHZhciBncF9udW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhnbG9iYWxfcGFsZXR0ZSk7XG4gICAgd2hpbGUgKGdwX251bV9jb2xvcnMgPj49IDEpICsrZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGdwX251bV9jb2xvcnMgPSAxIDw8IGdwX251bV9jb2xvcnNfcG93MjtcbiAgICAtLWdwX251bV9jb2xvcnNfcG93MjtcbiAgICBpZiAoZ29wdHMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZ29wdHMuYmFja2dyb3VuZDtcbiAgICAgIGlmIChiYWNrZ3JvdW5kID49IGdwX251bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgIC8vIFRoZSBHSUYgc3BlYyBzdGF0ZXMgdGhhdCBhIGJhY2tncm91bmQgaW5kZXggb2YgMCBzaG91bGQgYmUgaWdub3JlZCwgc29cbiAgICAgIC8vIHRoaXMgaXMgcHJvYmFibHkgYSBtaXN0YWtlIGFuZCB5b3UgcmVhbGx5IHdhbnQgdG8gc2V0IGl0IHRvIGFub3RoZXJcbiAgICAgIC8vIHNsb3QgaW4gdGhlIHBhbGV0dGUuICBCdXQgYWN0dWFsbHkgaW4gdGhlIGVuZCBtb3N0IGJyb3dzZXJzLCBldGMgZW5kXG4gICAgICAvLyB1cCBpZ25vcmluZyB0aGlzIGFsbW9zdCBjb21wbGV0ZWx5IChpbmNsdWRpbmcgZm9yIGRpc3Bvc2UgYmFja2dyb3VuZCkuXG4gICAgICBpZiAoYmFja2dyb3VuZCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBleHBsaWNpdGx5IHBhc3NlZCBhcyAwLlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIC8vIE5PVEUoZGVhbm0pOiB3L2ggYXBwYXJlbnRseSBpZ25vcmVkIGJ5IGltcGxlbWVudGF0aW9ucywgYnV0IHNldCBhbnl3YXkuXG4gIGJ1ZltwKytdID0gd2lkdGggJiAweGZmOyBidWZbcCsrXSA9IHdpZHRoID4+IDggJiAweGZmO1xuICBidWZbcCsrXSA9IGhlaWdodCAmIDB4ZmY7IGJ1ZltwKytdID0gaGVpZ2h0ID4+IDggJiAweGZmO1xuICAvLyBOT1RFOiBJbmRpY2F0ZXMgMC1icHAgb3JpZ2luYWwgY29sb3IgcmVzb2x1dGlvbiAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gKGdsb2JhbF9wYWxldHRlICE9PSBudWxsID8gMHg4MCA6IDApIHwgIC8vIEdsb2JhbCBDb2xvciBUYWJsZSBGbGFnLlxuICAgICAgICAgICAgIGdwX251bV9jb2xvcnNfcG93MjsgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gYmFja2dyb3VuZDsgIC8vIEJhY2tncm91bmQgQ29sb3IgSW5kZXguXG4gIGJ1ZltwKytdID0gMDsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgLy8gLSBHbG9iYWwgQ29sb3IgVGFibGVcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZ2xvYmFsX3BhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIHJnYiA9IGdsb2JhbF9wYWxldHRlW2ldO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3BfY291bnQgIT09IG51bGwpIHsgIC8vIE5ldHNjYXBlIGJsb2NrIGZvciBsb29waW5nLlxuICAgIGlmIChsb29wX2NvdW50IDwgMCB8fCBsb29wX2NvdW50ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb29wIGNvdW50IGludmFsaWQuXCIpXG4gICAgLy8gRXh0ZW5zaW9uIGNvZGUsIGxhYmVsLCBhbmQgbGVuZ3RoLlxuICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGZmOyBidWZbcCsrXSA9IDB4MGI7XG4gICAgLy8gTkVUU0NBUEUyLjBcbiAgICBidWZbcCsrXSA9IDB4NGU7IGJ1ZltwKytdID0gMHg0NTsgYnVmW3ArK10gPSAweDU0OyBidWZbcCsrXSA9IDB4NTM7XG4gICAgYnVmW3ArK10gPSAweDQzOyBidWZbcCsrXSA9IDB4NDE7IGJ1ZltwKytdID0gMHg1MDsgYnVmW3ArK10gPSAweDQ1O1xuICAgIGJ1ZltwKytdID0gMHgzMjsgYnVmW3ArK10gPSAweDJlOyBidWZbcCsrXSA9IDB4MzA7XG4gICAgLy8gU3ViLWJsb2NrXG4gICAgYnVmW3ArK10gPSAweDAzOyBidWZbcCsrXSA9IDB4MDE7XG4gICAgYnVmW3ArK10gPSBsb29wX2NvdW50ICYgMHhmZjsgYnVmW3ArK10gPSBsb29wX2NvdW50ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gMHgwMDsgIC8vIFRlcm1pbmF0b3IuXG4gIH1cblxuXG4gIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCBpbmRleGVkX3BpeGVscywgb3B0cykge1xuICAgIGlmIChlbmRlZCA9PT0gdHJ1ZSkgeyAtLXA7IGVuZGVkID0gZmFsc2U7IH0gIC8vIFVuLWVuZC5cblxuICAgIG9wdHMgPSBvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBvcHRzO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IEJvdW5kcyBjaGVjayB4LCB5LiAgRG8gdGhleSBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgdmlydHVhbFxuICAgIC8vIGNhbnZhcyB3aWR0aC9oZWlnaHQsIEkgaW1hZ2luZT9cbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IDY1NTM1IHx8IHkgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIngveSBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKHcgPD0gMCB8fCBoIDw9IDAgfHwgdyA+IDY1NTM1IHx8IGggPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKGluZGV4ZWRfcGl4ZWxzLmxlbmd0aCA8IHcgKiBoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBwaXhlbHMgZm9yIHRoZSBmcmFtZSBzaXplLlwiKTtcblxuICAgIHZhciB1c2luZ19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICB2YXIgcGFsZXR0ZSA9IG9wdHMucGFsZXR0ZTtcbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpIHtcbiAgICAgIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgIHBhbGV0dGUgPSBnbG9iYWxfcGFsZXR0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBlaXRoZXIgYSBsb2NhbCBvciBnbG9iYWwgcGFsZXR0ZS5cIik7XG5cbiAgICB2YXIgbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtaW5fY29kZV9zaXplIChwb3dlciBvZiAyKSwgZGVzdHJveWluZyBudW1fY29sb3JzLlxuICAgIHZhciBtaW5fY29kZV9zaXplID0gMDtcbiAgICB3aGlsZSAobnVtX2NvbG9ycyA+Pj0gMSkgKyttaW5fY29kZV9zaXplO1xuICAgIG51bV9jb2xvcnMgPSAxIDw8IG1pbl9jb2RlX3NpemU7ICAvLyBOb3cgd2UgY2FuIGVhc2lseSBnZXQgaXQgYmFjay5cblxuICAgIHZhciBkZWxheSA9IG9wdHMuZGVsYXkgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRlbGF5O1xuXG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyAgICAgMCAtICAgTm8gZGlzcG9zYWwgc3BlY2lmaWVkLiBUaGUgZGVjb2RlciBpc1xuICAgIC8vICAgICAgICAgICBub3QgcmVxdWlyZWQgdG8gdGFrZSBhbnkgYWN0aW9uLlxuICAgIC8vICAgICAxIC0gICBEbyBub3QgZGlzcG9zZS4gVGhlIGdyYXBoaWMgaXMgdG8gYmUgbGVmdFxuICAgIC8vICAgICAgICAgICBpbiBwbGFjZS5cbiAgICAvLyAgICAgMiAtICAgUmVzdG9yZSB0byBiYWNrZ3JvdW5kIGNvbG9yLiBUaGUgYXJlYSB1c2VkIGJ5IHRoZVxuICAgIC8vICAgICAgICAgICBncmFwaGljIG11c3QgYmUgcmVzdG9yZWQgdG8gdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgIDMgLSAgIFJlc3RvcmUgdG8gcHJldmlvdXMuIFRoZSBkZWNvZGVyIGlzIHJlcXVpcmVkIHRvXG4gICAgLy8gICAgICAgICAgIHJlc3RvcmUgdGhlIGFyZWEgb3ZlcndyaXR0ZW4gYnkgdGhlIGdyYXBoaWMgd2l0aFxuICAgIC8vICAgICAgICAgICB3aGF0IHdhcyB0aGVyZSBwcmlvciB0byByZW5kZXJpbmcgdGhlIGdyYXBoaWMuXG4gICAgLy8gIDQtNyAtICAgIFRvIGJlIGRlZmluZWQuXG4gICAgLy8gTk9URShkZWFubSk6IERpc3Bvc2UgYmFja2dyb3VuZCBkb2Vzbid0IHJlYWxseSB3b3JrLCBhcHBhcmVudGx5IG1vc3RcbiAgICAvLyBicm93c2VycyBpZ25vcmUgdGhlIGJhY2tncm91bmQgcGFsZXR0ZSBpbmRleCBhbmQgY2xlYXIgdG8gdHJhbnNwYXJlbmN5LlxuICAgIHZhciBkaXNwb3NhbCA9IG9wdHMuZGlzcG9zYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRpc3Bvc2FsO1xuICAgIGlmIChkaXNwb3NhbCA8IDAgfHwgZGlzcG9zYWwgPiAzKSAgLy8gNC03IGlzIHJlc2VydmVkLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcG9zYWwgb3V0IG9mIHJhbmdlLlwiKTtcblxuICAgIHZhciB1c2VfdHJhbnNwYXJlbmN5ID0gZmFsc2U7XG4gICAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gMDtcbiAgICBpZiAob3B0cy50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudHJhbnNwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVzZV90cmFuc3BhcmVuY3kgPSB0cnVlO1xuICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBvcHRzLnRyYW5zcGFyZW50O1xuICAgICAgaWYgKHRyYW5zcGFyZW50X2luZGV4IDwgMCB8fCB0cmFuc3BhcmVudF9pbmRleCA+PSBudW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2FsICE9PSAwIHx8IHVzZV90cmFuc3BhcmVuY3kgfHwgZGVsYXkgIT09IDApIHtcbiAgICAgIC8vIC0gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGY5OyAgLy8gRXh0ZW5zaW9uIC8gTGFiZWwuXG4gICAgICBidWZbcCsrXSA9IDQ7ICAvLyBCeXRlIHNpemUuXG5cbiAgICAgIGJ1ZltwKytdID0gZGlzcG9zYWwgPDwgMiB8ICh1c2VfdHJhbnNwYXJlbmN5ID09PSB0cnVlID8gMSA6IDApO1xuICAgICAgYnVmW3ArK10gPSBkZWxheSAmIDB4ZmY7IGJ1ZltwKytdID0gZGVsYXkgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHRyYW5zcGFyZW50X2luZGV4OyAgLy8gVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXG4gICAgICBidWZbcCsrXSA9IDA7ICAvLyBCbG9jayBUZXJtaW5hdG9yLlxuICAgIH1cblxuICAgIC8vIC0gSW1hZ2UgRGVzY3JpcHRvclxuICAgIGJ1ZltwKytdID0gMHgyYzsgIC8vIEltYWdlIFNlcGVyYXRvci5cbiAgICBidWZbcCsrXSA9IHggJiAweGZmOyBidWZbcCsrXSA9IHggPj4gOCAmIDB4ZmY7ICAvLyBMZWZ0LlxuICAgIGJ1ZltwKytdID0geSAmIDB4ZmY7IGJ1ZltwKytdID0geSA+PiA4ICYgMHhmZjsgIC8vIFRvcC5cbiAgICBidWZbcCsrXSA9IHcgJiAweGZmOyBidWZbcCsrXSA9IHcgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBoICYgMHhmZjsgYnVmW3ArK10gPSBoID4+IDggJiAweGZmO1xuICAgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gICAgLy8gVE9ETyhkZWFubSk6IFN1cHBvcnQgaW50ZXJsYWNlLlxuICAgIGJ1ZltwKytdID0gdXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSA/ICgweDgwIHwgKG1pbl9jb2RlX3NpemUtMSkpIDogMDtcblxuICAgIC8vIC0gTG9jYWwgQ29sb3IgVGFibGVcbiAgICBpZiAodXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciByZ2IgPSBwYWxldHRlW2ldO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oXG4gICAgICAgICAgICBidWYsIHAsIG1pbl9jb2RlX3NpemUgPCAyID8gMiA6IG1pbl9jb2RlX3NpemUsIGluZGV4ZWRfcGl4ZWxzKTtcblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVuZGVkID09PSBmYWxzZSkge1xuICAgICAgYnVmW3ArK10gPSAweDNiOyAgLy8gVHJhaWxlci5cbiAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1ZjsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbih2KSB7IGJ1ZiA9IHY7IH07XG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHA7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbih2KSB7IHAgPSB2OyB9O1xufVxuXG4vLyBNYWluIGNvbXByZXNzaW9uIHJvdXRpbmUsIHBhbGV0dGUgaW5kZXhlcyAtPiBMWlcgY29kZSBzdHJlYW0uXG4vLyB8aW5kZXhfc3RyZWFtfCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LlxuZnVuY3Rpb24gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShidWYsIHAsIG1pbl9jb2RlX3NpemUsIGluZGV4X3N0cmVhbSkge1xuICBidWZbcCsrXSA9IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjdXJfc3ViYmxvY2sgPSBwKys7ICAvLyBQb2ludGluZyBhdCB0aGUgbGVuZ3RoIGZpZWxkLlxuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgY29kZV9tYXNrID0gY2xlYXJfY29kZSAtIDE7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIC8vIFdlIGhhdmUgYXQgbW9zdCAxMi1iaXQgY29kZXMsIHNvIHdlIHNob3VsZCBoYXZlIHRvIGhvbGQgYSBtYXggb2YgMTlcbiAgLy8gYml0cyBoZXJlIChhbmQgdGhlbiB3ZSB3b3VsZCB3cml0ZSBvdXQpLlxuICB2YXIgY3VyID0gMDtcblxuICBmdW5jdGlvbiBlbWl0X2J5dGVzX3RvX2J1ZmZlcihiaXRfYmxvY2tfc2l6ZSkge1xuICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gYml0X2Jsb2NrX3NpemUpIHtcbiAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRfY29kZShjKSB7XG4gICAgY3VyIHw9IGMgPDwgY3VyX3NoaWZ0O1xuICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDgpO1xuICB9XG5cbiAgLy8gSSBhbSBub3QgYW4gZXhwZXJ0IG9uIHRoZSB0b3BpYywgYW5kIEkgZG9uJ3Qgd2FudCB0byB3cml0ZSBhIHRoZXNpcy5cbiAgLy8gSG93ZXZlciwgaXQgaXMgZ29vZCB0byBvdXRsaW5lIGhlcmUgdGhlIGJhc2ljIGFsZ29yaXRobSBhbmQgdGhlIGZldyBkYXRhXG4gIC8vIHN0cnVjdHVyZXMgYW5kIG9wdGltaXphdGlvbnMgaGVyZSB0aGF0IG1ha2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBmYXN0LlxuICAvLyBUaGUgYmFzaWMgaWRlYSBiZWhpbmQgTFpXIGlzIHRvIGJ1aWxkIGEgdGFibGUgb2YgcHJldmlvdXNseSBzZWVuIHJ1bnNcbiAgLy8gYWRkcmVzc2VkIGJ5IGEgc2hvcnQgaWQgKGhlcmVpbiBjYWxsZWQgb3V0cHV0IGNvZGUpLiAgQWxsIGRhdGEgaXNcbiAgLy8gcmVmZXJlbmNlZCBieSBhIGNvZGUsIHdoaWNoIHJlcHJlc2VudHMgb25lIG9yIG1vcmUgdmFsdWVzIGZyb20gdGhlXG4gIC8vIG9yaWdpbmFsIGlucHV0IHN0cmVhbS4gIEFsbCBpbnB1dCBieXRlcyBjYW4gYmUgcmVmZXJlbmNlZCBhcyB0aGUgc2FtZVxuICAvLyB2YWx1ZSBhcyBhbiBvdXRwdXQgY29kZS4gIFNvIGlmIHlvdSBkaWRuJ3Qgd2FudCBhbnkgY29tcHJlc3Npb24sIHlvdVxuICAvLyBjb3VsZCBtb3JlIG9yIGxlc3MganVzdCBvdXRwdXQgdGhlIG9yaWdpbmFsIGJ5dGVzIGFzIGNvZGVzICh0aGVyZSBhcmVcbiAgLy8gc29tZSBkZXRhaWxzIHRvIHRoaXMsIGJ1dCBpdCBpcyB0aGUgaWRlYSkuICBJbiBvcmRlciB0byBhY2hpZXZlXG4gIC8vIGNvbXByZXNzaW9uLCB2YWx1ZXMgZ3JlYXRlciB0aGVuIHRoZSBpbnB1dCByYW5nZSAoY29kZXMgY2FuIGJlIHVwIHRvXG4gIC8vIDEyLWJpdCB3aGlsZSBpbnB1dCBvbmx5IDgtYml0KSByZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBwcmV2aW91c2x5IHNlZW5cbiAgLy8gaW5wdXRzLiAgVGhlIGRlY29tcHJlc3NvciBpcyBhYmxlIHRvIGJ1aWxkIHRoZSBzYW1lIG1hcHBpbmcgd2hpbGVcbiAgLy8gZGVjb2RpbmcsIHNvIHRoZXJlIGlzIGFsd2F5cyBhIHNoYXJlZCBjb21tb24ga25vd2xlZGdlIGJldHdlZW4gdGhlXG4gIC8vIGVuY29kaW5nIGFuZCBkZWNvZGVyLCB3aGljaCBpcyBhbHNvIGltcG9ydGFudCBmb3IgXCJ0aW1pbmdcIiBhc3BlY3RzIGxpa2VcbiAgLy8gaG93IHRvIGhhbmRsZSB2YXJpYWJsZSBiaXQgd2lkdGggY29kZSBlbmNvZGluZy5cbiAgLy9cbiAgLy8gT25lIG9idmlvdXMgYnV0IHZlcnkgaW1wb3J0YW50IGNvbnNlcXVlbmNlIG9mIHRoZSB0YWJsZSBzeXN0ZW0gaXMgdGhlcmVcbiAgLy8gaXMgYWx3YXlzIGEgdW5pcXVlIGlkIChhdCBtb3N0IDEyLWJpdHMpIHRvIG1hcCB0aGUgcnVucy4gICdBJyBtaWdodCBiZVxuICAvLyA0LCB0aGVuICdBQScgbWlnaHQgYmUgMTAsICdBQUEnIDExLCAnQUFBQScgMTIsIGV0Yy4gIFRoaXMgcmVsYXRpb25zaGlwXG4gIC8vIGNhbiBiZSB1c2VkIGZvciBhbiBlZmZlY2llbnQgbG9va3VwIHN0cmF0ZWd5IGZvciB0aGUgY29kZSBtYXBwaW5nLiAgV2VcbiAgLy8gbmVlZCB0byBrbm93IGlmIGEgcnVuIGhhcyBiZWVuIHNlZW4gYmVmb3JlLCBhbmQgYmUgYWJsZSB0byBtYXAgdGhhdCBydW5cbiAgLy8gdG8gdGhlIG91dHB1dCBjb2RlLiAgU2luY2Ugd2Ugc3RhcnQgd2l0aCBrbm93biB1bmlxdWUgaWRzIChpbnB1dCBieXRlcyksXG4gIC8vIGFuZCB0aGVuIGZyb20gdGhvc2UgYnVpbGQgbW9yZSB1bmlxdWUgaWRzICh0YWJsZSBlbnRyaWVzKSwgd2UgY2FuXG4gIC8vIGNvbnRpbnVlIHRoaXMgY2hhaW4gKGFsbW9zdCBsaWtlIGEgbGlua2VkIGxpc3QpIHRvIGFsd2F5cyBoYXZlIHNtYWxsXG4gIC8vIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGJ5dGUgY2hhaW5zIGluIHRoZSBlbmNvZGVyLlxuICAvLyBUaGlzIG1lYW5zIGluc3RlYWQgb2YgdHJhY2tpbmcgdGhlIGlucHV0IGJ5dGVzIChBQUFBQkNEKSB0byBrbm93IG91clxuICAvLyBjdXJyZW50IHN0YXRlLCB3ZSBjYW4gdHJhY2sgdGhlIHRhYmxlIGVudHJ5IGZvciBBQUFBQkMgKGl0IGlzIGd1YXJhbnRlZWRcbiAgLy8gdG8gZXhpc3QgYnkgdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtKSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIEQuXG4gIC8vIFRoZXJlZm9yIHRoZSB0dXBsZSBvZiAodGFibGVfZW50cnksIGJ5dGUpIGlzIGd1YXJhbnRlZWQgdG8gYWxzbyBiZVxuICAvLyB1bmlxdWUuICBUaGlzIGFsbG93cyB1cyB0byBjcmVhdGUgYSBzaW1wbGUgbG9va3VwIGtleSBmb3IgbWFwcGluZyBpbnB1dFxuICAvLyBzZXF1ZW5jZXMgdG8gY29kZXMgKHRhYmxlIGluZGljZXMpIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3JlIG9yIHNlYXJjaFxuICAvLyBhbnkgb2YgdGhlIGNvZGUgc2VxdWVuY2VzLiAgU28gaWYgJ0FBQUEnIGhhcyBhIHRhYmxlIGVudHJ5IG9mIDEyLCB0aGVcbiAgLy8gdHVwbGUgb2YgKCdBQUFBJywgSykgZm9yIGFueSBpbnB1dCBieXRlIEsgd2lsbCBiZSB1bmlxdWUsIGFuZCBjYW4gYmUgb3VyXG4gIC8vIGtleS4gIFRoaXMgbGVhZHMgdG8gYSBpbnRlZ2VyIHZhbHVlIGF0IG1vc3QgMjAtYml0cywgd2hpY2ggY2FuIGFsd2F5c1xuICAvLyBmaXQgaW4gYW4gU01JIHZhbHVlIGFuZCBiZSB1c2VkIGFzIGEgZmFzdCBzcGFyc2UgYXJyYXkgLyBvYmplY3Qga2V5LlxuXG4gIC8vIE91dHB1dCBjb2RlIGZvciB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgaW5kZXggYnVmZmVyLlxuICB2YXIgaWJfY29kZSA9IGluZGV4X3N0cmVhbVswXSAmIGNvZGVfbWFzazsgIC8vIExvYWQgZmlyc3QgaW5wdXQgaW5kZXguXG4gIHZhciBjb2RlX3RhYmxlID0geyB9OyAgLy8gS2V5J2Qgb24gb3VyIDIwLWJpdCBcInR1cGxlXCIuXG5cbiAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpOyAgLy8gU3BlYyBzYXlzIGZpcnN0IGNvZGUgc2hvdWxkIGJlIGEgY2xlYXIgY29kZS5cblxuICAvLyBGaXJzdCBpbmRleCBhbHJlYWR5IGxvYWRlZCwgcHJvY2VzcyB0aGUgcmVzdCBvZiB0aGUgc3RyZWFtLlxuICBmb3IgKHZhciBpID0gMSwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHZhciBrID0gaW5kZXhfc3RyZWFtW2ldICYgY29kZV9tYXNrO1xuICAgIHZhciBjdXJfa2V5ID0gaWJfY29kZSA8PCA4IHwgazsgIC8vIChwcmV2LCBrKSB1bmlxdWUgdHVwbGUuXG4gICAgdmFyIGN1cl9jb2RlID0gY29kZV90YWJsZVtjdXJfa2V5XTsgIC8vIGJ1ZmZlciArIGsuXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBjb2RlIHRhYmxlIGVudHJ5LlxuICAgIGlmIChjdXJfY29kZSA9PT0gdW5kZWZpbmVkKSB7ICAvLyBXZSBkb24ndCBoYXZlIGJ1ZmZlciArIGsuXG4gICAgICAvLyBFbWl0IGluZGV4IGJ1ZmZlciAod2l0aG91dCBrKS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5saW5lIHZlcnNpb24gb2YgZW1pdF9jb2RlLCBiZWNhdXNlIHRoaXMgaXMgdGhlIGNvcmVcbiAgICAgIC8vIHdyaXRpbmcgcm91dGluZSBvZiB0aGUgY29tcHJlc3NvciAoYW5kIFY4IGNhbm5vdCBpbmxpbmUgZW1pdF9jb2RlXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGEgY2xvc3VyZSBoZXJlIGluIGEgZGlmZmVyZW50IGNvbnRleHQpLiAgQWRkaXRpb25hbGx5XG4gICAgICAvLyB3ZSBjYW4gY2FsbCBlbWl0X2J5dGVfdG9fYnVmZmVyIGxlc3Mgb2Z0ZW4sIGJlY2F1c2Ugd2UgY2FuIGhhdmVcbiAgICAgIC8vIDMwLWJpdHMgKGZyb20gb3VyIDMxLWJpdCBzaWduZWQgU01JKSwgYW5kIHdlIGtub3cgb3VyIGNvZGVzIHdpbGwgb25seVxuICAgICAgLy8gYmUgMTItYml0cywgc28gY2FuIHNhZmVseSBoYXZlIDE4LWJpdHMgdGhlcmUgd2l0aG91dCBvdmVyZmxvdy5cbiAgICAgIC8vIGVtaXRfY29kZShpYl9jb2RlKTtcbiAgICAgIGN1ciB8PSBpYl9jb2RlIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSA4KSB7XG4gICAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRfY29kZSA9PT0gNDA5NikgeyAgLy8gVGFibGUgZnVsbCwgbmVlZCBhIGNsZWFyLlxuICAgICAgICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7XG4gICAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgICBjb2RlX3RhYmxlID0geyB9O1xuICAgICAgfSBlbHNlIHsgIC8vIFRhYmxlIG5vdCBmdWxsLCBpbnNlcnQgYSBuZXcgZW50cnkuXG4gICAgICAgIC8vIEluY3JlYXNlIG91ciB2YXJpYWJsZSBiaXQgY29kZSBzaXplcyBpZiBuZWNlc3NhcnkuICBUaGlzIGlzIGEgYml0XG4gICAgICAgIC8vIHRyaWNreSBhcyBpdCBpcyBiYXNlZCBvbiBcInRpbWluZ1wiIGJldHdlZW4gdGhlIGVuY29kaW5nIGFuZFxuICAgICAgICAvLyBkZWNvZGVyLiAgRnJvbSB0aGUgZW5jb2RlcnMgcGVyc3BlY3RpdmUgdGhpcyBzaG91bGQgaGFwcGVuIGFmdGVyXG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZW1pdHRlZCB0aGUgaW5kZXggYnVmZmVyIGFuZCBhcmUgYWJvdXQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAvLyBmaXJzdCB0YWJsZSBlbnRyeSB0aGF0IHdvdWxkIG92ZXJmbG93IG91ciBjdXJyZW50IGNvZGUgYml0IHNpemUuXG4gICAgICAgIGlmIChuZXh0X2NvZGUgPj0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkpICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV90YWJsZVtjdXJfa2V5XSA9IG5leHRfY29kZSsrOyAgLy8gSW5zZXJ0IGludG8gY29kZSB0YWJsZS5cbiAgICAgIH1cblxuICAgICAgaWJfY29kZSA9IGs7ICAvLyBJbmRleCBidWZmZXIgdG8gc2luZ2xlIGlucHV0IGsuXG4gICAgfSBlbHNlIHtcbiAgICAgIGliX2NvZGUgPSBjdXJfY29kZTsgIC8vIEluZGV4IGJ1ZmZlciB0byBzZXF1ZW5jZSBpbiBjb2RlIHRhYmxlLlxuICAgIH1cbiAgfVxuXG4gIGVtaXRfY29kZShpYl9jb2RlKTsgIC8vIFRoZXJlIHdpbGwgc3RpbGwgYmUgc29tZXRoaW5nIGluIHRoZSBpbmRleCBidWZmZXIuXG4gIGVtaXRfY29kZShlb2lfY29kZSk7ICAvLyBFbmQgT2YgSW5mb3JtYXRpb24uXG5cbiAgLy8gRmx1c2ggLyBmaW5hbGl6ZSB0aGUgc3ViLWJsb2NrcyBzdHJlYW0gdG8gdGhlIGJ1ZmZlci5cbiAgZW1pdF9ieXRlc190b19idWZmZXIoMSk7XG5cbiAgLy8gRmluaXNoIHRoZSBzdWItYmxvY2tzLCB3cml0aW5nIG91dCBhbnkgdW5maW5pc2hlZCBsZW5ndGhzIGFuZFxuICAvLyB0ZXJtaW5hdGluZyB3aXRoIGEgc3ViLWJsb2NrIG9mIGxlbmd0aCAwLiAgSWYgd2UgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgLy8gYnV0IG5vdCB5ZXQgdXNlZCBhIHN1Yi1ibG9jayBpdCBjYW4ganVzdCBiZWNvbWUgdGhlIHRlcm1pbmF0b3IuXG4gIGlmIChjdXJfc3ViYmxvY2sgKyAxID09PSBwKSB7ICAvLyBTdGFydGVkIGJ1dCB1bnVzZWQuXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSAwO1xuICB9IGVsc2UgeyAgLy8gU3RhcnRlZCBhbmQgdXNlZCwgd3JpdGUgbGVuZ3RoIGFuZCBhZGRpdGlvbmFsIHRlcm1pbmF0b3IgYmxvY2suXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSBwIC0gY3VyX3N1YmJsb2NrIC0gMTtcbiAgICBidWZbcCsrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlcihidWYpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIC8vIC0gSGVhZGVyIChHSUY4N2Egb3IgR0lGODlhKS5cbiAgaWYgKGJ1ZltwKytdICE9PSAweDQ3IHx8ICAgICAgICAgICAgYnVmW3ArK10gIT09IDB4NDkgfHwgYnVmW3ArK10gIT09IDB4NDYgfHxcbiAgICAgIGJ1ZltwKytdICE9PSAweDM4IHx8IChidWZbcCsrXSsxICYgMHhmZCkgIT09IDB4MzggfHwgYnVmW3ArK10gIT09IDB4NjEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdJRiA4N2EvODlhIGhlYWRlci5cIik7XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIHZhciB3aWR0aCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIGhlaWdodCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIHBmMCA9IGJ1ZltwKytdOyAgLy8gPFBhY2tlZCBGaWVsZHM+LlxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfZmxhZyA9IHBmMCA+PiA3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnNfcG93MiA9IHBmMCAmIDB4NztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzID0gMSA8PCAobnVtX2dsb2JhbF9jb2xvcnNfcG93MiArIDEpO1xuICB2YXIgYmFja2dyb3VuZCA9IGJ1ZltwKytdO1xuICBidWZbcCsrXTsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IG51bGw7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9zaXplICAgPSBudWxsO1xuXG4gIGlmIChnbG9iYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gcDtcbiAgICBnbG9iYWxfcGFsZXR0ZV9zaXplID0gbnVtX2dsb2JhbF9jb2xvcnM7XG4gICAgcCArPSBudW1fZ2xvYmFsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgfVxuXG4gIHZhciBub19lb2YgPSB0cnVlO1xuXG4gIHZhciBmcmFtZXMgPSBbIF07XG5cbiAgdmFyIGRlbGF5ID0gMDtcbiAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgdmFyIGRpc3Bvc2FsID0gMDsgIC8vIDAgLSBObyBkaXNwb3NhbCBzcGVjaWZpZWQuXG4gIHZhciBsb29wX2NvdW50ID0gbnVsbDtcblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHdoaWxlIChub19lb2YgJiYgcCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICBjYXNlIDB4MjE6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvbiBCbG9ja1xuICAgICAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICAgICAgY2FzZSAweGZmOiAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgYmxvY2tcbiAgICAgICAgICAgIC8vIFRyeSBpZiBpdCdzIGEgTmV0c2NhcGUgYmxvY2sgKHdpdGggYW5pbWF0aW9uIGxvb3AgY291bnRlcikuXG4gICAgICAgICAgICBpZiAoYnVmW3AgICBdICE9PSAweDBiIHx8ICAvLyAyMSBGRiBhbHJlYWR5IHJlYWQsIGNoZWNrIGJsb2NrIHNpemUuXG4gICAgICAgICAgICAgICAgLy8gTkVUU0NBUEUyLjBcbiAgICAgICAgICAgICAgICBidWZbcCsxIF0gPT0gMHg0ZSAmJiBidWZbcCsyIF0gPT0gMHg0NSAmJiBidWZbcCszIF0gPT0gMHg1NCAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzQgXSA9PSAweDUzICYmIGJ1ZltwKzUgXSA9PSAweDQzICYmIGJ1ZltwKzYgXSA9PSAweDQxICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNyBdID09IDB4NTAgJiYgYnVmW3ArOCBdID09IDB4NDUgJiYgYnVmW3ArOSBdID09IDB4MzIgJiZcbiAgICAgICAgICAgICAgICBidWZbcCsxMF0gPT0gMHgyZSAmJiBidWZbcCsxMV0gPT0gMHgzMCAmJlxuICAgICAgICAgICAgICAgIC8vIFN1Yi1ibG9ja1xuICAgICAgICAgICAgICAgIGJ1ZltwKzEyXSA9PSAweDAzICYmIGJ1ZltwKzEzXSA9PSAweDAxICYmIGJ1ZltwKzE2XSA9PSAwKSB7XG4gICAgICAgICAgICAgIHAgKz0gMTQ7XG4gICAgICAgICAgICAgIGxvb3BfY291bnQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBXZSBkb24ndCBrbm93IHdoYXQgaXQgaXMsIGp1c3QgdHJ5IHRvIGdldCBwYXN0IGl0LlxuICAgICAgICAgICAgICBwICs9IDEyO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4Zjk6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGJ1ZltwKytdICE9PSAweDQgfHwgYnVmW3ArNF0gIT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JhcGhpY3MgZXh0ZW5zaW9uIGJsb2NrLlwiKTtcbiAgICAgICAgICAgIHZhciBwZjEgPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGRlbGF5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGlmICgocGYxICYgMSkgPT09IDApIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3Bvc2FsID0gcGYxID4+IDIgJiAweDc7XG4gICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZTogIC8vIENvbW1lbnQgRXh0ZW5zaW9uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ1Zi5zbGljZShwLCBwK2Jsb2NrX3NpemUpLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5rbm93biBncmFwaGljIGNvbnRyb2wgbGFiZWw6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MmM6ICAvLyBJbWFnZSBEZXNjcmlwdG9yLlxuICAgICAgICB2YXIgeCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB3ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgaCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHBmMiA9IGJ1ZltwKytdO1xuICAgICAgICB2YXIgbG9jYWxfcGFsZXR0ZV9mbGFnID0gcGYyID4+IDc7XG4gICAgICAgIHZhciBpbnRlcmxhY2VfZmxhZyA9IHBmMiA+PiA2ICYgMTtcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnNfcG93MiA9IHBmMiAmIDB4NztcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnMgPSAxIDw8IChudW1fbG9jYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgICAgICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0O1xuICAgICAgICB2YXIgcGFsZXR0ZV9zaXplID0gZ2xvYmFsX3BhbGV0dGVfc2l6ZTtcbiAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2NhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0ID0gcDsgIC8vIE92ZXJyaWRlIHdpdGggbG9jYWwgcGFsZXR0ZS5cbiAgICAgICAgICBwYWxldHRlX3NpemUgPSBudW1fbG9jYWxfY29sb3JzO1xuICAgICAgICAgIHAgKz0gbnVtX2xvY2FsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhX29mZnNldCA9IHA7XG5cbiAgICAgICAgcCsrOyAgLy8gY29kZXNpemVcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lcy5wdXNoKHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgaGFzX2xvY2FsX3BhbGV0dGU6IGhhc19sb2NhbF9wYWxldHRlLFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9vZmZzZXQ6IHBhbGV0dGVfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9zaXplOiBwYWxldHRlX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX29mZnNldDogZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX2xlbmd0aDogcCAtIGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXg6IHRyYW5zcGFyZW50X2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgaW50ZXJsYWNlZDogISFpbnRlcmxhY2VfZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FsOiBkaXNwb3NhbH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDNiOiAgLy8gVHJhaWxlciBNYXJrZXIgKGVuZCBvZiBmaWxlKS5cbiAgICAgICAgbm9fZW9mID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdpZiBibG9jazogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubnVtRnJhbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZyYW1lcy5sZW5ndGg7XG4gIH07XG5cbiAgdGhpcy5sb29wQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9vcF9jb3VudDtcbiAgfTtcblxuICB0aGlzLmZyYW1lSW5mbyA9IGZ1bmN0aW9uKGZyYW1lX251bSkge1xuICAgIGlmIChmcmFtZV9udW0gPCAwIHx8IGZyYW1lX251bSA+PSBmcmFtZXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICByZXR1cm4gZnJhbWVzW2ZyYW1lX251bV07XG4gIH1cblxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gSSB3aWxsIGdvIHRvIGNvcHkgYW5kIHBhc3RlIGhlbGwgb25lIGRheS4uLlxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKGNvZGVfc3RyZWFtLCBwLCBvdXRwdXQsIG91dHB1dF9sZW5ndGgpIHtcbiAgdmFyIG1pbl9jb2RlX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIC8vIE5PVEU6IFRoaXMgc2hhcmVzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGVuY29kZXIsIGJ1dCBoYXMgYSBkaWZmZXJlbnRcbiAgLy8gbWVhbmluZyBoZXJlLiAgSGVyZSB0aGlzIG1hc2tzIGVhY2ggY29kZSBjb21pbmcgZnJvbSB0aGUgY29kZSBzdHJlYW0uXG4gIHZhciBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICB2YXIgY3VyID0gMDtcblxuICB2YXIgb3AgPSAwOyAgLy8gT3V0cHV0IHBvaW50ZXIuXG5cbiAgdmFyIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIC8vIFRPRE8oZGVhbm0pOiBXb3VsZCB1c2luZyBhIFR5cGVkQXJyYXkgYmUgYW55IGZhc3Rlcj8gIEF0IGxlYXN0IGl0IHdvdWxkXG4gIC8vIHNvbHZlIHRoZSBmYXN0IG1vZGUgLyBiYWNraW5nIHN0b3JlIHVuY2VydGFpbnR5LlxuICAvLyB2YXIgY29kZV90YWJsZSA9IEFycmF5KDQwOTYpO1xuICB2YXIgY29kZV90YWJsZSA9IG5ldyBJbnQzMkFycmF5KDQwOTYpOyAgLy8gQ2FuIGJlIHNpZ25lZCwgd2Ugb25seSB1c2UgMjAgYml0cy5cblxuICB2YXIgcHJldl9jb2RlID0gbnVsbDsgIC8vIFRyYWNrIGNvZGUtMS5cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFJlYWQgdXAgdG8gdHdvIGJ5dGVzLCBtYWtpbmcgc3VyZSB3ZSBhbHdheXMgMTItYml0cyBmb3IgbWF4IHNpemVkIGNvZGUuXG4gICAgd2hpbGUgKGN1cl9zaGlmdCA8IDE2KSB7XG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyBObyBtb3JlIGRhdGEgdG8gYmUgcmVhZC5cblxuICAgICAgY3VyIHw9IGNvZGVfc3RyZWFtW3ArK10gPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IDg7XG5cbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAxKSB7ICAvLyBOZXZlciBsZXQgaXQgZ2V0IHRvIDAgdG8gaG9sZCBsb2dpYyBhYm92ZS5cbiAgICAgICAgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107ICAvLyBOZXh0IHN1YmJsb2NrLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLS1zdWJibG9ja19zaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8oZGVhbm0pOiBXZSBzaG91bGQgbmV2ZXIgcmVhbGx5IGdldCBoZXJlLCB3ZSBzaG91bGQgaGF2ZSByZWNlaXZlZFxuICAgIC8vIGFuZCBFT0kuXG4gICAgaWYgKGN1cl9zaGlmdCA8IGN1cl9jb2RlX3NpemUpXG4gICAgICBicmVhaztcblxuICAgIHZhciBjb2RlID0gY3VyICYgY29kZV9tYXNrO1xuICAgIGN1ciA+Pj0gY3VyX2NvZGVfc2l6ZTtcbiAgICBjdXJfc2hpZnQgLT0gY3VyX2NvZGVfc2l6ZTtcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBNYXliZSBzaG91bGQgY2hlY2sgdGhhdCB0aGUgZmlyc3QgY29kZSB3YXMgYSBjbGVhciBjb2RlLFxuICAgIC8vIGF0IGxlYXN0IHRoaXMgaXMgd2hhdCB5b3UncmUgc3VwcG9zZWQgdG8gZG8uICBCdXQgYWN0dWFsbHkgb3VyIGVuY29kZXJcbiAgICAvLyBub3cgZG9lc24ndCBlbWl0IGEgY2xlYXIgY29kZSBmaXJzdCBhbnl3YXkuXG4gICAgaWYgKGNvZGUgPT09IGNsZWFyX2NvZGUpIHtcbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gY2xlYXIgdGhlIHRhYmxlLiAgVGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYVxuICAgICAgLy8gZm9yIGdyZWF0ZXIgZXJyb3IgY2hlY2tpbmcsIGJ1dCB3ZSBkb24ndCByZWFsbHkgZG8gYW55IGFueXdheS4gIFdlXG4gICAgICAvLyB3aWxsIGp1c3QgdHJhY2sgaXQgd2l0aCBuZXh0X2NvZGUgYW5kIG92ZXJ3cml0ZSBvbGQgZW50cmllcy5cblxuICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgcHJldl9jb2RlID9cbiAgICAgIHByZXZfY29kZSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGVvaV9jb2RlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgc2ltaWxhciBzaXR1YXRpb24gYXMgdGhlIGRlY29kZXIsIHdoZXJlIHdlIHdhbnQgdG8gc3RvcmVcbiAgICAvLyB2YXJpYWJsZSBsZW5ndGggZW50cmllcyAoY29kZSB0YWJsZSBlbnRyaWVzKSwgYnV0IHdlIHdhbnQgdG8gZG8gaW4gYVxuICAgIC8vIGZhc3RlciBtYW5uZXIgdGhhbiBhbiBhcnJheSBvZiBhcnJheXMuICBUaGUgY29kZSBiZWxvdyBzdG9yZXMgc29ydCBvZiBhXG4gICAgLy8gbGlua2VkIGxpc3Qgd2l0aGluIHRoZSBjb2RlIHRhYmxlLCBhbmQgdGhlbiBcImNoYXNlc1wiIHRocm91Z2ggaXQgdG9cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGRpY3Rpb25hcnkgZW50cmllcy4gIFdoZW4gYSBuZXcgZW50cnkgaXMgY3JlYXRlZCwganVzdCB0aGVcbiAgICAvLyBsYXN0IGJ5dGUgaXMgc3RvcmVkLCBhbmQgdGhlIHJlc3QgKHByZWZpeCkgb2YgdGhlIGVudHJ5IGlzIG9ubHlcbiAgICAvLyByZWZlcmVuY2VkIGJ5IGl0cyB0YWJsZSBlbnRyeS4gIFRoZW4gdGhlIGNvZGUgY2hhc2VzIHRocm91Z2ggdGhlXG4gICAgLy8gcHJlZml4ZXMgdW50aWwgaXQgcmVhY2hlcyBhIHNpbmdsZSBieXRlIGNvZGUuICBXZSBoYXZlIHRvIGNoYXNlIHR3aWNlLFxuICAgIC8vIGZpcnN0IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCwgYW5kIHRoZW4gdG8gYWN0dWFsbHkgY29weSB0aGUgZGF0YSB0byB0aGVcbiAgICAvLyBvdXRwdXQgKGJhY2t3YXJkcywgc2luY2Ugd2Uga25vdyB0aGUgbGVuZ3RoKS4gIFRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZVxuICAgIC8vIHN0b3Jpbmcgc29tZXRoaW5nIGluIGFuIGludGVybWVkaWF0ZSBzdGFjaywgYnV0IHRoYXQgZG9lc24ndCBtYWtlIGFueVxuICAgIC8vIG1vcmUgc2Vuc2UuICBJIGltcGxlbWVudGVkIGFuIGFwcHJvYWNoIHdoZXJlIGl0IGFsc28gc3RvcmVkIHRoZSBsZW5ndGhcbiAgICAvLyBpbiB0aGUgY29kZSB0YWJsZSwgYWx0aG91Z2ggaXQncyBhIGJpdCB0cmlja3kgYmVjYXVzZSB5b3UgcnVuIG91dCBvZlxuICAgIC8vIGJpdHMgKDEyICsgMTIgKyA4KSwgYnV0IEkgZGlkbid0IG1lYXN1cmUgbXVjaCBpbXByb3ZlbWVudHMgKHRoZSB0YWJsZVxuICAgIC8vIGVudHJpZXMgYXJlIGdlbmVyYWxseSBub3QgdGhlIGxvbmcpLiAgRXZlbiB3aGVuIEkgY3JlYXRlZCBiZW5jaG1hcmtzIGZvclxuICAgIC8vIHZlcnkgbG9uZyB0YWJsZSBlbnRyaWVzIHRoZSBjb21wbGV4aXR5IGRpZCBub3Qgc2VlbSB3b3J0aCBpdC5cbiAgICAvLyBUaGUgY29kZSB0YWJsZSBzdG9yZXMgdGhlIHByZWZpeCBlbnRyeSBpbiAxMiBiaXRzIGFuZCB0aGVuIHRoZSBzdWZmaXhcbiAgICAvLyBieXRlIGluIDggYml0cywgc28gZWFjaCBlbnRyeSBpcyAyMCBiaXRzLlxuXG4gICAgdmFyIGNoYXNlX2NvZGUgPSBjb2RlIDwgbmV4dF9jb2RlID8gY29kZSA6IHByZXZfY29kZTtcblxuICAgIC8vIENoYXNlIHdoYXQgd2Ugd2lsbCBvdXRwdXQsIGVpdGhlciB7Q09ERX0gb3Ige0NPREUtMX0uXG4gICAgdmFyIGNoYXNlX2xlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2UgPiBjbGVhcl9jb2RlKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdID4+IDg7XG4gICAgICArK2NoYXNlX2xlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgayA9IGNoYXNlO1xuXG4gICAgdmFyIG9wX2VuZCA9IG9wICsgY2hhc2VfbGVuZ3RoICsgKGNoYXNlX2NvZGUgIT09IGNvZGUgPyAxIDogMCk7XG4gICAgaWYgKG9wX2VuZCA+IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBsb25nZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWxyZWFkeSBoYXZlIHRoZSBmaXJzdCBieXRlIGZyb20gdGhlIGNoYXNlLCBtaWdodCBhcyB3ZWxsIHdyaXRlIGl0IGZhc3QuXG4gICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIG9wICs9IGNoYXNlX2xlbmd0aDtcbiAgICB2YXIgYiA9IG9wOyAgLy8gVHJhY2sgcG9pbnRlciwgd3JpdGluZyBiYWNrd2FyZHMuXG5cbiAgICBpZiAoY2hhc2VfY29kZSAhPT0gY29kZSkgIC8vIFRoZSBjYXNlIG9mIGVtaXR0aW5nIHtDT0RFLTF9ICsgay5cbiAgICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlX2xlbmd0aC0tKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdO1xuICAgICAgb3V0cHV0Wy0tYl0gPSBjaGFzZSAmIDB4ZmY7ICAvLyBXcml0ZSBiYWNrd2FyZHMuXG4gICAgICBjaGFzZSA+Pj0gODsgIC8vIFB1bGwgZG93biB0byB0aGUgcHJlZml4IGNvZGUuXG4gICAgfVxuXG4gICAgaWYgKHByZXZfY29kZSAhPT0gbnVsbCAmJiBuZXh0X2NvZGUgPCA0MDk2KSB7XG4gICAgICBjb2RlX3RhYmxlW25leHRfY29kZSsrXSA9IHByZXZfY29kZSA8PCA4IHwgaztcbiAgICAgIC8vIFRPRE8oZGVhbm0pOiBGaWd1cmUgb3V0IHRoaXMgY2xlYXJpbmcgdnMgY29kZSBncm93dGggbG9naWMgYmV0dGVyLiAgSVxuICAgICAgLy8gaGF2ZSBhbiBmZWVsaW5nIHRoYXQgaXQgc2hvdWxkIGp1c3QgaGFwcGVuIHNvbWV3aGVyZSBlbHNlLCBmb3Igbm93IGl0XG4gICAgICAvLyBpcyBhd2t3YXJkIGJldHdlZW4gd2hlbiB3ZSBncm93IHBhc3QgdGhlIG1heCBhbmQgdGhlbiBoaXQgYSBjbGVhciBjb2RlLlxuICAgICAgLy8gRm9yIG5vdyBqdXN0IGNoZWNrIGlmIHdlIGhpdCB0aGUgbWF4IDEyLWJpdHMgKHRoZW4gYSBjbGVhciBjb2RlIHNob3VsZFxuICAgICAgLy8gZm9sbG93LCBhbHNvIG9mIGNvdXJzZSBlbmNvZGVkIGluIDEyLWJpdHMpLlxuICAgICAgaWYgKG5leHRfY29kZSA+PSBjb2RlX21hc2srMSAmJiBjdXJfY29kZV9zaXplIDwgMTIpIHtcbiAgICAgICAgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX21hc2sgPSBjb2RlX21hc2sgPDwgMSB8IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldl9jb2RlID0gY29kZTtcbiAgfVxuXG4gIGlmIChvcCAhPT0gb3V0cHV0X2xlbmd0aCkge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gQ29tbW9uSlMuXG50cnkgeyBleHBvcnRzLkdpZldyaXRlciA9IEdpZldyaXRlcjsgZXhwb3J0cy5HaWZSZWFkZXIgPSBHaWZSZWFkZXIgfSBjYXRjaChlKSB7fVxuIiwiLy8gLmRpcm5hbWUsIC5iYXNlbmFtZSwgYW5kIC5leHRuYW1lIG1ldGhvZHMgYXJlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSxcbi8vIGJhY2twb3J0ZWQgYW5kIHRyYW5zcGxpdGVkIHdpdGggQmFiZWwsIHdpdGggYmFja3dhcmRzLWNvbXBhdCBmaXhlc1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgIC8vIHJldHVybiAnLy8nO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxuICAgIHJldHVybiAnLyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbn1cblxuLy8gVXNlcyBhIG1peGVkIGFwcHJvYWNoIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgYXMgZXh0IGJlaGF2aW9yIGNoYW5nZWRcbi8vIGluIG5ldyBOb2RlLmpzIHZlcnNpb25zLCBzbyBvbmx5IGJhc2VuYW1lKCkgYWJvdmUgaXMgYmFja3BvcnRlZCBoZXJlXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24gKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IGJhc2VuYW1lKHBhdGgpO1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gIHZhciBzdGFydFBhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBleHRlbnNpb25cbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoXG50aHJvdWdoLnRocm91Z2ggPSB0aHJvdWdoXG5cbi8vY3JlYXRlIGEgcmVhZGFibGUgd3JpdGFibGUgc3RyZWFtLlxuXG5mdW5jdGlvbiB0aHJvdWdoICh3cml0ZSwgZW5kLCBvcHRzKSB7XG4gIHdyaXRlID0gd3JpdGUgfHwgZnVuY3Rpb24gKGRhdGEpIHsgdGhpcy5xdWV1ZShkYXRhKSB9XG4gIGVuZCA9IGVuZCB8fCBmdW5jdGlvbiAoKSB7IHRoaXMucXVldWUobnVsbCkgfVxuXG4gIHZhciBlbmRlZCA9IGZhbHNlLCBkZXN0cm95ZWQgPSBmYWxzZSwgYnVmZmVyID0gW10sIF9lbmRlZCA9IGZhbHNlXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcblxuLy8gIHN0cmVhbS5hdXRvUGF1c2UgICA9ICEob3B0cyAmJiBvcHRzLmF1dG9QYXVzZSAgID09PSBmYWxzZSlcbiAgc3RyZWFtLmF1dG9EZXN0cm95ID0gIShvcHRzICYmIG9wdHMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKVxuXG4gIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgd3JpdGUuY2FsbCh0aGlzLCBkYXRhKVxuICAgIHJldHVybiAhc3RyZWFtLnBhdXNlZFxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgd2hpbGUoYnVmZmVyLmxlbmd0aCAmJiAhc3RyZWFtLnBhdXNlZCkge1xuICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2hpZnQoKVxuICAgICAgaWYobnVsbCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgICAgZWxzZVxuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLnF1ZXVlID0gc3RyZWFtLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuLy8gICAgY29uc29sZS5lcnJvcihlbmRlZClcbiAgICBpZihfZW5kZWQpIHJldHVybiBzdHJlYW1cbiAgICBpZihkYXRhID09PSBudWxsKSBfZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2VcbiAgICBlbmQuY2FsbChzdHJlYW0pXG4gICAgaWYoIXN0cmVhbS5yZWFkYWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgICB9XG4gICAgZHJhaW4oKVxuICAgIC8vbWF5IGhhdmUgYmVjb21lIHBhdXNlZCBhZ2FpbixcbiAgICAvL2FzIGRyYWluIGVtaXRzICdkYXRhJy5cbiAgICBpZighc3RyZWFtLnBhdXNlZClcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGR1cCA9IHJlcXVpcmUoJ2R1cCcpXG5cbi8vTGVnYWN5IHBvb2wgc3VwcG9ydFxuaWYoIWdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCkge1xuICBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wgPSB7XG4gICAgICBVSU5UOCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMTYgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMzIgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQ4ICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQxNiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQzMiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBGTE9BVCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBET1VCTEUgIDogZHVwKFszMiwgMF0pXG4gICAgLCBEQVRBICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UOEMgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCVUZGRVIgIDogZHVwKFszMiwgMF0pXG4gIH1cbn1cblxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIFBPT0wgPSBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0xcblxuLy9VcGdyYWRlIHBvb2xcbmlmKCFQT09MLlVJTlQ4Qykge1xuICBQT09MLlVJTlQ4QyA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQlVGRkVSKSB7XG4gIFBPT0wuQlVGRkVSID0gZHVwKFszMiwgMF0pXG59XG5cbi8vTmV3IHRlY2huaXF1ZTogT25seSBhbGxvY2F0ZSBmcm9tIEFycmF5QnVmZmVyVmlldyBhbmQgQnVmZmVyXG52YXIgREFUQSAgICA9IFBPT0wuREFUQVxuICAsIEJVRkZFUiAgPSBQT09MLkJVRkZFUlxuXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiBmcmVlKGFycmF5KSB7XG4gIGlmKEJ1ZmZlci5pc0J1ZmZlcihhcnJheSkpIHtcbiAgICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG4gIH0gZWxzZSB7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSAhPT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgYXJyYXkgPSBhcnJheS5idWZmZXJcbiAgICB9XG4gICAgaWYoIWFycmF5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGggfHwgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKXwwXG4gICAgREFUQVtsb2dfbl0ucHVzaChhcnJheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmVlQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKCFidWZmZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGggfHwgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIERBVEFbbG9nX25dLnB1c2goYnVmZmVyKVxufVxuXG5mdW5jdGlvbiBmcmVlVHlwZWRBcnJheShhcnJheSkge1xuICBmcmVlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyKVxufVxuXG5leHBvcnRzLmZyZWVVaW50OCA9XG5leHBvcnRzLmZyZWVVaW50MTYgPVxuZXhwb3J0cy5mcmVlVWludDMyID1cbmV4cG9ydHMuZnJlZUludDggPVxuZXhwb3J0cy5mcmVlSW50MTYgPVxuZXhwb3J0cy5mcmVlSW50MzIgPVxuZXhwb3J0cy5mcmVlRmxvYXQzMiA9IFxuZXhwb3J0cy5mcmVlRmxvYXQgPVxuZXhwb3J0cy5mcmVlRmxvYXQ2NCA9IFxuZXhwb3J0cy5mcmVlRG91YmxlID0gXG5leHBvcnRzLmZyZWVVaW50OENsYW1wZWQgPSBcbmV4cG9ydHMuZnJlZURhdGFWaWV3ID0gZnJlZVR5cGVkQXJyYXlcblxuZXhwb3J0cy5mcmVlQXJyYXlCdWZmZXIgPSBmcmVlQXJyYXlCdWZmZXJcblxuZXhwb3J0cy5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihhcnJheSkge1xuICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMubWFsbG9jID0gZnVuY3Rpb24gbWFsbG9jKG4sIGR0eXBlKSB7XG4gIGlmKGR0eXBlID09PSB1bmRlZmluZWQgfHwgZHR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICByZXR1cm4gbWFsbG9jQXJyYXlCdWZmZXIobilcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goZHR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDE2KG4pXG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDMyKG4pXG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDgobilcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDE2KG4pXG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQzMihuKVxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NGbG9hdChuKVxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRG91YmxlKG4pXG4gICAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKVxuICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0J1ZmZlcihuKVxuICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICBjYXNlICdkYXRhdmlldyc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEYXRhVmlldyhuKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBtYWxsb2NBcnJheUJ1ZmZlcihuKSB7XG4gIHZhciBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGQgPSBEQVRBW2xvZ19uXVxuICBpZihkLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZC5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQXJyYXlCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQXJyYXlCdWZmZXIgPSBtYWxsb2NBcnJheUJ1ZmZlclxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OChuKSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDggPSBtYWxsb2NVaW50OFxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MTYobikge1xuICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQxNiA9IG1hbGxvY1VpbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MzIobikge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQzMiA9IG1hbGxvY1VpbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDggPSBtYWxsb2NJbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDE2ID0gbWFsbG9jSW50MTZcblxuZnVuY3Rpb24gbWFsbG9jSW50MzIobikge1xuICByZXR1cm4gbmV3IEludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MzIgPSBtYWxsb2NJbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NGbG9hdChuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0MzIgPSBleHBvcnRzLm1hbGxvY0Zsb2F0ID0gbWFsbG9jRmxvYXRcblxuZnVuY3Rpb24gbWFsbG9jRG91YmxlKG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoOCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQ2NCA9IGV4cG9ydHMubWFsbG9jRG91YmxlID0gbWFsbG9jRG91YmxlXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKSB7XG4gIGlmKGhhc1VpbnQ4Qykge1xuICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jVWludDhDbGFtcGVkID0gbWFsbG9jVWludDhDbGFtcGVkXG5cbmZ1bmN0aW9uIG1hbGxvY0RhdGFWaWV3KG4pIHtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRGF0YVZpZXcgPSBtYWxsb2NEYXRhVmlld1xuXG5mdW5jdGlvbiBtYWxsb2NCdWZmZXIobikge1xuICBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGNhY2hlID0gQlVGRkVSW2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQnVmZmVyID0gbWFsbG9jQnVmZmVyXG5cbmV4cG9ydHMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gIGZvcih2YXIgaT0wOyBpPDMyOyArK2kpIHtcbiAgICBQT09MLlVJTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5GTE9BVFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5ET1VCTEVbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDhDW2ldLmxlbmd0aCA9IDBcbiAgICBEQVRBW2ldLmxlbmd0aCA9IDBcbiAgICBCVUZGRVJbaV0ubGVuZ3RoID0gMFxuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYj1saXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGNvbXBhcmUoYSwgYikpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZV9lcShsaXN0KSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiID0gbGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSwgYj1hKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGEgIT09IGIpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0LCBjb21wYXJlLCBzb3J0ZWQpIHtcbiAgaWYobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIGlmKGNvbXBhcmUpIHtcbiAgICBpZighc29ydGVkKSB7XG4gICAgICBsaXN0LnNvcnQoY29tcGFyZSlcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpXG4gIH1cbiAgaWYoIXNvcnRlZCkge1xuICAgIGxpc3Quc29ydCgpXG4gIH1cbiAgcmV0dXJuIHVuaXF1ZV9lcShsaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIl19
